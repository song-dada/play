<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>랜덤 미로 게임 (완성본)</title>
    <link rel="stylesheet" href="css/gpt.css">
</head>

<body>
    <div class="wrap">
        <div id="ads"></div>
        <div id="hubmap">
            <!-- HUD (좌상단): 레벨 / 아이템 / 도감 버튼 -->
            <div class="hud">
                <div class="hubup">
                    <div class="panel" id="levelPanel">레벨: <span id="levelText">1</span></div>
                    <div class="panel items" id="itemPanel">아이템: <span id="itemKey">❌</span> <span
                            id="itemCompass">❌</span>

                    </div>
                </div>
                <div class="panel"><button id="codexBtn">📖 도감</button></div>
            </div>

            <!-- 미니맵 (우상단) -->
            <div id="miniWrapper"><canvas id="miniMap" width="260" height="260"></canvas></div>

        </div>

        <!-- 중앙 미로 캔버스 (fixed size) -->
        <div id="gameWrapper">
            <canvas id="game" width="480" height="480"></canvas>

        </div>
        <!-- 조이스틱 (하단 중앙 고정) -->
        <div id="joystickWrap">
            <div id="joystick">
                <div id="stick"></div>
            </div>
        </div>
    </div>

    <!-- 오버레이: 인트로/스토리/코덱스 상세 등이 재사용 -->
    <div id="overlay" class="overlay">
        <div class="panel" id="overlayPanel">
            <!-- 콘텐츠 동적 삽입 -->
        </div>
    </div>

    <!-- 코덱스 전용 오버레이 (리스트) -->
    <div id="codexOverlay" class="overlay">
        <div class="panel" id="codexPanel"></div>
    </div>

    <script>
        /* =====================================================
           랜덤 미로 게임 - 통합 완성본
           - 요구사항 반영:
             인트로 -> 시작 버튼 -> 인트로 스토리(도감 자동 해금) -> 미로 시작
             아이템: 열쇠(key), 나침반(compass) (랜덤 배치)
             열쇠 소지 시 출구 통과 가능
             revealAround() 시야 구현 + miniMap: 지나간 길만 표시
             도감(localStorage): 해금 여부 + (compass) 메시지 저장
             블럭 이미지(1x1~3x3) 자동 스케일링
             HUD / 중앙미로 / 우상단 미니맵 / 하단 중앙 조이스틱
           ===================================================== */

        ///// 저장 키 & 초기 스토리 데이터
        const STORAGE_KEY = 'maze_collectedStories_v1';
        // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
        let startTime = 0;           // 레벨 시작 시 설정 (이미 쓰고 계신 변수)
        let timeLimitSeconds = 90;   // 현재 레벨의 시간제한(초)
        let timeUp = false;          // 시간초과 발생 플래그
        // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

        // 스토리 슬롯 및 텍스트 (compass는 레벨별 다중 메시지 풀)
        const storySlots = [
            { id: 'intro', label: '프롤로그' },
            { id: 'key', label: '열쇠' },
            // gem 제거 (회의 결과)
            { id: 'compass', label: '나침반' },
            { id: 'level1', label: '레벨1' },
            { id: 'level2', label: '레벨2' },
            { id: 'ending', label: '엔딩' }
        ];

        const storyTexts = {
            intro: ['깊은 미궁 속으로 발을 내딛었다. 어둠 속에서 무언가 속삭이는 듯하다...'],
            key: ['낡은 열쇠를 손에 넣었다. 녹슨 금속이 차갑게 닿는다.'],
            // compass: 레벨별 메시지 풀 (랜덤 선택)
            compass: [
                ['서쪽에서 기묘한 기운이 느껴진다...', '나침반이 갑자기 흔들리며 방향을 잃는다...'],
                ['멀리서 낮은 울음소리가 들려온다...', '벽에 새겨진 고대 문양이 눈에 들어왔다...'],
                ['‘출구는 없다’는 목소리가 메아리쳤다...', '차갑고 습한 공기가 더 짙어졌다...']
            ],
            level1: ['첫 번째 미궁을 통과했다!'],
            level2: ['더 깊은 곳으로 발걸음을 옮긴다...'],
            ending: ['드디어 미궁에서 탈출했다!']
        };

        let collectedStories = {}; // { id: {unlocked:true, text: '...'} } or { id: true }

        function loadStories() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) { collectedStories = {}; return; }
                collectedStories = JSON.parse(raw) || {};
            } catch (e) { console.warn('loadStories error', e); collectedStories = {}; }
        }
        function saveStories() {
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(collectedStories)); } catch (e) { console.warn('saveStories', e); }
        }

        // 권장 기본값 함수 (원하면 조정)
        function getTimeLimitForLevel(lv) {
            if (lv <= 1) return 90;      // 1분30초
            if (lv === 2) return 120;    // 2분
            if (lv === 3) return 150;    // 2분30초
            // 레벨이 높아질수록 +30초씩
            return 150 + (lv - 3) * 30;
        }

        /* ---------------------------
           캔버스 세팅
           --------------------------- */
        const gameCanvas = document.getElementById('game');
        const ctx = gameCanvas.getContext('2d');
        const miniCanvas = document.getElementById('miniMap');
        const miniCtx = miniCanvas.getContext('2d');

        let tileSize = 30; // 타일 픽셀 크기 (고정)
        const getCanvasSize = () => ({ w: gameCanvas.width, h: gameCanvas.height });

        /* ---------------------------
           블럭 이미지 (1x1 ~ 3x3)
           - 제공된 이미지를 tileSize에 맞춰 자동 스케일링해서 그립니다.
           - 경로는 필요시 교체하세요.
           --------------------------- */
        const blockImages = {
            "1x1": new Image(), "1x2": new Image(), "1x3": new Image(),
            "2x1": new Image(), "2x2": new Image(), "2x3": new Image(),
            "3x1": new Image(), "3x2": new Image(), "3x3": new Image()
        };
        // (이미지 경로: 필요시 바꾸세요)
        blockImages["1x1"].src = "img/block_1x1.png";
        blockImages["1x2"].src = "img/block_1x2.png";
        blockImages["1x3"].src = "img/block_1x3.png";
        blockImages["2x1"].src = "img/block_2x1.png";
        blockImages["2x2"].src = "img/block_2x2.png";
        blockImages["2x3"].src = "img/block_2x3.png";
        blockImages["3x1"].src = "img/block_3x1.png";
        blockImages["3x2"].src = "img/block_3x2.png";
        blockImages["3x3"].src = "img/block_3x3.png";

        /* ---------------------------
           게임 상태 변수
           --------------------------- */
        let rows = 21, cols = 21; // 기본
        let maze = []; // 2D array: 1=wall,0=path
        let revealMap = []; // 시야(보여진 타일) boolean
        let visitedMap = []; // 미니맵용: 지나간 길만 true
        let items = []; // [{x,y,type, collected, storyId, message?}]
        let level = 1;

        let player = { x: 1.5, y: 1.5, size: 0.65, vx: 0, vy: 0 }; // 좌표는 타일 단위 (1.5 = 중앙)
        let speed = 4.2; // tiles/sec (이 값은 조이스틱/키보드에 의해 곱해짐)
        let lastTime = performance.now();

        let goal = { x: cols - 2, y: rows - 2 };

        /* ---------------------------
           DOM references
           --------------------------- */
        const overlay = document.getElementById('overlay');
        const overlayPanel = document.getElementById('overlayPanel');
        const codexOverlay = document.getElementById('codexOverlay');
        const codexPanel = document.getElementById('codexPanel');
        const codexBtn = document.getElementById('codexBtn');
        const levelText = document.getElementById('levelText');
        const itemKeyEl = document.getElementById('itemKey');
        const itemCompassEl = document.getElementById('itemCompass');

        /* ---------------------------
           유틸 함수: inBounds, randInt, distance
           --------------------------- */
        function inBounds(x, y) { return x >= 0 && y >= 0 && x < cols && y < rows; }
        function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
        function dist(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }

        /* ===========================
           미로 생성 (DFS Carve)
           - 홀수 좌표 기반 carve 방식 (1칸 벽/길 스타일 유지)
           =========================== */
        function createEmptyMaze(w, h) {
            const m = [];
            for (let y = 0; y < h; y++) { m[y] = []; for (let x = 0; x < w; x++) m[y][x] = 1; }
            return m;
        }
        function generateMaze(w, h) {
            cols = w; rows = h;
            maze = createEmptyMaze(cols, rows);
            // carve from (1,1)
            const stack = [];
            maze[1][1] = 0;
            stack.push({ x: 1, y: 1 });
            const deltas = [[0, -2], [2, 0], [0, 2], [-2, 0]];
            while (stack.length) {
                const cur = stack[stack.length - 1];
                let neighbors = [];
                for (const d of deltas) {
                    const nx = cur.x + d[0], ny = cur.y + d[1];
                    if (inBounds(nx, ny) && maze[ny][nx] === 1) neighbors.push(d);
                }
                if (neighbors.length === 0) { stack.pop(); continue; }
                const ch = neighbors[Math.floor(Math.random() * neighbors.length)];
                const betweenX = cur.x + ch[0] / 2;
                const betweenY = cur.y + ch[1] / 2;
                const nx = cur.x + ch[0];
                const ny = cur.y + ch[1];
                maze[betweenY][betweenX] = 0;
                maze[ny][nx] = 0;
                stack.push({ x: nx, y: ny });
            }
            // goal ensure open
            let possibleGoals = [];

            // 상단 테두리: y=0
            for (let x = 1; x < cols - 1; x++) {
                if (maze[1][x] === 0) possibleGoals.push({ x, y: 0 }); // 상단 벽, 바로 아래가 길
            }

            // 하단 테두리: y=rows-1
            for (let x = 1; x < cols - 1; x++) {
                if (maze[rows - 2][x] === 0) possibleGoals.push({ x, y: rows - 1 }); // 하단 벽, 바로 위가 길
            }

            // 좌측 테두리: x=0
            for (let y = 1; y < rows - 1; y++) {
                if (maze[y][1] === 0) possibleGoals.push({ x: 0, y }); // 좌측 벽, 바로 오른쪽이 길
            }

            // 우측 테두리: x=cols-1
            for (let y = 1; y < rows - 1; y++) {
                if (maze[y][cols - 2] === 0) possibleGoals.push({ x: cols - 1, y }); // 우측 벽, 바로 왼쪽이 길
            }

            // fallback: 맨 오른쪽 아래 안쪽 칸
            if (possibleGoals.length === 0) possibleGoals.push({ x: cols - 2, y: rows - 2 });

            // 랜덤 선택
            goal = possibleGoals[Math.floor(Math.random() * possibleGoals.length)];

            // goal 칸은 벽으로 유지 (출구 표시용)
            maze[goal.y][goal.x] = 2;

            // reveal/visited 초기화
            revealMap = Array.from({ length: rows }, () => Array(cols).fill(false));
            visitedMap = Array.from({ length: rows }, () => Array(cols).fill(false));
        }

        /* ===========================
           아이템 배치
           - key(열쇠) 1개, compass(나침반) 레벨당 1개
           - 랜덤 배치(길 위), 시작/종료 근처는 피함
           =========================== */
        function findRandomPathCell(avoidNearStart = true) {
            for (let tries = 0; tries < 5000; tries++) {
                const x = randInt(1, cols - 2);
                const y = randInt(1, rows - 2);
                if (maze[y][x] !== 0) continue;
                // avoid start/goal proximity
                if (avoidNearStart) {
                    if (Math.abs(x - 1) + Math.abs(y - 1) < 4) continue;
                    if (Math.abs(x - goal.x) + Math.abs(y - goal.y) < 4) continue;
                }
                return { x, y };
            }
            // fallback: first path cell
            for (let y = 1; y < rows - 1; y++) for (let x = 1; x < cols - 1; x++) if (maze[y][x] === 0) return { x, y };
            return { x: 1, y: 1 };
        }

        function placeItemsForLevel(lv) {
            console.trace("startLevel 호출", { lv, level });
            items = [];
            // key
            const k = findRandomPathCell(true);
            items.push({ type: 'key', x: k.x, y: k.y, collected: false, storyId: 'key' });
            // compass (one per level)
            const c = findRandomPathCell(true);
            // select random message from pool (if exists for level)
            let pool = (storyTexts.compass && storyTexts.compass[lv - 1]) || (storyTexts.compass && storyTexts.compass[0]) || ['나침반이 조용하다.'];
            const chosen = pool[Math.floor(Math.random() * pool.length)];
            const storyId = `compass_${lv}`;
            items.push({ type: 'compass', x: c.x, y: c.y, collected: false, storyId: storyId, message: chosen });
        }

        /* ===========================
           충돌 검사 (player.size 반영)
           - player coords are in tiles. size is fraction of tile (e.g. 0.65)
           - check four corners in tile coords (floor)
           =========================== */
        function canMoveTo(newX, newY) {
            const half = player.size / 2;
            const corners = [
                { x: newX - half, y: newY - half },
                { x: newX + half, y: newY - half },
                { x: newX - half, y: newY + half },
                { x: newX + half, y: newY + half }
            ];
            for (const c of corners) {
                const tx = Math.floor(c.x);
                const ty = Math.floor(c.y);
                // if (!inBounds(tx, ty) ) return false;
                if (!inBounds(tx, ty) || maze[ty][tx] === 1) return false;
                return (maze[ty][tx] === 0 || maze[ty][tx] === 2);
                // if (maze[ty][tx] === 1) return false;
            }
            return true;
        }

        /* ===========================
           시야 & 미니맵
           - revealAround(px,py): 주변 revealRadius 타일을 true로 설정
           - visitedMap: 플레이어가 지나간 path만 true (미니맵용)
           =========================== */
        let revealRadius = 3;
        function revealAround(px, py) {
            const cx = Math.floor(px), cy = Math.floor(py);
            for (let dy = -revealRadius; dy <= revealRadius; dy++) {
                for (let dx = -revealRadius; dx <= revealRadius; dx++) {
                    const x = cx + dx, y = cy + dy;
                    if (inBounds(x, y)) {
                        revealMap[y][x] = true;
                    }
                }
            }
            // mark current tile as visited (miniMap)
            if (inBounds(cx, cy) && maze[cy][cx] === 0) visitedMap[cy][cx] = true;
        }

        /* ===========================
           스토리(도감) 해금 및 오버레이 표시
           - unlockStory(id, text?)
           - stored format: collectedStories[id] = {unlocked:true, text: '...'} OR true
           - 인트로는 처음 시작 버튼 클릭 후 호출하여 1회 해금
           =========================== */
        function unlockStory(id, text) {
            // If already unlocked, still may show overlay if text provided? We'll avoid re-showing on duplicate unlock.
            if (!collectedStories[id]) {
                collectedStories[id] = { unlocked: true, text: text || (storyTexts[id] ? (Array.isArray(storyTexts[id]) ? storyTexts[id][0] : storyTexts[id]) : '') };
                saveStories();
            }
            // Show overlay with text (pull stored text if present)
            const data = collectedStories[id];
            const showText = (data && data.text) || text || (storyTexts[id] ? (Array.isArray(storyTexts[id]) ? storyTexts[id][0] : storyTexts[id]) : '(기록 없음)');
            showStoryOverlay(`${id}`, showText, 3000); // 자동으로 3초 후 닫힘
        }

        /* Show overlay with text and optional image; autoCloseMs = milliseconds or 0 for no auto-close */
        function showStoryOverlay(title, text, autoCloseMs = 3000) {
            overlayPanel.innerHTML = '';
            // simple layout: title, text (and placeholder for image if needed)
            const h = document.createElement('div');
            h.innerHTML = `<h3 style="margin:0 0 6px">${title}</h3>`;
            overlayPanel.appendChild(h);
            if (text && text.length > 0) {
                const p = document.createElement('p');
                p.textContent = text;
                overlayPanel.appendChild(p);
            }
            // close button area
            const actions = document.createElement('div');
            actions.className = 'actions';
            const closeBtn = document.createElement('button');
            closeBtn.className = 'ghost';
            closeBtn.textContent = '닫기';
            closeBtn.onclick = () => { overlay.style.display = 'none'; };
            actions.appendChild(closeBtn);
            overlayPanel.appendChild(actions);

            overlay.style.display = 'flex';
            if (autoCloseMs && autoCloseMs > 0) {
                setTimeout(() => { if (overlay.style.display === 'flex') overlay.style.display = 'none'; }, autoCloseMs);
            }
        }

        /* ---------------------------
           코덱스(도감) UI
           - 리스트 표시, 클릭하면 상세 도감 텍스트를 overlay로 표시
           --------------------------- */
        function openCodex() {
            codexPanel.innerHTML = '<h3 style="margin-top:0">스토리 도감</h3>';
            storySlots.forEach(s => {
                const owned = !!collectedStories[s.id];
                const mark = owned ? '✅' : '❌';
                // choose display text: if unlocked with text then show preview, else ??? 
                let preview = '???';
                if (owned) {
                    const d = collectedStories[s.id];
                    if (d && d.text) preview = d.text.length > 80 ? d.text.slice(0, 77) + '...' : d.text;
                    else preview = (storyTexts[s.id] && storyTexts[s.id][0]) || '해금됨';
                }
                const row = document.createElement('div');
                row.style.padding = '8px 0';
                row.style.borderBottom = '1px dashed #222';
                row.innerHTML = `<strong style="display:block">${mark} ${s.label}</strong><small>${preview}</small>`;
                row.style.cursor = 'pointer';
                row.onclick = () => {
                    // show detail overlay for this slot
                    const fullText = (collectedStories[s.id] && collectedStories[s.id].text) || (storyTexts[s.id] && storyTexts[s.id][0]) || '(잠금)';
                    showStoryOverlay(s.label, fullText, 0); // 0 -> don't auto close, let user close
                    codexOverlay.style.display = 'none';
                };
                codexPanel.appendChild(row);
            });
            const close = document.createElement('div');
            close.style.marginTop = '8px';
            close.innerHTML = `<div style="text-align:right"><button class="primary" id="codexClose">닫기</button></div>`;
            codexPanel.appendChild(close);
            codexOverlay.style.display = 'flex';
            document.getElementById('codexClose').onclick = () => { codexOverlay.style.display = 'none'; };
        }

        /* ---------------------------
           HUD 업데이트
           --------------------------- */
        function updateHud() {
            levelText.textContent = level;
            itemKeyEl.textContent = collectedStories['key'] ? '🔑' : '❌';
            // compass could be per-level: show if any compass_n unlocked for current or previous levels
            const compId = `compass_${level}`;
            const hasCompass = !!(collectedStories[compId] || collectedStories['compass']);
            itemCompassEl.textContent = hasCompass ? '🧭' : '❌';
        }

        /* ---------------------------
           아이템 수집 처리
           - items 배열을 순회하여 플레이어가 가까이 가면 수집
           - 수집 시 도감 unlock 및 overlay 표시 (compass는 메시지 기록)
           --------------------------- */
        function tryCollectItems() {
            for (let i = items.length - 1; i >= 0; i--) {
                const it = items[i];
                if (!it) continue;
                const d = dist(player.x, player.y, it.x + 0.5, it.y + 0.5);
                if (d < 0.8) {
                    // collect
                    it.collected = true;
                    items.splice(i, 1);
                    if (it.type === 'compass') {
                        // store compass message under storyId (compass_level)
                        collectedStories[it.storyId] = { unlocked: true, text: it.message };
                        saveStories();
                        showStoryOverlay('나침반', it.message, 3000);
                    } else if (it.type === 'key') {
                        hasKey = true; // 현재 레벨에서 열쇠 소유
                        // key: fixed story text
                        unlockStory('key', storyTexts.key[0]);
                    } else {
                        unlockStory(it.storyId, it.message || '아이템 획득');
                    }
                    updateHud();
                    // small toast
                    showToast(`획득: ${it.type}`);
                }
            }
        }

        /* ---------------------------
           토스트
           --------------------------- */
        function showToast(text, ms = 1600) {
            const t = document.createElement('div'); t.className = 'toast'; t.textContent = text;
            document.body.appendChild(t);
            setTimeout(() => { t.remove(); }, ms);
        }

        /* ---------------------------
           목표(출구) 도달 처리
           - 열쇠가 있어야 통과 가능 (key 해금)
           --------------------------- */
        let hasKey = false;

        let levelCleared = false;

        function checkGoal() {
            const d = dist(player.x, player.y, goal.x + 0.5, goal.y + 0.5);

            console.log("checkGoal 실행", { d, levelCleared, hasKey, level });

            if (d < 0.8 && !levelCleared) {
                if (hasKey) {
                    levelCleared = true;

                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                    console.log("GOAL!", { elapsed });

                    // ⚠️ 레벨 이동은 alert 뒤로 지연시킴
                    setTimeout(() => {
                        // alert(`레벨 ${level} 클리어!\n플레이타임: ${elapsed}초`);

                        if (level < 3) {
                            level++;
                            startLevel(level);
                            levelCleared = false; // 여기서만 초기화
                        } else {
                            alert("레벨 3까지 클리어 완료!");
                        }
                    }, 100);  // alert 띄운 후에 레벨 이동
                } else {
                    console.log("열쇠 없음");
                    showToast("아이템이 부족합니다! 🔑를 모아야 합니다.", 1800);
                }
            }
        }

        /* ===========================
           그리기 로직
           - 메인 캔버스: 타일(벽/바닥), 블럭 이미지 적용, 아이템, 플레이어, 출구
           - 미니맵: visitedMap에 따라 지나간 길만 표시
           =========================== */

        function getBlockRunSize(x, y) {
            // Count how many consecutive wall tiles to the right (w) and down (h), max 3
            if (maze[y][x] !== 1) return { w: 0, h: 0 };
            let w = 1, h = 1;
            for (let sx = 1; sx < 3; sx++) {
                if (inBounds(x + sx, y) && maze[y][x + sx] === 1) w++; else break;
            }
            for (let sy = 1; sy < 3; sy++) {
                if (inBounds(x, y + sy) && maze[y + sy][x] === 1) h++; else break;
            }
            w = Math.min(3, w); h = Math.min(3, h);
            return { w, h };
        }


        function getBlockType(x, y) {
            let h = 1, w = 1;

            // 오른쪽이 벽이면 가로 확장
            if (maze[y][x + 1] === 1) w++;
            // 아래가 벽이면 세로 확장
            if (maze[y + 1] && maze[y + 1][x] === 1) h++;

            return `${w}x${h}`; // "1x1", "2x1", "1x2", "2x2" 등
        }


        function draw() {
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            // 카메라 오프셋: 플레이어를 중앙에 고정
            const offsetX = gameCanvas.width / 2 - player.x * tileSize;
            const offsetY = gameCanvas.height / 2 - player.y * tileSize;

            // 방문 체크용 배열
            const visited = Array.from({ length: rows }, () => Array(cols).fill(false));

            // 벽 & 길
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] === 1 && !visited[y][x]) {
                        let placed = false;

                        // --- 가로 그룹핑 (최대 3칸) ---
                        let lenX = 1;
                        while (
                            x + lenX < cols &&
                            lenX < 3 &&
                            maze[y][x + lenX] === 1 &&
                            !visited[y][x + lenX]
                        ) {
                            lenX++;
                        }
                        if (lenX > 1) {
                            let type = `1x${lenX}`; // "1x2", "1x3"
                            let img = blockImages[type] || blockImages["1x1"];
                            ctx.drawImage(
                                img,
                                x * tileSize + offsetX,
                                y * tileSize + offsetY,
                                tileSize * lenX,
                                tileSize
                            );
                            for (let i = 0; i < lenX; i++) visited[y][x + i] = true;
                            placed = true;
                        }

                        // --- 세로 그룹핑 (최대 3칸) ---
                        if (!placed) {
                            let lenY = 1;
                            while (
                                y + lenY < rows &&
                                lenY < 3 &&
                                maze[y + lenY][x] === 1 &&
                                !visited[y + lenY][x]
                            ) {
                                lenY++;
                            }
                            if (lenY > 1) {
                                let type = `${lenY}x1`; // "2x1", "3x1"
                                let img = blockImages[type] || blockImages["1x1"];
                                ctx.drawImage(
                                    img,
                                    x * tileSize + offsetX,
                                    y * tileSize + offsetY,
                                    tileSize,
                                    tileSize * lenY
                                );
                                for (let i = 0; i < lenY; i++) visited[y + i][x] = true;
                                placed = true;
                            }
                        }

                        // --- 단일 블럭 ---
                        if (!placed) {
                            let img = blockImages["1x1"];
                            ctx.drawImage(
                                img,
                                x * tileSize + offsetX,
                                y * tileSize + offsetY,
                                tileSize,
                                tileSize
                            );
                            visited[y][x] = true;
                        }
                    } else if (maze[y][x] === 0) {
                        // 길
                        ctx.fillStyle = "white";
                        ctx.fillRect(
                            x * tileSize + offsetX,
                            y * tileSize + offsetY,
                            tileSize,
                            tileSize
                        );
                    }
                }
            }

            // 목표
            ctx.fillStyle = "green";
            ctx.fillRect(
                goal.x * tileSize + offsetX,
                goal.y * tileSize + offsetY,
                tileSize,
                tileSize
            );

            // 아이템
            items.forEach(it => {
                ctx.fillStyle = it.type === "compass" ? "purple" : "gold";
                ctx.beginPath();
                ctx.arc(
                    it.x * tileSize + tileSize / 2 + offsetX,
                    it.y * tileSize + tileSize / 2 + offsetY,
                    tileSize / 3,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });

            // 플레이어 (항상 중앙 고정)
            const psize = tileSize * player.size;
            ctx.fillStyle = "red";
            ctx.fillRect(
                gameCanvas.width / 2 - psize / 2,
                gameCanvas.height / 2 - psize / 2,
                psize,
                psize
            );

            // 시간 표시를 캔버스에 그릴 경우
            drawTimer(ctx);
        }



        /* ---------------------------
           미니맵 렌더링
           - visitedMap true인 path 타일만 표시
           - player marker + goal marker
           --------------------------- */
        function drawMiniMap() {
            const w = miniCanvas.width, h = miniCanvas.height;
            miniCtx.clearRect(0, 0, w, h);
            const cellW = w / cols, cellH = h / rows;
            // background
            miniCtx.fillStyle = '#030303';
            miniCtx.fillRect(0, 0, w, h);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (visitedMap[y][x] && maze[y][x] === 0) {
                        miniCtx.fillStyle = '#bfbfbf';
                        miniCtx.fillRect(x * cellW, y * cellH, cellW, cellH);
                    }
                }
            }
            // goal marker (if visited/revealed maybe show regardless)
            miniCtx.fillStyle = '#2ecc71';
            miniCtx.fillRect(goal.x * cellW + cellW * 0.15, goal.y * cellW + cellW * 0.15, cellW * 0.7, cellH * 0.7);

            // items (if visited tile) small circles
            for (const it of items) {
                if (visitedMap[it.y] && visitedMap[it.y][it.x]) {
                    miniCtx.beginPath();
                    miniCtx.fillStyle = (it.type === 'key') ? '#ffcc00' : '#7f5cff';
                    miniCtx.arc((it.x + 0.5) * cellW, (it.y + 0.5) * cellH, Math.min(cellW, cellH) * 0.25, 0, Math.PI * 2);
                    miniCtx.fill();
                }
            }
            // player marker
            miniCtx.fillStyle = '#ff4b4b';
            miniCtx.beginPath();
            miniCtx.arc((player.x) * cellW, (player.y) * cellH, Math.min(cellW, cellH) * 0.32, 0, Math.PI * 2);
            miniCtx.fill();
        }

        /* ---------------------------
           입력 처리: 키보드 (WASD / arrows)
           --------------------------- */
        const keys = {};
        window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

        /* ---------------------------
           조이스틱 (하단 중앙 고정)
           - touch / mouse 지원
           --------------------------- */
        const joystick = document.getElementById('joystick');
        const stick = document.getElementById('stick');
        let joyActive = false;
        let joyCenter = null;
        function initJoyCenter() { const r = joystick.getBoundingClientRect(); joyCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2 }; }
        initJoyCenter();
        window.addEventListener('resize', initJoyCenter);

        function setStickPos(dx, dy) {
            // dx,dy in range [-1,1]
            const max = (joystick.clientWidth / 2 - stick.clientWidth / 2 - 6);
            const tx = Math.max(-1, Math.min(1, dx)) * max;
            const ty = Math.max(-1, Math.min(1, dy)) * max;
            stick.style.transform = `translate(${tx}px, ${ty}px)`;
        }

        function startJoy(x, y) {
            joyActive = true;
            initJoyCenter();
            updateJoy(x, y);
        }
        function updateJoy(x, y) {
            if (!joyActive || !joyCenter) return;
            let dx = x - joyCenter.x;
            let dy = y - joyCenter.y;
            const distv = Math.hypot(dx, dy);
            const max = joystick.clientWidth / 2;
            if (distv > max) { dx = dx / distv * max; dy = dy / distv * max; }
            const nx = dx / max, ny = dy / max;
            // store velocity in tiles/sec
            player.vx = nx * speed;
            player.vy = ny * speed;
            setStickPos(nx, ny);
        }
        function endJoy() {
            joyActive = false;
            player.vx = 0; player.vy = 0;
            setStickPos(0, 0);
        }

        joystick.addEventListener('touchstart', e => { e.preventDefault(); startJoy(e.touches[0].clientX, e.touches[0].clientY); });
        joystick.addEventListener('touchmove', e => { e.preventDefault(); updateJoy(e.touches[0].clientX, e.touches[0].clientY); });
        joystick.addEventListener('touchend', e => { e.preventDefault(); endJoy(); });

        joystick.addEventListener('mousedown', e => { e.preventDefault(); startJoy(e.clientX, e.clientY); });
        window.addEventListener('mousemove', e => { if (joyActive) updateJoy(e.clientX, e.clientY); });
        window.addEventListener('mouseup', e => { if (joyActive) endJoy(); });

        /* ---------------------------
           메인 업데이트 루프
           - 입력 처리(키보드+조이스틱) -> 물리(충돌검사) -> 시야/수집/목표 체크 -> 그리기
           --------------------------- */

        // 플레이어 크기를 고려한 충돌 검사
        function canMoveTo(x, y) {
            const half = player.size / 2; // 플레이어 절반 크기

            // 플레이어 네 꼭짓점 좌표
            const corners = [
                { cx: x - half, cy: y - half },
                { cx: x + half, cy: y - half },
                { cx: x - half, cy: y + half },
                { cx: x + half, cy: y + half }
            ];

            for (const p of corners) {
                const gx = Math.floor(p.cx);
                const gy = Math.floor(p.cy);
                // 범위 밖이거나 벽이면 이동 불가
                if (!inBounds(gx, gy) || maze[gy][gx] === 1) {
                    return false;
                }
            }
            return true;
        }

        // =========================
        // update 함수 (플레이어 이동, 충돌, 아이템, 출구 처리)
        // =========================
        function update(now) {
            const dt = Math.min(0.05, (now - lastTime) / 1000);
            lastTime = now;

            // ── 키보드 입력 처리 (조이스틱이 비활성일 때만)
            if (!joyActive) {
                let ix = 0, iy = 0;
                if (keys['arrowup'] || keys['w']) iy -= 1;
                if (keys['arrowdown'] || keys['s']) iy += 1;
                if (keys['arrowleft'] || keys['a']) ix -= 1;
                if (keys['arrowright'] || keys['d']) ix += 1;
                if (ix !== 0 || iy !== 0) {
                    const len = Math.hypot(ix, iy) || 1;
                    player.vx = (ix / len) * speed;
                    player.vy = (iy / len) * speed;
                } else {
                    player.vx = 0;
                    player.vy = 0;
                }
            }

            // ── 이동 시도 (충돌 검사 포함)
            let nextX = player.x + player.vx * dt;
            let nextY = player.y + player.vy * dt;

            if (canMoveTo(nextX, player.y)) {
                player.x = nextX;
            } else {
                player.vx = 0; // 벽 충돌 → X방향 정지
            }

            if (canMoveTo(player.x, nextY)) {
                player.y = nextY;
            } else {
                player.vy = 0; // 벽 충돌 → Y방향 정지
            }

            // 시야/아이템/목표 체크 전에 시간 체크(혹은 후에)
            checkTimeout();

            // ── 시야 & 방문 경로 업데이트
            revealAround(player.x, player.y);

            // ── 아이템 획득 판정
            tryCollectItems();

            // ── 출구 도달 판정
            checkGoal();

            // ── 화면 갱신
            draw();
            drawMiniMap();

            requestAnimationFrame(update);
        }
        /* ---------------------------
           레벨 / 초기화
           --------------------------- */
        function startLevel(lv) {
            hasKey = false;
            level = lv || 1;
            // rows/cols growth: base 21 + (level-1)*2
            cols = 21 + (level - 1) * 2;
            rows = 21 + (level - 1) * 2;
            if (cols % 2 === 0) cols++;
            if (rows % 2 === 0) rows++;
            // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
            // startTime = Date.now();
            // 시간제한 초기화
            timeLimitSeconds = getTimeLimitForLevel(level);
            startTime = Date.now();
            timeUp = false;
            // levelCleared = false; 등 기존 초기화
            // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
            generateMaze(cols, rows);
            // reset player to start
            player.x = 1.5; player.y = 1.5; player.vx = 0; player.vy = 0;
            levelCleared = false;
            placeItemsForLevel(level);
            revealAround(player.x, player.y);
            updateHud();
        }

        function getRemainingSeconds() {
            if (!startTime) return timeLimitSeconds;
            const elapsed = (Date.now() - startTime) / 1000;
            return Math.max(0, timeLimitSeconds - elapsed);
        }
        // HUD 또는 캔버스에 시간 그리기: draw() 또는 별도 drawHUD() 안에서 호출
        function drawTimer(ctx) {
            const rem = getRemainingSeconds();
            const sec = Math.floor(rem);
            const mm = Math.floor(sec / 60);
            const ss = sec % 60;
            const text = `${mm}:${String(ss).padStart(2, '0')}`;

            // 예: 좌상단 HUD에 텍스트로 그리기 (canvas drawing)
            ctx.save();
            ctx.font = '18px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            // 남은시간 색상: 10초 이하면 빨강
            ctx.fillStyle = rem <= 10 ? 'tomato' : '#fff';
            ctx.fillText(`시간: ${text}`, 12, 14); // 위치는 조정하세요
            ctx.restore();
        }

        // 시간 만료 처리
        function handleTimeUp() {
            if (timeUp) return; // 중복 방지
            timeUp = true;

            // 플레이어에게 알려주기 (원하시면 overlay로 바꿀 수 있음)
            const elapsedTotal = ((Date.now() - startTime) / 1000).toFixed(1);
            // 기본 동작: 알림 후 동일 레벨 재시작 (원하면 레벨 종료/게임오버로 변경)
            // setTimeout(() => {
            //     alert(`시간 초과! 플레이타임: ${elapsedTotal}초\n레벨을 다시 시작합니다.`);
            //     // 재시작 동작: 같은 레벨 다시 시작
            //     startLevel(level);
            // }, 50);
            showGameOverOverlay({
                title: '시간 초과!',
                message: `플레이타임: ${elapsed}초\n레벨을 다시 시작하시겠습니까?`,
            });
        }

        // ---------- 게임오버 오버레이 생성 함수 ----------
        function showGameOverOverlay({ title = '게임 오버', message = '' } = {}) {
            // overlay 및 overlayPanel은 기존에 정의되어 있다고 가정
            overlayPanel.innerHTML = ''; // 기존 내용 초기화

            const panel = document.createElement('div');
            panel.className = 'panel';
            const h3 = document.createElement('h3');
            h3.textContent = title;
            panel.appendChild(h3);

            if (message) {
                const p = document.createElement('p');
                // 줄바꿈 보존
                p.innerText = message;
                panel.appendChild(p);
            }

            // 버튼 영역
            const actions = document.createElement('div');
            actions.className = 'actions';

            // 다시 시작 버튼: 같은 레벨 재시작
            const restartBtn = document.createElement('button');
            restartBtn.className = 'primary';
            restartBtn.textContent = '다시 시작';
            restartBtn.onclick = () => {
                overlay.style.display = 'none';
                // 재시작: 같은 레벨
                timeUp = false;
                // 재시작 전에 필요한 초기화(아이템 리셋 등)는 startLevel에서 처리
                startLevel(level);
                // 루프가 정지 상태라면 재개
                requestAnimationFrame(update);
            };
            actions.appendChild(restartBtn);

            // 종료 버튼: 프롤로그(인트로)로 이동
            const exitBtn = document.createElement('button');
            exitBtn.className = 'ghost';
            exitBtn.style.marginLeft = '8px';
            exitBtn.textContent = '종료';
            exitBtn.onclick = () => {
                overlay.style.display = 'none';
                timeUp = false;

                // 인트로 보여주기 (사용하던 showIntroStart 함수가 있다고 가정)
                // 도감/진행 정보는 원하면 초기화하거나 보존하도록 변경 가능
                if (typeof showIntroStart === 'function') {
                    showIntroStart();
                } else {
                    // fallback: 강제로 인트로 텍스트 표시
                    overlayPanel.innerHTML = `<div class="panel"><h3>프롤로그</h3><p>${(storyTexts.intro && storyTexts.intro[0]) || '프롤로그'}</p><div class="actions"><button id="startAgain" class="primary">게임 시작</button></div></div>`;
                    overlay.style.display = 'flex';
                    document.getElementById('startAgain').onclick = () => {
                        overlay.style.display = 'none';
                        // 새 게임을 위해 레벨 초기화
                        level = 1;
                        startLevel(1);
                        requestAnimationFrame(update);
                    };
                }
            };
            actions.appendChild(exitBtn);

            panel.appendChild(actions);

            overlayPanel.appendChild(panel);
            overlay.style.display = 'flex';
        }

        // update() 내부에 체크 추가 (기존 update() 최상단/중간에 넣기 좋음)
        function checkTimeout() {
            if (timeUp) return;
            const rem = getRemainingSeconds();
            if (rem <= 0) {
                handleTimeUp();
            }
        }
        /* ---------------------------
           인트로 흐름:
           - 처음 실행 시 overlay에 시작 버튼 표시
           - 버튼 클릭 -> 인트로 텍스트 보여주기 (자동으로 도감 해금)
           --------------------------- */
        const showIntroStart = () => {
            overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">프롤로그</h3>
    <p>깊은 미궁으로 들어갈 준비가 되었나? 시작 버튼을 눌러 탐험을 시작하세요.</p>
    <div class="actions"><button class="primary" id="startBtn">게임 시작</button></div>`;
            overlay.style.display = 'flex';
            document.getElementById('startBtn').onclick = () => {
                // show intro story text, unlock in storage, then close and start level
                overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">프롤로그</h3>
      <p>${storyTexts.intro[0]}</p>`;
                // unlock intro in storage and show
                collectedStories['intro'] = { unlocked: true, text: storyTexts.intro[0] };
                saveStories();
                setTimeout(() => { overlay.style.display = 'none'; startLevel(1); requestAnimationFrame(update); }, 2200);
            };
        };

        /* ---------------------------
           초기 로드: 스토리 불러오기 & 시작
           --------------------------- */
        loadStories();
        updateHud();
        // If intro not yet unlocked, show start overlay; else start immediately
        if (!collectedStories['intro']) {
            showIntroStart();
        } else {
            startLevel(level);
            requestAnimationFrame(update);
        }

        /* ---------------------------
           코덱스 버튼 연결
           --------------------------- */
        codexBtn.addEventListener('click', () => { openCodex(); });

        /* ---------------------------
           유틸: 초기 디버그 노출 (콘솔)
           --------------------------- */
        window._GAME = {
            getState: () => ({ level, rows, cols, maze, items, player, collectedStories }),
            resetStories: () => { collectedStories = {}; saveStories(); alert('stories reset'); }
        };

        /* ---------------------------
           주석(확장 포인트)
           - 바닥 타일 이미지 적용: 현재 floor은 단색으로 그려집니다.
             향후 floorImages 객체를 만들어 blockImages와 동일한 방식으로 draw()에서 floor 이미지를 draw하면 됩니다.
           - 블럭 디테일: 현재 1x1~3x3 그리드를 지원합니다. 필요 시 코너/ T자/ 십자 등 더 섬세한 매핑 로직을 추가하세요.
           - 적/트랩 추가: items와 유사하게 적 객체(위치, 패턴)를 추가하고 update()에서 충돌/이동 로직을 구현하면 됩니다.
           --------------------------- */


    </script>
</body>

</html>