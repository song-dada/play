<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>랜덤 미로 게임 (완성본)</title>
    <link rel="stylesheet" href="css/gpt.css">
</head>

<body>
    <div class="wrap">
        <div id="ads"></div>
        <div id="hubmap">
            <!-- HUD (좌상단): 레벨 / 아이템 / 도감 버튼 -->
            <div class="hud">
                <div class="hubup">
                    <div class="panel" id="levelPanel">레벨: <span id="levelText">1</span></div>
                    <div class="panel items" id="itemPanel">아이템: <span id="itemKey">❌</span> <span
                            id="itemCompass">❌</span>

                    </div>
                </div>
                <div class="panel"><button id="codexBtn">📖 도감</button></div>
            </div>

            <!-- 미니맵 (우상단) -->
            <div id="miniWrapper"><canvas id="miniMap" width="260" height="260"></canvas></div>

        </div>

        <!-- 중앙 미로 캔버스 (fixed size) -->
        <div id="gameWrapper">
            <canvas id="game" width="480" height="480"></canvas>

        </div>
        <!-- 조이스틱 (하단 중앙 고정) -->
        <div id="joystickWrap">
            <div id="joystick">
                <div id="stick"></div>
            </div>
        </div>
    </div>

    <!-- 오버레이: 인트로/스토리/코덱스 상세 등이 재사용 -->
    <div id="overlay" class="overlay">
        <div class="panel" id="overlayPanel">
            <!-- 콘텐츠 동적 삽입 -->
        </div>
    </div>

    <!-- 코덱스 전용 오버레이 (리스트) -->
    <div id="codexOverlay" class="overlay">
        <div class="panel" id="codexPanel"></div>
    </div>

    <script>
        /* =====================================================
           랜덤 미로 게임 - 통합 완성본
           - 요구사항 반영:
             인트로 -> 시작 버튼 -> 인트로 스토리(도감 자동 해금) -> 미로 시작
             아이템: 열쇠(key), 나침반(compass) (랜덤 배치)
             열쇠 소지 시 출구 통과 가능
             revealAround() 시야 구현 + miniMap: 지나간 길만 표시
             도감(localStorage): 해금 여부 + (compass) 메시지 저장
             블럭 이미지(1x1~3x3) 자동 스케일링
             HUD / 중앙미로 / 우상단 미니맵 / 하단 중앙 조이스틱
           ===================================================== */

        ///// 저장 키 & 초기 스토리 데이터
        const STORAGE_KEY = 'maze_collectedStories_v1';

        // 스토리 슬롯 및 텍스트 (compass는 레벨별 다중 메시지 풀)
        const storySlots = [
            { id: 'intro', label: '프롤로그' },
            { id: 'key', label: '열쇠' },
            // gem 제거 (회의 결과)
            { id: 'compass', label: '나침반' },
            { id: 'level1', label: '레벨1' },
            { id: 'level2', label: '레벨2' },
            { id: 'ending', label: '엔딩' }
        ];

        const storyTexts = {
            intro: ['깊은 미궁 속으로 발을 내딛었다. 어둠 속에서 무언가 속삭이는 듯하다...'],
            key: ['낡은 열쇠를 손에 넣었다. 녹슨 금속이 차갑게 닿는다.'],
            // compass: 레벨별 메시지 풀 (랜덤 선택)
            compass: [
                ['서쪽에서 기묘한 기운이 느껴진다...', '나침반이 갑자기 흔들리며 방향을 잃는다...'],
                ['멀리서 낮은 울음소리가 들려온다...', '벽에 새겨진 고대 문양이 눈에 들어왔다...'],
                ['‘출구는 없다’는 목소리가 메아리쳤다...', '차갑고 습한 공기가 더 짙어졌다...']
            ],
            level1: ['첫 번째 미궁을 통과했다!'],
            level2: ['더 깊은 곳으로 발걸음을 옮긴다...'],
            ending: ['드디어 미궁에서 탈출했다!']
        };

        let collectedStories = {}; // { id: {unlocked:true, text: '...'} } or { id: true }

        function loadStories() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) { collectedStories = {}; return; }
                collectedStories = JSON.parse(raw) || {};
            } catch (e) { console.warn('loadStories error', e); collectedStories = {}; }
        }
        function saveStories() {
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(collectedStories)); } catch (e) { console.warn('saveStories', e); }
        }

        /* ---------------------------
           캔버스 세팅
           --------------------------- */
        const gameCanvas = document.getElementById('game');
        const ctx = gameCanvas.getContext('2d');
        const miniCanvas = document.getElementById('miniMap');
        const miniCtx = miniCanvas.getContext('2d');

        let tileSize = 30; // 타일 픽셀 크기 (고정)
        const getCanvasSize = () => ({ w: gameCanvas.width, h: gameCanvas.height });

        /* ---------------------------
           블럭 이미지 (1x1 ~ 3x3)
           - 제공된 이미지를 tileSize에 맞춰 자동 스케일링해서 그립니다.
           - 경로는 필요시 교체하세요.
           --------------------------- */
        const blockImages = {
            "1x1": new Image(), "1x2": new Image(), "1x3": new Image(),
            "2x1": new Image(), "2x2": new Image(), "2x3": new Image(),
            "3x1": new Image(), "3x2": new Image(), "3x3": new Image()
        };
        // (이미지 경로: 필요시 바꾸세요)
        blockImages["1x1"].src = "img/block_1x1.png";
        blockImages["1x2"].src = "img/block_1x2.png";
        blockImages["1x3"].src = "img/block_1x3.png";
        blockImages["2x1"].src = "img/block_2x1.png";
        blockImages["2x2"].src = "img/block_2x2.png";
        blockImages["2x3"].src = "img/block_2x3.png";
        blockImages["3x1"].src = "img/block_3x1.png";
        blockImages["3x2"].src = "img/block_3x2.png";
        blockImages["3x3"].src = "img/block_3x3.png";

        /* ---------------------------
           게임 상태 변수
           --------------------------- */
        let rows = 21, cols = 21; // 기본
        let maze = []; // 2D array: 1=wall,0=path
        let revealMap = []; // 시야(보여진 타일) boolean
        let visitedMap = []; // 미니맵용: 지나간 길만 true
        let items = []; // [{x,y,type, collected, storyId, message?}]
        let level = 1;

        let player = { x: 1.5, y: 1.5, size: 0.65, vx: 0, vy: 0 }; // 좌표는 타일 단위 (1.5 = 중앙)
        let speed = 4.2; // tiles/sec (이 값은 조이스틱/키보드에 의해 곱해짐)
        let lastTime = performance.now();

        let goal = { x: cols - 2, y: rows - 2 };

        /* ---------------------------
           DOM references
           --------------------------- */
        const overlay = document.getElementById('overlay');
        const overlayPanel = document.getElementById('overlayPanel');
        const codexOverlay = document.getElementById('codexOverlay');
        const codexPanel = document.getElementById('codexPanel');
        const codexBtn = document.getElementById('codexBtn');
        const levelText = document.getElementById('levelText');
        const itemKeyEl = document.getElementById('itemKey');
        const itemCompassEl = document.getElementById('itemCompass');

        /* ---------------------------
           유틸 함수: inBounds, randInt, distance
           --------------------------- */
        function inBounds(x, y) { return x >= 0 && y >= 0 && x < cols && y < rows; }
        function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
        function dist(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }

        /* ===========================
           미로 생성 (DFS Carve)
           - 홀수 좌표 기반 carve 방식 (1칸 벽/길 스타일 유지)
           =========================== */
        function createEmptyMaze(w, h) {
            const m = [];
            for (let y = 0; y < h; y++) { m[y] = []; for (let x = 0; x < w; x++) m[y][x] = 1; }
            return m;
        }
        function generateMaze(w, h) {
            cols = w; rows = h;
            maze = createEmptyMaze(cols, rows);
            // carve from (1,1)
            const stack = [];
            maze[1][1] = 0;
            stack.push({ x: 1, y: 1 });
            const deltas = [[0, -2], [2, 0], [0, 2], [-2, 0]];
            while (stack.length) {
                const cur = stack[stack.length - 1];
                let neighbors = [];
                for (const d of deltas) {
                    const nx = cur.x + d[0], ny = cur.y + d[1];
                    if (inBounds(nx, ny) && maze[ny][nx] === 1) neighbors.push(d);
                }
                if (neighbors.length === 0) { stack.pop(); continue; }
                const ch = neighbors[Math.floor(Math.random() * neighbors.length)];
                const betweenX = cur.x + ch[0] / 2;
                const betweenY = cur.y + ch[1] / 2;
                const nx = cur.x + ch[0];
                const ny = cur.y + ch[1];
                maze[betweenY][betweenX] = 0;
                maze[ny][nx] = 0;
                stack.push({ x: nx, y: ny });
            }
            // goal ensure open
            let possibleGoals = [];

            // 상단 테두리: y=0
            for (let x = 1; x < cols - 1; x++) {
                if (maze[1][x] === 0) possibleGoals.push({ x, y: 0 }); // 상단 벽, 바로 아래가 길
            }

            // 하단 테두리: y=rows-1
            for (let x = 1; x < cols - 1; x++) {
                if (maze[rows - 2][x] === 0) possibleGoals.push({ x, y: rows - 1 }); // 하단 벽, 바로 위가 길
            }

            // 좌측 테두리: x=0
            for (let y = 1; y < rows - 1; y++) {
                if (maze[y][1] === 0) possibleGoals.push({ x: 0, y }); // 좌측 벽, 바로 오른쪽이 길
            }

            // 우측 테두리: x=cols-1
            for (let y = 1; y < rows - 1; y++) {
                if (maze[y][cols - 2] === 0) possibleGoals.push({ x: cols - 1, y }); // 우측 벽, 바로 왼쪽이 길
            }

            // fallback: 맨 오른쪽 아래 안쪽 칸
            if (possibleGoals.length === 0) possibleGoals.push({ x: cols - 2, y: rows - 2 });

            // 랜덤 선택
            goal = possibleGoals[Math.floor(Math.random() * possibleGoals.length)];

            // goal 칸은 벽으로 유지 (출구 표시용)
            maze[goal.y][goal.x] = 2;


            // // 테두리 후보 수집 (0 ~ length-1 포함)
            // let possibleGoals = [];

            // // 상단, 하단 테두리
            // for (let x = 0; x < cols; x++) {
            //     if (maze[0][x] === 0) possibleGoals.push({ x, y: 0 });
            //     if (maze[rows - 1][x] === 0) possibleGoals.push({ x, y: rows - 1 });
            // }

            // // 좌측, 우측 테두리
            // for (let y = 1; y < rows - 1; y++) { // 상단/하단은 이미 포함했으므로 1~rows-2
            //     if (maze[y][0] === 0) possibleGoals.push({ x: 0, y });
            //     if (maze[y][cols - 1] === 0) possibleGoals.push({ x: cols - 1, y });
            // }

            // // fallback
            // if (possibleGoals.length === 0) possibleGoals.push({ x: cols - 1, y: rows - 1 });

            // // goal 랜덤 선택
            // goal = possibleGoals[Math.floor(Math.random() * possibleGoals.length)];

            // // goal 위치는 반드시 길로
            // maze[goal.y][goal.x] = 0;

            // // ==============================
            // // goal: 미로 테두리 중 랜덤 위치로 지정
            // // - 테두리(상단, 하단, 좌측, 우측) 중 길(0)인 칸을 수집
            // // - 랜덤 선택
            // // - 만약 테두리에 길이 없으면 fallback으로 오른쪽 아래 지정
            // // ==============================
            // let possibleGoals = [];

            // // 상단, 하단 테두리
            // for (let x = 1; x < cols - 1; x++) {
            //     if (maze[0][x] === 0) possibleGoals.push({ x, y: 0 });
            //     if (maze[rows - 1][x] === 0) possibleGoals.push({ x, y: rows - 1 });
            // }

            // // 좌측, 우측 테두리
            // for (let y = 1; y < rows - 1; y++) {
            //     if (maze[y][0] === 0) possibleGoals.push({ x: 0, y });
            //     if (maze[y][cols - 1] === 0) possibleGoals.push({ x: cols - 1, y });
            // }

            // // 테두리에 길이 없을 경우 fallback
            // if (possibleGoals.length === 0) possibleGoals.push({ x: cols - 2, y: rows - 2 });

            // // goal 선택
            // goal = possibleGoals[Math.floor(Math.random() * possibleGoals.length)];

            // // goal 위치는 반드시 길로 만들기
            // maze[goal.y][goal.x] = 0;

            // goal.x = cols - 2; goal.y = rows - 2;
            // maze[goal.y][goal.x] = 0;

            // reveal/visited 초기화
            revealMap = Array.from({ length: rows }, () => Array(cols).fill(false));
            visitedMap = Array.from({ length: rows }, () => Array(cols).fill(false));
        }

        /* ===========================
           아이템 배치
           - key(열쇠) 1개, compass(나침반) 레벨당 1개
           - 랜덤 배치(길 위), 시작/종료 근처는 피함
           =========================== */
        function findRandomPathCell(avoidNearStart = true) {
            for (let tries = 0; tries < 5000; tries++) {
                const x = randInt(1, cols - 2);
                const y = randInt(1, rows - 2);
                if (maze[y][x] !== 0) continue;
                // avoid start/goal proximity
                if (avoidNearStart) {
                    if (Math.abs(x - 1) + Math.abs(y - 1) < 4) continue;
                    if (Math.abs(x - goal.x) + Math.abs(y - goal.y) < 4) continue;
                }
                return { x, y };
            }
            // fallback: first path cell
            for (let y = 1; y < rows - 1; y++) for (let x = 1; x < cols - 1; x++) if (maze[y][x] === 0) return { x, y };
            return { x: 1, y: 1 };
        }

        function placeItemsForLevel(lv) {
            items = [];
            // key
            const k = findRandomPathCell(true);
            items.push({ type: 'key', x: k.x, y: k.y, collected: false, storyId: 'key' });
            // compass (one per level)
            const c = findRandomPathCell(true);
            // select random message from pool (if exists for level)
            let pool = (storyTexts.compass && storyTexts.compass[lv - 1]) || (storyTexts.compass && storyTexts.compass[0]) || ['나침반이 조용하다.'];
            const chosen = pool[Math.floor(Math.random() * pool.length)];
            const storyId = `compass_${lv}`;
            items.push({ type: 'compass', x: c.x, y: c.y, collected: false, storyId: storyId, message: chosen });
        }

        /* ===========================
           충돌 검사 (player.size 반영)
           - player coords are in tiles. size is fraction of tile (e.g. 0.65)
           - check four corners in tile coords (floor)
           =========================== */
        function canMoveTo(newX, newY) {
            const half = player.size / 2;
            const corners = [
                { x: newX - half, y: newY - half },
                { x: newX + half, y: newY - half },
                { x: newX - half, y: newY + half },
                { x: newX + half, y: newY + half }
            ];
            for (const c of corners) {
                const tx = Math.floor(c.x);
                const ty = Math.floor(c.y);
                // if (!inBounds(tx, ty) ) return false;
                if (!inBounds(tx, ty) || maze[ty][tx] === 1) return false;
                return (maze[ty][tx] === 0 || maze[ty][tx] === 2);
                // if (maze[ty][tx] === 1) return false;
            }
            return true;
        }

        /* ===========================
           시야 & 미니맵
           - revealAround(px,py): 주변 revealRadius 타일을 true로 설정
           - visitedMap: 플레이어가 지나간 path만 true (미니맵용)
           =========================== */
        let revealRadius = 3;
        function revealAround(px, py) {
            const cx = Math.floor(px), cy = Math.floor(py);
            for (let dy = -revealRadius; dy <= revealRadius; dy++) {
                for (let dx = -revealRadius; dx <= revealRadius; dx++) {
                    const x = cx + dx, y = cy + dy;
                    if (inBounds(x, y)) {
                        revealMap[y][x] = true;
                    }
                }
            }
            // mark current tile as visited (miniMap)
            if (inBounds(cx, cy) && maze[cy][cx] === 0) visitedMap[cy][cx] = true;
        }

        /* ===========================
           스토리(도감) 해금 및 오버레이 표시
           - unlockStory(id, text?)
           - stored format: collectedStories[id] = {unlocked:true, text: '...'} OR true
           - 인트로는 처음 시작 버튼 클릭 후 호출하여 1회 해금
           =========================== */
        function unlockStory(id, text) {
            // If already unlocked, still may show overlay if text provided? We'll avoid re-showing on duplicate unlock.
            if (!collectedStories[id]) {
                collectedStories[id] = { unlocked: true, text: text || (storyTexts[id] ? (Array.isArray(storyTexts[id]) ? storyTexts[id][0] : storyTexts[id]) : '') };
                saveStories();
            }
            // Show overlay with text (pull stored text if present)
            const data = collectedStories[id];
            const showText = (data && data.text) || text || (storyTexts[id] ? (Array.isArray(storyTexts[id]) ? storyTexts[id][0] : storyTexts[id]) : '(기록 없음)');
            showStoryOverlay(`${id}`, showText, 3000); // 자동으로 3초 후 닫힘
        }

        /* Show overlay with text and optional image; autoCloseMs = milliseconds or 0 for no auto-close */
        function showStoryOverlay(title, text, autoCloseMs = 3000) {
            overlayPanel.innerHTML = '';
            // simple layout: title, text (and placeholder for image if needed)
            const h = document.createElement('div');
            h.innerHTML = `<h3 style="margin:0 0 6px">${title}</h3>`;
            overlayPanel.appendChild(h);
            if (text && text.length > 0) {
                const p = document.createElement('p');
                p.textContent = text;
                overlayPanel.appendChild(p);
            }
            // close button area
            const actions = document.createElement('div');
            actions.className = 'actions';
            const closeBtn = document.createElement('button');
            closeBtn.className = 'ghost';
            closeBtn.textContent = '닫기';
            closeBtn.onclick = () => { overlay.style.display = 'none'; };
            actions.appendChild(closeBtn);
            overlayPanel.appendChild(actions);

            overlay.style.display = 'flex';
            if (autoCloseMs && autoCloseMs > 0) {
                setTimeout(() => { if (overlay.style.display === 'flex') overlay.style.display = 'none'; }, autoCloseMs);
            }
        }

        /* ---------------------------
           코덱스(도감) UI
           - 리스트 표시, 클릭하면 상세 도감 텍스트를 overlay로 표시
           --------------------------- */
        function openCodex() {
            codexPanel.innerHTML = '<h3 style="margin-top:0">스토리 도감</h3>';
            storySlots.forEach(s => {
                const owned = !!collectedStories[s.id];
                const mark = owned ? '✅' : '❌';
                // choose display text: if unlocked with text then show preview, else ??? 
                let preview = '???';
                if (owned) {
                    const d = collectedStories[s.id];
                    if (d && d.text) preview = d.text.length > 80 ? d.text.slice(0, 77) + '...' : d.text;
                    else preview = (storyTexts[s.id] && storyTexts[s.id][0]) || '해금됨';
                }
                const row = document.createElement('div');
                row.style.padding = '8px 0';
                row.style.borderBottom = '1px dashed #222';
                row.innerHTML = `<strong style="display:block">${mark} ${s.label}</strong><small>${preview}</small>`;
                row.style.cursor = 'pointer';
                row.onclick = () => {
                    // show detail overlay for this slot
                    const fullText = (collectedStories[s.id] && collectedStories[s.id].text) || (storyTexts[s.id] && storyTexts[s.id][0]) || '(잠금)';
                    showStoryOverlay(s.label, fullText, 0); // 0 -> don't auto close, let user close
                    codexOverlay.style.display = 'none';
                };
                codexPanel.appendChild(row);
            });
            const close = document.createElement('div');
            close.style.marginTop = '8px';
            close.innerHTML = `<div style="text-align:right"><button class="primary" id="codexClose">닫기</button></div>`;
            codexPanel.appendChild(close);
            codexOverlay.style.display = 'flex';
            document.getElementById('codexClose').onclick = () => { codexOverlay.style.display = 'none'; };
        }

        /* ---------------------------
           HUD 업데이트
           --------------------------- */
        function updateHud() {
            levelText.textContent = level;
            itemKeyEl.textContent = collectedStories['key'] ? '🔑' : '❌';
            // compass could be per-level: show if any compass_n unlocked for current or previous levels
            const compId = `compass_${level}`;
            const hasCompass = !!(collectedStories[compId] || collectedStories['compass']);
            itemCompassEl.textContent = hasCompass ? '🧭' : '❌';
        }

        /* ---------------------------
           아이템 수집 처리
           - items 배열을 순회하여 플레이어가 가까이 가면 수집
           - 수집 시 도감 unlock 및 overlay 표시 (compass는 메시지 기록)
           --------------------------- */
        function tryCollectItems() {
            for (let i = items.length - 1; i >= 0; i--) {
                const it = items[i];
                if (!it) continue;
                const d = dist(player.x, player.y, it.x + 0.5, it.y + 0.5);
                if (d < 0.8) {
                    // collect
                    it.collected = true;
                    items.splice(i, 1);
                    if (it.type === 'compass') {
                        // store compass message under storyId (compass_level)
                        collectedStories[it.storyId] = { unlocked: true, text: it.message };
                        saveStories();
                        showStoryOverlay('나침반', it.message, 3000);
                    } else if (it.type === 'key') {
                        hasKey = true; // 현재 레벨에서 열쇠 소유
                        // key: fixed story text
                        unlockStory('key', storyTexts.key[0]);
                    } else {
                        unlockStory(it.storyId, it.message || '아이템 획득');
                    }
                    updateHud();
                    // small toast
                    showToast(`획득: ${it.type}`);
                }
            }
        }

        /* ---------------------------
           토스트
           --------------------------- */
        function showToast(text, ms = 1600) {
            const t = document.createElement('div'); t.className = 'toast'; t.textContent = text;
            document.body.appendChild(t);
            setTimeout(() => { t.remove(); }, ms);
        }

        /* ---------------------------
           목표(출구) 도달 처리
           - 열쇠가 있어야 통과 가능 (key 해금)
           --------------------------- */
        let hasKey = false;

        let levelCleared = false;
        function checkGoal() {
            // 플레이어와 목표 지점(셀 중앙) 거리 계산
            const d = dist(player.x, player.y, goal.x + 0.5, goal.y + 0.5);

            // 충분히 가까우면 도달로 판정
            if (d < 0.8 && !levelCleared) {
                if (hasKey) {
                    // if (collectedStories['key']) {
                    // 🔑 열쇠를 가진 경우 → 레벨 클리어 처리
                    levelCleared = true;

                    // 도감에 레벨 클리어 스토리 해금
                    unlockStory(
                        `level${level}`,
                        (storyTexts[`level${level}`] && storyTexts[`level${level}`][0]) || `레벨 ${level} 클리어`
                    );

                    // 오버레이로 알림
                    showStoryOverlay('레벨 클리어', `레벨 ${level} 클리어! 다음 레벨로 이동합니다.`, 2500);

                    // 다음 레벨 시작
                    setTimeout(() => {
                        level++;
                        startLevel(level);
                    }, 2300);

                } else {
                    // 🔑 없으면 출구 통과 불가
                    showToast('아이템이 부족합니다! 🔑를 모아야 합니다.', 1800);
                }
            }
        }


        // function checkGoal() {
        //     const d = dist(player.x, player.y, goal.x + 0.5, goal.y + 0.5);
        //     if (d < 0.8 && !levelCleared) {
        //         if (collectedStories['key']) {
        //             levelCleared = true;
        //             // unlock level story
        //             unlockStory(`level${level}`, (storyTexts[`level${level}`] && storyTexts[`level${level}`][0]) || `레벨 ${level} 클리어`);
        //             showStoryOverlay('레벨 클리어', `레벨 ${level} 클리어! 다음 레벨로 이동합니다.`, 2500);
        //             setTimeout(() => { level++; startLevel(level); }, 2300);
        //         } else {
        //             // can't pass
        //             showToast('아이템이 부족합니다! 🔑를 모아야 합니다.', 1800);
        //         }
        //     }
        // }

        /* ===========================
           그리기 로직
           - 메인 캔버스: 타일(벽/바닥), 블럭 이미지 적용, 아이템, 플레이어, 출구
           - 미니맵: visitedMap에 따라 지나간 길만 표시
           =========================== */

        function getBlockRunSize(x, y) {
            // Count how many consecutive wall tiles to the right (w) and down (h), max 3
            if (maze[y][x] !== 1) return { w: 0, h: 0 };
            let w = 1, h = 1;
            for (let sx = 1; sx < 3; sx++) {
                if (inBounds(x + sx, y) && maze[y][x + sx] === 1) w++; else break;
            }
            for (let sy = 1; sy < 3; sy++) {
                if (inBounds(x, y + sy) && maze[y + sy][x] === 1) h++; else break;
            }
            w = Math.min(3, w); h = Math.min(3, h);
            return { w, h };
        }

        // function draw() {
        //     // clear
        //     ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

        //     // draw tiles. We will draw block images only for top-left of a run to avoid overlap.
        //     for (let y = 0; y < rows; y++) {
        //         for (let x = 0; x < cols; x++) {
        //             const px = x * tileSize, py = y * tileSize;
        //             // if tile not yet revealed, draw dark overlay (fog)
        //             const revealed = revealMap[y] && revealMap[y][x];
        //             if (!revealed) {
        //                 // cover with dark rectangle
        //                 ctx.fillStyle = '#050506';
        //                 ctx.fillRect(px, py, tileSize, tileSize);
        //                 continue;
        //             }
        //             if (maze[y][x] === 1) {
        //                 // draw wall using block images where appropriate
        //                 // Only draw when this tile is top-left of a block run (no wall at left and above)
        //                 const leftIsWall = (x > 0 && maze[y][x - 1] === 1);
        //                 const aboveIsWall = (y > 0 && maze[y - 1][x] === 1);
        //                 if (!leftIsWall && !aboveIsWall) {
        //                     const { w, h } = getBlockRunSize(x, y);
        //                     const key = `${w}x${h}`;
        //                     const img = blockImages[key];
        //                     if (img && img.complete && img.naturalWidth > 0) {
        //                         // draw scaled to (w*tileSize, h*tileSize)
        //                         ctx.drawImage(img, px, py, w * tileSize, h * tileSize);
        //                     } else {
        //                         // fallback fill
        //                         ctx.fillStyle = '#222';
        //                         ctx.fillRect(px, py, w * tileSize, h * tileSize);
        //                     }
        //                 } else {
        //                     // If not top-left, just leave it (it will be covered by the top-left draw), but ensure single tile fallback if images not ready:
        //                     // draw small fallback for individual uncovered wall tiles
        //                     ctx.fillStyle = '#222';
        //                     ctx.fillRect(px, py, tileSize, tileSize);
        //                 }
        //             } else {
        //                 // floor
        //                 ctx.fillStyle = '#cfcfcf';
        //                 ctx.fillRect(px, py, tileSize, tileSize);
        //             }
        //         }
        //     }

        //     // draw goal if revealed
        //     if (revealMap[goal.y] && revealMap[goal.y][goal.x]) {
        //         ctx.fillStyle = '#2ecc71';
        //         ctx.fillRect(goal.x * tileSize + tileSize * 0.15, goal.y * tileSize + tileSize * 0.15, tileSize * 0.7, tileSize * 0.7);
        //     }

        //     // draw items (only if their tile revealed)
        //     for (const it of items) {
        //         if (it.collected) continue;
        //         if (!revealMap[it.y] || !revealMap[it.y][it.x]) continue;
        //         const cx = it.x * tileSize + tileSize / 2, cy = it.y * tileSize + tileSize / 2;
        //         ctx.beginPath();
        //         ctx.arc(cx, cy, tileSize * 0.28, 0, Math.PI * 2);
        //         if (it.type === 'key') ctx.fillStyle = '#ffcc00';
        //         else if (it.type === 'compass') ctx.fillStyle = '#7f5cff';
        //         else ctx.fillStyle = '#fff';
        //         ctx.fill();
        //     }

        //     // draw player (as square)
        //     const px = player.x * tileSize, py = player.y * tileSize;
        //     const psize = player.size * tileSize;
        //     ctx.fillStyle = '#ff4b4b';
        //     ctx.fillRect(px - psize / 2, py - psize / 2, psize, psize);

        //     // debug: draw player center
        //     // ctx.fillStyle='#0f0'; ctx.fillRect(px-2,py-2,4,4);
        // }

        function getBlockType(x, y) {
            let h = 1, w = 1;

            // 오른쪽이 벽이면 가로 확장
            if (maze[y][x + 1] === 1) w++;
            // 아래가 벽이면 세로 확장
            if (maze[y + 1] && maze[y + 1][x] === 1) h++;

            return `${w}x${h}`; // "1x1", "2x1", "1x2", "2x2" 등
        }


        function draw() {
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            // 카메라 오프셋: 플레이어를 중앙에 고정
            const offsetX = gameCanvas.width / 2 - player.x * tileSize;
            const offsetY = gameCanvas.height / 2 - player.y * tileSize;

            // 방문 체크용 배열
            const visited = Array.from({ length: rows }, () => Array(cols).fill(false));

            // 벽 & 길
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] === 1 && !visited[y][x]) {
                        let placed = false;

                        // --- 가로 그룹핑 (최대 3칸) ---
                        let lenX = 1;
                        while (
                            x + lenX < cols &&
                            lenX < 3 &&
                            maze[y][x + lenX] === 1 &&
                            !visited[y][x + lenX]
                        ) {
                            lenX++;
                        }
                        if (lenX > 1) {
                            let type = `1x${lenX}`; // "1x2", "1x3"
                            let img = blockImages[type] || blockImages["1x1"];
                            ctx.drawImage(
                                img,
                                x * tileSize + offsetX,
                                y * tileSize + offsetY,
                                tileSize * lenX,
                                tileSize
                            );
                            for (let i = 0; i < lenX; i++) visited[y][x + i] = true;
                            placed = true;
                        }

                        // --- 세로 그룹핑 (최대 3칸) ---
                        if (!placed) {
                            let lenY = 1;
                            while (
                                y + lenY < rows &&
                                lenY < 3 &&
                                maze[y + lenY][x] === 1 &&
                                !visited[y + lenY][x]
                            ) {
                                lenY++;
                            }
                            if (lenY > 1) {
                                let type = `${lenY}x1`; // "2x1", "3x1"
                                let img = blockImages[type] || blockImages["1x1"];
                                ctx.drawImage(
                                    img,
                                    x * tileSize + offsetX,
                                    y * tileSize + offsetY,
                                    tileSize,
                                    tileSize * lenY
                                );
                                for (let i = 0; i < lenY; i++) visited[y + i][x] = true;
                                placed = true;
                            }
                        }

                        // --- 단일 블럭 ---
                        if (!placed) {
                            let img = blockImages["1x1"];
                            ctx.drawImage(
                                img,
                                x * tileSize + offsetX,
                                y * tileSize + offsetY,
                                tileSize,
                                tileSize
                            );
                            visited[y][x] = true;
                        }
                    } else if (maze[y][x] === 0) {
                        // 길
                        ctx.fillStyle = "white";
                        ctx.fillRect(
                            x * tileSize + offsetX,
                            y * tileSize + offsetY,
                            tileSize,
                            tileSize
                        );
                    }
                }
            }

            // 목표
            ctx.fillStyle = "green";
            ctx.fillRect(
                goal.x * tileSize + offsetX,
                goal.y * tileSize + offsetY,
                tileSize,
                tileSize
            );

            // 아이템
            items.forEach(it => {
                ctx.fillStyle = it.type === "compass" ? "purple" : "gold";
                ctx.beginPath();
                ctx.arc(
                    it.x * tileSize + tileSize / 2 + offsetX,
                    it.y * tileSize + tileSize / 2 + offsetY,
                    tileSize / 3,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });

            // 플레이어 (항상 중앙 고정)
            const psize = tileSize * player.size;
            ctx.fillStyle = "red";
            ctx.fillRect(
                gameCanvas.width / 2 - psize / 2,
                gameCanvas.height / 2 - psize / 2,
                psize,
                psize
            );
        }



        /* ---------------------------
           미니맵 렌더링
           - visitedMap true인 path 타일만 표시
           - player marker + goal marker
           --------------------------- */
        function drawMiniMap() {
            const w = miniCanvas.width, h = miniCanvas.height;
            miniCtx.clearRect(0, 0, w, h);
            const cellW = w / cols, cellH = h / rows;
            // background
            miniCtx.fillStyle = '#030303';
            miniCtx.fillRect(0, 0, w, h);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (visitedMap[y][x] && maze[y][x] === 0) {
                        miniCtx.fillStyle = '#bfbfbf';
                        miniCtx.fillRect(x * cellW, y * cellH, cellW, cellH);
                    }
                }
            }
            // goal marker (if visited/revealed maybe show regardless)
            miniCtx.fillStyle = '#2ecc71';
            miniCtx.fillRect(goal.x * cellW + cellW * 0.15, goal.y * cellW + cellW * 0.15, cellW * 0.7, cellH * 0.7);

            // items (if visited tile) small circles
            for (const it of items) {
                if (visitedMap[it.y] && visitedMap[it.y][it.x]) {
                    miniCtx.beginPath();
                    miniCtx.fillStyle = (it.type === 'key') ? '#ffcc00' : '#7f5cff';
                    miniCtx.arc((it.x + 0.5) * cellW, (it.y + 0.5) * cellH, Math.min(cellW, cellH) * 0.25, 0, Math.PI * 2);
                    miniCtx.fill();
                }
            }
            // player marker
            miniCtx.fillStyle = '#ff4b4b';
            miniCtx.beginPath();
            miniCtx.arc((player.x) * cellW, (player.y) * cellH, Math.min(cellW, cellH) * 0.32, 0, Math.PI * 2);
            miniCtx.fill();
        }

        /* ---------------------------
           입력 처리: 키보드 (WASD / arrows)
           --------------------------- */
        const keys = {};
        window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

        /* ---------------------------
           조이스틱 (하단 중앙 고정)
           - touch / mouse 지원
           --------------------------- */
        const joystick = document.getElementById('joystick');
        const stick = document.getElementById('stick');
        let joyActive = false;
        let joyCenter = null;
        function initJoyCenter() { const r = joystick.getBoundingClientRect(); joyCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2 }; }
        initJoyCenter();
        window.addEventListener('resize', initJoyCenter);

        function setStickPos(dx, dy) {
            // dx,dy in range [-1,1]
            const max = (joystick.clientWidth / 2 - stick.clientWidth / 2 - 6);
            const tx = Math.max(-1, Math.min(1, dx)) * max;
            const ty = Math.max(-1, Math.min(1, dy)) * max;
            stick.style.transform = `translate(${tx}px, ${ty}px)`;
        }

        function startJoy(x, y) {
            joyActive = true;
            initJoyCenter();
            updateJoy(x, y);
        }
        function updateJoy(x, y) {
            if (!joyActive || !joyCenter) return;
            let dx = x - joyCenter.x;
            let dy = y - joyCenter.y;
            const distv = Math.hypot(dx, dy);
            const max = joystick.clientWidth / 2;
            if (distv > max) { dx = dx / distv * max; dy = dy / distv * max; }
            const nx = dx / max, ny = dy / max;
            // store velocity in tiles/sec
            player.vx = nx * speed;
            player.vy = ny * speed;
            setStickPos(nx, ny);
        }
        function endJoy() {
            joyActive = false;
            player.vx = 0; player.vy = 0;
            setStickPos(0, 0);
        }

        joystick.addEventListener('touchstart', e => { e.preventDefault(); startJoy(e.touches[0].clientX, e.touches[0].clientY); });
        joystick.addEventListener('touchmove', e => { e.preventDefault(); updateJoy(e.touches[0].clientX, e.touches[0].clientY); });
        joystick.addEventListener('touchend', e => { e.preventDefault(); endJoy(); });

        joystick.addEventListener('mousedown', e => { e.preventDefault(); startJoy(e.clientX, e.clientY); });
        window.addEventListener('mousemove', e => { if (joyActive) updateJoy(e.clientX, e.clientY); });
        window.addEventListener('mouseup', e => { if (joyActive) endJoy(); });

        /* ---------------------------
           메인 업데이트 루프
           - 입력 처리(키보드+조이스틱) -> 물리(충돌검사) -> 시야/수집/목표 체크 -> 그리기
           --------------------------- */
        // function update(now) {
        //     const dt = Math.min(0.05, (now - lastTime) / 1000);
        //     lastTime = now;

        //     // keyboard input (if no joystick active, keyboard will set velocity)
        //     if (!joyActive) {
        //         let ix = 0, iy = 0;
        //         if (keys['arrowup'] || keys['w']) iy -= 1;
        //         if (keys['arrowdown'] || keys['s']) iy += 1;
        //         if (keys['arrowleft'] || keys['a']) ix -= 1;
        //         if (keys['arrowright'] || keys['d']) ix += 1;
        //         if (ix !== 0 || iy !== 0) {
        //             const len = Math.hypot(ix, iy) || 1;
        //             player.vx = (ix / len) * speed;
        //             player.vy = (iy / len) * speed;
        //         } else {
        //             // no keys: if joystick not active, stop
        //             player.vx = 0; player.vy = 0;
        //         }
        //     }

        //     // attempt movement with sliding
        //     let nextX = player.x + player.vx * dt;
        //     let nextY = player.y + player.vy * dt;
        //     if (canMoveTo(nextX, player.y)) player.x = nextX; else player.vx = 0;
        //     if (canMoveTo(player.x, nextY)) player.y = nextY; else player.vy = 0;

        //     // reveal and mark visited
        //     revealAround(player.x, player.y);

        //     // collect items
        //     tryCollectItems();

        //     // goal check
        //     checkGoal();

        //     // draw
        //     draw();
        //     drawMiniMap();
        //     requestAnimationFrame(update);
        // }
        // 플레이어 크기를 고려한 충돌 검사
        function canMoveTo(x, y) {
            const half = player.size / 2; // 플레이어 절반 크기

            // 플레이어 네 꼭짓점 좌표
            const corners = [
                { cx: x - half, cy: y - half },
                { cx: x + half, cy: y - half },
                { cx: x - half, cy: y + half },
                { cx: x + half, cy: y + half }
            ];

            for (const p of corners) {
                const gx = Math.floor(p.cx);
                const gy = Math.floor(p.cy);
                // 범위 밖이거나 벽이면 이동 불가
                if (!inBounds(gx, gy) || maze[gy][gx] === 1) {
                    return false;
                }
            }
            return true;
        }

        // =========================
        // update 함수 (플레이어 이동, 충돌, 아이템, 출구 처리)
        // =========================
        function update(now) {
            const dt = Math.min(0.05, (now - lastTime) / 1000);
            lastTime = now;

            // ── 키보드 입력 처리 (조이스틱이 비활성일 때만)
            if (!joyActive) {
                let ix = 0, iy = 0;
                if (keys['arrowup'] || keys['w']) iy -= 1;
                if (keys['arrowdown'] || keys['s']) iy += 1;
                if (keys['arrowleft'] || keys['a']) ix -= 1;
                if (keys['arrowright'] || keys['d']) ix += 1;
                if (ix !== 0 || iy !== 0) {
                    const len = Math.hypot(ix, iy) || 1;
                    player.vx = (ix / len) * speed;
                    player.vy = (iy / len) * speed;
                } else {
                    player.vx = 0;
                    player.vy = 0;
                }
            }

            // ── 이동 시도 (충돌 검사 포함)
            let nextX = player.x + player.vx * dt;
            let nextY = player.y + player.vy * dt;

            if (canMoveTo(nextX, player.y)) {
                player.x = nextX;
            } else {
                player.vx = 0; // 벽 충돌 → X방향 정지
            }

            if (canMoveTo(player.x, nextY)) {
                player.y = nextY;
            } else {
                player.vy = 0; // 벽 충돌 → Y방향 정지
            }

            // ── 시야 & 방문 경로 업데이트
            revealAround(player.x, player.y);

            // ── 아이템 획득 판정
            tryCollectItems();

            // ── 출구 도달 판정
            checkGoal();

            // ── 화면 갱신
            draw();
            drawMiniMap();

            requestAnimationFrame(update);
        }
        /* ---------------------------
           레벨 / 초기화
           --------------------------- */
        function startLevel(lv) {
            hasKey = false;
            level = lv || 1;
            // rows/cols growth: base 21 + (level-1)*2
            cols = 21 + (level - 1) * 2;
            rows = 21 + (level - 1) * 2;
            if (cols % 2 === 0) cols++;
            if (rows % 2 === 0) rows++;
            generateMaze(cols, rows);
            // reset player to start
            player.x = 1.5; player.y = 1.5; player.vx = 0; player.vy = 0;
            levelCleared = false;
            placeItemsForLevel(level);
            revealAround(player.x, player.y);
            updateHud();
        }

        /* ---------------------------
           인트로 흐름:
           - 처음 실행 시 overlay에 시작 버튼 표시
           - 버튼 클릭 -> 인트로 텍스트 보여주기 (자동으로 도감 해금)
           --------------------------- */
        const showIntroStart = () => {
            overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">프롤로그</h3>
    <p>깊은 미궁으로 들어갈 준비가 되었나? 시작 버튼을 눌러 탐험을 시작하세요.</p>
    <div class="actions"><button class="primary" id="startBtn">게임 시작</button></div>`;
            overlay.style.display = 'flex';
            document.getElementById('startBtn').onclick = () => {
                // show intro story text, unlock in storage, then close and start level
                overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">프롤로그</h3>
      <p>${storyTexts.intro[0]}</p>`;
                // unlock intro in storage and show
                collectedStories['intro'] = { unlocked: true, text: storyTexts.intro[0] };
                saveStories();
                setTimeout(() => { overlay.style.display = 'none'; startLevel(1); requestAnimationFrame(update); }, 2200);
            };
        };

        /* ---------------------------
           초기 로드: 스토리 불러오기 & 시작
           --------------------------- */
        loadStories();
        updateHud();
        // If intro not yet unlocked, show start overlay; else start immediately
        if (!collectedStories['intro']) {
            showIntroStart();
        } else {
            startLevel(level);
            requestAnimationFrame(update);
        }

        /* ---------------------------
           코덱스 버튼 연결
           --------------------------- */
        codexBtn.addEventListener('click', () => { openCodex(); });

        /* ---------------------------
           유틸: 초기 디버그 노출 (콘솔)
           --------------------------- */
        window._GAME = {
            getState: () => ({ level, rows, cols, maze, items, player, collectedStories }),
            resetStories: () => { collectedStories = {}; saveStories(); alert('stories reset'); }
        };

        /* ---------------------------
           주석(확장 포인트)
           - 바닥 타일 이미지 적용: 현재 floor은 단색으로 그려집니다.
             향후 floorImages 객체를 만들어 blockImages와 동일한 방식으로 draw()에서 floor 이미지를 draw하면 됩니다.
           - 블럭 디테일: 현재 1x1~3x3 그리드를 지원합니다. 필요 시 코너/ T자/ 십자 등 더 섬세한 매핑 로직을 추가하세요.
           - 적/트랩 추가: items와 유사하게 적 객체(위치, 패턴)를 추가하고 update()에서 충돌/이동 로직을 구현하면 됩니다.
           --------------------------- */

    </script>
</body>

</html>