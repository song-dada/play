<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ëœë¤ ë¯¸ë¡œ ê²Œì„ (ì™„ì„±ë³¸)</title>
    <link rel="stylesheet" href="css/gpt.css">
</head>

<body>
    <div class="wrap">
        <div id="ads"></div>
        <div id="hubmap">
            <!-- HUD (ì¢Œìƒë‹¨): ë ˆë²¨ / ì•„ì´í…œ / ë„ê° ë²„íŠ¼ -->
            <div class="hud">
                <div class="hubup">
                    <div class="panel" id="levelPanel">ë ˆë²¨: <span id="levelText">1</span></div>
                    <div class="panel items" id="itemPanel">ì•„ì´í…œ: <span id="itemKey">âŒ</span> <span
                            id="itemCompass">âŒ</span>

                    </div>
                </div>
                <div class="panel"><button id="codexBtn">ğŸ“– ë„ê°</button></div>
            </div>

            <!-- ë¯¸ë‹ˆë§µ (ìš°ìƒë‹¨) -->
            <div id="miniWrapper"><canvas id="miniMap" width="260" height="260"></canvas></div>

        </div>

        <!-- ì¤‘ì•™ ë¯¸ë¡œ ìº”ë²„ìŠ¤ (fixed size) -->
        <div id="gameWrapper">
            <canvas id="game" width="480" height="480"></canvas>

        </div>
        <!-- ì¡°ì´ìŠ¤í‹± (í•˜ë‹¨ ì¤‘ì•™ ê³ ì •) -->
        <div id="joystickWrap">
            <div id="joystick">
                <div id="stick"></div>
            </div>
        </div>
    </div>

    <!-- ì˜¤ë²„ë ˆì´: ì¸íŠ¸ë¡œ/ìŠ¤í† ë¦¬/ì½”ë±ìŠ¤ ìƒì„¸ ë“±ì´ ì¬ì‚¬ìš© -->
    <div id="overlay" class="overlay">
        <div class="panel" id="overlayPanel">
            <!-- ì½˜í…ì¸  ë™ì  ì‚½ì… -->
        </div>
    </div>

    <!-- ì½”ë±ìŠ¤ ì „ìš© ì˜¤ë²„ë ˆì´ (ë¦¬ìŠ¤íŠ¸) -->
    <div id="codexOverlay" class="overlay">
        <div class="panel" id="codexPanel"></div>
    </div>

    <script>
        /* =====================================================
           ëœë¤ ë¯¸ë¡œ ê²Œì„ - í†µí•© ì™„ì„±ë³¸
           - ìš”êµ¬ì‚¬í•­ ë°˜ì˜:
             ì¸íŠ¸ë¡œ -> ì‹œì‘ ë²„íŠ¼ -> ì¸íŠ¸ë¡œ ìŠ¤í† ë¦¬(ë„ê° ìë™ í•´ê¸ˆ) -> ë¯¸ë¡œ ì‹œì‘
             ì•„ì´í…œ: ì—´ì‡ (key), ë‚˜ì¹¨ë°˜(compass) (ëœë¤ ë°°ì¹˜)
             ì—´ì‡  ì†Œì§€ ì‹œ ì¶œêµ¬ í†µê³¼ ê°€ëŠ¥
             revealAround() ì‹œì•¼ êµ¬í˜„ + miniMap: ì§€ë‚˜ê°„ ê¸¸ë§Œ í‘œì‹œ
             ë„ê°(localStorage): í•´ê¸ˆ ì—¬ë¶€ + (compass) ë©”ì‹œì§€ ì €ì¥
             ë¸”ëŸ­ ì´ë¯¸ì§€(1x1~3x3) ìë™ ìŠ¤ì¼€ì¼ë§
             HUD / ì¤‘ì•™ë¯¸ë¡œ / ìš°ìƒë‹¨ ë¯¸ë‹ˆë§µ / í•˜ë‹¨ ì¤‘ì•™ ì¡°ì´ìŠ¤í‹±
           ===================================================== */

        ///// ì €ì¥ í‚¤ & ì´ˆê¸° ìŠ¤í† ë¦¬ ë°ì´í„°
        const STORAGE_KEY = 'maze_collectedStories_v1';

        // ìŠ¤í† ë¦¬ ìŠ¬ë¡¯ ë° í…ìŠ¤íŠ¸ (compassëŠ” ë ˆë²¨ë³„ ë‹¤ì¤‘ ë©”ì‹œì§€ í’€)
        const storySlots = [
            { id: 'intro', label: 'í”„ë¡¤ë¡œê·¸' },
            { id: 'key', label: 'ì—´ì‡ ' },
            // gem ì œê±° (íšŒì˜ ê²°ê³¼)
            { id: 'compass', label: 'ë‚˜ì¹¨ë°˜' },
            { id: 'level1', label: 'ë ˆë²¨1' },
            { id: 'level2', label: 'ë ˆë²¨2' },
            { id: 'ending', label: 'ì—”ë”©' }
        ];

        const storyTexts = {
            intro: ['ê¹Šì€ ë¯¸ê¶ ì†ìœ¼ë¡œ ë°œì„ ë‚´ë”›ì—ˆë‹¤. ì–´ë‘  ì†ì—ì„œ ë¬´ì–¸ê°€ ì†ì‚­ì´ëŠ” ë“¯í•˜ë‹¤...'],
            key: ['ë‚¡ì€ ì—´ì‡ ë¥¼ ì†ì— ë„£ì—ˆë‹¤. ë…¹ìŠ¨ ê¸ˆì†ì´ ì°¨ê°‘ê²Œ ë‹¿ëŠ”ë‹¤.'],
            // compass: ë ˆë²¨ë³„ ë©”ì‹œì§€ í’€ (ëœë¤ ì„ íƒ)
            compass: [
                ['ì„œìª½ì—ì„œ ê¸°ë¬˜í•œ ê¸°ìš´ì´ ëŠê»´ì§„ë‹¤...', 'ë‚˜ì¹¨ë°˜ì´ ê°‘ìê¸° í”ë“¤ë¦¬ë©° ë°©í–¥ì„ ìƒëŠ”ë‹¤...'],
                ['ë©€ë¦¬ì„œ ë‚®ì€ ìš¸ìŒì†Œë¦¬ê°€ ë“¤ë ¤ì˜¨ë‹¤...', 'ë²½ì— ìƒˆê²¨ì§„ ê³ ëŒ€ ë¬¸ì–‘ì´ ëˆˆì— ë“¤ì–´ì™”ë‹¤...'],
                ['â€˜ì¶œêµ¬ëŠ” ì—†ë‹¤â€™ëŠ” ëª©ì†Œë¦¬ê°€ ë©”ì•„ë¦¬ì³¤ë‹¤...', 'ì°¨ê°‘ê³  ìŠµí•œ ê³µê¸°ê°€ ë” ì§™ì–´ì¡Œë‹¤...']
            ],
            level1: ['ì²« ë²ˆì§¸ ë¯¸ê¶ì„ í†µê³¼í–ˆë‹¤!'],
            level2: ['ë” ê¹Šì€ ê³³ìœ¼ë¡œ ë°œê±¸ìŒì„ ì˜®ê¸´ë‹¤...'],
            ending: ['ë“œë””ì–´ ë¯¸ê¶ì—ì„œ íƒˆì¶œí–ˆë‹¤!']
        };

        let collectedStories = {}; // { id: {unlocked:true, text: '...'} } or { id: true }

        function loadStories() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) { collectedStories = {}; return; }
                collectedStories = JSON.parse(raw) || {};
            } catch (e) { console.warn('loadStories error', e); collectedStories = {}; }
        }
        function saveStories() {
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(collectedStories)); } catch (e) { console.warn('saveStories', e); }
        }

        /* ---------------------------
           ìº”ë²„ìŠ¤ ì„¸íŒ…
           --------------------------- */
        const gameCanvas = document.getElementById('game');
        const ctx = gameCanvas.getContext('2d');
        const miniCanvas = document.getElementById('miniMap');
        const miniCtx = miniCanvas.getContext('2d');

        let tileSize = 30; // íƒ€ì¼ í”½ì…€ í¬ê¸° (ê³ ì •)
        const getCanvasSize = () => ({ w: gameCanvas.width, h: gameCanvas.height });

        /* ---------------------------
           ë¸”ëŸ­ ì´ë¯¸ì§€ (1x1 ~ 3x3)
           - ì œê³µëœ ì´ë¯¸ì§€ë¥¼ tileSizeì— ë§ì¶° ìë™ ìŠ¤ì¼€ì¼ë§í•´ì„œ ê·¸ë¦½ë‹ˆë‹¤.
           - ê²½ë¡œëŠ” í•„ìš”ì‹œ êµì²´í•˜ì„¸ìš”.
           --------------------------- */
        const blockImages = {
            "1x1": new Image(), "1x2": new Image(), "1x3": new Image(),
            "2x1": new Image(), "2x2": new Image(), "2x3": new Image(),
            "3x1": new Image(), "3x2": new Image(), "3x3": new Image()
        };
        // (ì´ë¯¸ì§€ ê²½ë¡œ: í•„ìš”ì‹œ ë°”ê¾¸ì„¸ìš”)
        blockImages["1x1"].src = "img/block_1x1.png";
        blockImages["1x2"].src = "img/block_1x2.png";
        blockImages["1x3"].src = "img/block_1x3.png";
        blockImages["2x1"].src = "img/block_2x1.png";
        blockImages["2x2"].src = "img/block_2x2.png";
        blockImages["2x3"].src = "img/block_2x3.png";
        blockImages["3x1"].src = "img/block_3x1.png";
        blockImages["3x2"].src = "img/block_3x2.png";
        blockImages["3x3"].src = "img/block_3x3.png";

        /* ---------------------------
           ê²Œì„ ìƒíƒœ ë³€ìˆ˜
           --------------------------- */
        let rows = 21, cols = 21; // ê¸°ë³¸
        let maze = []; // 2D array: 1=wall,0=path
        let revealMap = []; // ì‹œì•¼(ë³´ì—¬ì§„ íƒ€ì¼) boolean
        let visitedMap = []; // ë¯¸ë‹ˆë§µìš©: ì§€ë‚˜ê°„ ê¸¸ë§Œ true
        let items = []; // [{x,y,type, collected, storyId, message?}]
        let level = 1;

        let player = { x: 1.5, y: 1.5, size: 0.65, vx: 0, vy: 0 }; // ì¢Œí‘œëŠ” íƒ€ì¼ ë‹¨ìœ„ (1.5 = ì¤‘ì•™)
        let speed = 4.2; // tiles/sec (ì´ ê°’ì€ ì¡°ì´ìŠ¤í‹±/í‚¤ë³´ë“œì— ì˜í•´ ê³±í•´ì§)
        let lastTime = performance.now();

        let goal = { x: cols - 2, y: rows - 2 };

        /* ---------------------------
           DOM references
           --------------------------- */
        const overlay = document.getElementById('overlay');
        const overlayPanel = document.getElementById('overlayPanel');
        const codexOverlay = document.getElementById('codexOverlay');
        const codexPanel = document.getElementById('codexPanel');
        const codexBtn = document.getElementById('codexBtn');
        const levelText = document.getElementById('levelText');
        const itemKeyEl = document.getElementById('itemKey');
        const itemCompassEl = document.getElementById('itemCompass');

        /* ---------------------------
           ìœ í‹¸ í•¨ìˆ˜: inBounds, randInt, distance
           --------------------------- */
        function inBounds(x, y) { return x >= 0 && y >= 0 && x < cols && y < rows; }
        function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
        function dist(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }

        /* ===========================
           ë¯¸ë¡œ ìƒì„± (DFS Carve)
           - í™€ìˆ˜ ì¢Œí‘œ ê¸°ë°˜ carve ë°©ì‹ (1ì¹¸ ë²½/ê¸¸ ìŠ¤íƒ€ì¼ ìœ ì§€)
           =========================== */
        function createEmptyMaze(w, h) {
            const m = [];
            for (let y = 0; y < h; y++) { m[y] = []; for (let x = 0; x < w; x++) m[y][x] = 1; }
            return m;
        }
        function generateMaze(w, h) {
            cols = w; rows = h;
            maze = createEmptyMaze(cols, rows);
            // carve from (1,1)
            const stack = [];
            maze[1][1] = 0;
            stack.push({ x: 1, y: 1 });
            const deltas = [[0, -2], [2, 0], [0, 2], [-2, 0]];
            while (stack.length) {
                const cur = stack[stack.length - 1];
                let neighbors = [];
                for (const d of deltas) {
                    const nx = cur.x + d[0], ny = cur.y + d[1];
                    if (inBounds(nx, ny) && maze[ny][nx] === 1) neighbors.push(d);
                }
                if (neighbors.length === 0) { stack.pop(); continue; }
                const ch = neighbors[Math.floor(Math.random() * neighbors.length)];
                const betweenX = cur.x + ch[0] / 2;
                const betweenY = cur.y + ch[1] / 2;
                const nx = cur.x + ch[0];
                const ny = cur.y + ch[1];
                maze[betweenY][betweenX] = 0;
                maze[ny][nx] = 0;
                stack.push({ x: nx, y: ny });
            }
            // goal ensure open
            let possibleGoals = [];

            // ìƒë‹¨ í…Œë‘ë¦¬: y=0
            for (let x = 1; x < cols - 1; x++) {
                if (maze[1][x] === 0) possibleGoals.push({ x, y: 0 }); // ìƒë‹¨ ë²½, ë°”ë¡œ ì•„ë˜ê°€ ê¸¸
            }

            // í•˜ë‹¨ í…Œë‘ë¦¬: y=rows-1
            for (let x = 1; x < cols - 1; x++) {
                if (maze[rows - 2][x] === 0) possibleGoals.push({ x, y: rows - 1 }); // í•˜ë‹¨ ë²½, ë°”ë¡œ ìœ„ê°€ ê¸¸
            }

            // ì¢Œì¸¡ í…Œë‘ë¦¬: x=0
            for (let y = 1; y < rows - 1; y++) {
                if (maze[y][1] === 0) possibleGoals.push({ x: 0, y }); // ì¢Œì¸¡ ë²½, ë°”ë¡œ ì˜¤ë¥¸ìª½ì´ ê¸¸
            }

            // ìš°ì¸¡ í…Œë‘ë¦¬: x=cols-1
            for (let y = 1; y < rows - 1; y++) {
                if (maze[y][cols - 2] === 0) possibleGoals.push({ x: cols - 1, y }); // ìš°ì¸¡ ë²½, ë°”ë¡œ ì™¼ìª½ì´ ê¸¸
            }

            // fallback: ë§¨ ì˜¤ë¥¸ìª½ ì•„ë˜ ì•ˆìª½ ì¹¸
            if (possibleGoals.length === 0) possibleGoals.push({ x: cols - 2, y: rows - 2 });

            // ëœë¤ ì„ íƒ
            goal = possibleGoals[Math.floor(Math.random() * possibleGoals.length)];

            // goal ì¹¸ì€ ë²½ìœ¼ë¡œ ìœ ì§€ (ì¶œêµ¬ í‘œì‹œìš©)
            maze[goal.y][goal.x] = 2;


            // // í…Œë‘ë¦¬ í›„ë³´ ìˆ˜ì§‘ (0 ~ length-1 í¬í•¨)
            // let possibleGoals = [];

            // // ìƒë‹¨, í•˜ë‹¨ í…Œë‘ë¦¬
            // for (let x = 0; x < cols; x++) {
            //     if (maze[0][x] === 0) possibleGoals.push({ x, y: 0 });
            //     if (maze[rows - 1][x] === 0) possibleGoals.push({ x, y: rows - 1 });
            // }

            // // ì¢Œì¸¡, ìš°ì¸¡ í…Œë‘ë¦¬
            // for (let y = 1; y < rows - 1; y++) { // ìƒë‹¨/í•˜ë‹¨ì€ ì´ë¯¸ í¬í•¨í–ˆìœ¼ë¯€ë¡œ 1~rows-2
            //     if (maze[y][0] === 0) possibleGoals.push({ x: 0, y });
            //     if (maze[y][cols - 1] === 0) possibleGoals.push({ x: cols - 1, y });
            // }

            // // fallback
            // if (possibleGoals.length === 0) possibleGoals.push({ x: cols - 1, y: rows - 1 });

            // // goal ëœë¤ ì„ íƒ
            // goal = possibleGoals[Math.floor(Math.random() * possibleGoals.length)];

            // // goal ìœ„ì¹˜ëŠ” ë°˜ë“œì‹œ ê¸¸ë¡œ
            // maze[goal.y][goal.x] = 0;

            // // ==============================
            // // goal: ë¯¸ë¡œ í…Œë‘ë¦¬ ì¤‘ ëœë¤ ìœ„ì¹˜ë¡œ ì§€ì •
            // // - í…Œë‘ë¦¬(ìƒë‹¨, í•˜ë‹¨, ì¢Œì¸¡, ìš°ì¸¡) ì¤‘ ê¸¸(0)ì¸ ì¹¸ì„ ìˆ˜ì§‘
            // // - ëœë¤ ì„ íƒ
            // // - ë§Œì•½ í…Œë‘ë¦¬ì— ê¸¸ì´ ì—†ìœ¼ë©´ fallbackìœ¼ë¡œ ì˜¤ë¥¸ìª½ ì•„ë˜ ì§€ì •
            // // ==============================
            // let possibleGoals = [];

            // // ìƒë‹¨, í•˜ë‹¨ í…Œë‘ë¦¬
            // for (let x = 1; x < cols - 1; x++) {
            //     if (maze[0][x] === 0) possibleGoals.push({ x, y: 0 });
            //     if (maze[rows - 1][x] === 0) possibleGoals.push({ x, y: rows - 1 });
            // }

            // // ì¢Œì¸¡, ìš°ì¸¡ í…Œë‘ë¦¬
            // for (let y = 1; y < rows - 1; y++) {
            //     if (maze[y][0] === 0) possibleGoals.push({ x: 0, y });
            //     if (maze[y][cols - 1] === 0) possibleGoals.push({ x: cols - 1, y });
            // }

            // // í…Œë‘ë¦¬ì— ê¸¸ì´ ì—†ì„ ê²½ìš° fallback
            // if (possibleGoals.length === 0) possibleGoals.push({ x: cols - 2, y: rows - 2 });

            // // goal ì„ íƒ
            // goal = possibleGoals[Math.floor(Math.random() * possibleGoals.length)];

            // // goal ìœ„ì¹˜ëŠ” ë°˜ë“œì‹œ ê¸¸ë¡œ ë§Œë“¤ê¸°
            // maze[goal.y][goal.x] = 0;

            // goal.x = cols - 2; goal.y = rows - 2;
            // maze[goal.y][goal.x] = 0;

            // reveal/visited ì´ˆê¸°í™”
            revealMap = Array.from({ length: rows }, () => Array(cols).fill(false));
            visitedMap = Array.from({ length: rows }, () => Array(cols).fill(false));
        }

        /* ===========================
           ì•„ì´í…œ ë°°ì¹˜
           - key(ì—´ì‡ ) 1ê°œ, compass(ë‚˜ì¹¨ë°˜) ë ˆë²¨ë‹¹ 1ê°œ
           - ëœë¤ ë°°ì¹˜(ê¸¸ ìœ„), ì‹œì‘/ì¢…ë£Œ ê·¼ì²˜ëŠ” í”¼í•¨
           =========================== */
        function findRandomPathCell(avoidNearStart = true) {
            for (let tries = 0; tries < 5000; tries++) {
                const x = randInt(1, cols - 2);
                const y = randInt(1, rows - 2);
                if (maze[y][x] !== 0) continue;
                // avoid start/goal proximity
                if (avoidNearStart) {
                    if (Math.abs(x - 1) + Math.abs(y - 1) < 4) continue;
                    if (Math.abs(x - goal.x) + Math.abs(y - goal.y) < 4) continue;
                }
                return { x, y };
            }
            // fallback: first path cell
            for (let y = 1; y < rows - 1; y++) for (let x = 1; x < cols - 1; x++) if (maze[y][x] === 0) return { x, y };
            return { x: 1, y: 1 };
        }

        function placeItemsForLevel(lv) {
            items = [];
            // key
            const k = findRandomPathCell(true);
            items.push({ type: 'key', x: k.x, y: k.y, collected: false, storyId: 'key' });
            // compass (one per level)
            const c = findRandomPathCell(true);
            // select random message from pool (if exists for level)
            let pool = (storyTexts.compass && storyTexts.compass[lv - 1]) || (storyTexts.compass && storyTexts.compass[0]) || ['ë‚˜ì¹¨ë°˜ì´ ì¡°ìš©í•˜ë‹¤.'];
            const chosen = pool[Math.floor(Math.random() * pool.length)];
            const storyId = `compass_${lv}`;
            items.push({ type: 'compass', x: c.x, y: c.y, collected: false, storyId: storyId, message: chosen });
        }

        /* ===========================
           ì¶©ëŒ ê²€ì‚¬ (player.size ë°˜ì˜)
           - player coords are in tiles. size is fraction of tile (e.g. 0.65)
           - check four corners in tile coords (floor)
           =========================== */
        function canMoveTo(newX, newY) {
            const half = player.size / 2;
            const corners = [
                { x: newX - half, y: newY - half },
                { x: newX + half, y: newY - half },
                { x: newX - half, y: newY + half },
                { x: newX + half, y: newY + half }
            ];
            for (const c of corners) {
                const tx = Math.floor(c.x);
                const ty = Math.floor(c.y);
                // if (!inBounds(tx, ty) ) return false;
                if (!inBounds(tx, ty) || maze[ty][tx] === 1) return false;
                return (maze[ty][tx] === 0 || maze[ty][tx] === 2);
                // if (maze[ty][tx] === 1) return false;
            }
            return true;
        }

        /* ===========================
           ì‹œì•¼ & ë¯¸ë‹ˆë§µ
           - revealAround(px,py): ì£¼ë³€ revealRadius íƒ€ì¼ì„ trueë¡œ ì„¤ì •
           - visitedMap: í”Œë ˆì´ì–´ê°€ ì§€ë‚˜ê°„ pathë§Œ true (ë¯¸ë‹ˆë§µìš©)
           =========================== */
        let revealRadius = 3;
        function revealAround(px, py) {
            const cx = Math.floor(px), cy = Math.floor(py);
            for (let dy = -revealRadius; dy <= revealRadius; dy++) {
                for (let dx = -revealRadius; dx <= revealRadius; dx++) {
                    const x = cx + dx, y = cy + dy;
                    if (inBounds(x, y)) {
                        revealMap[y][x] = true;
                    }
                }
            }
            // mark current tile as visited (miniMap)
            if (inBounds(cx, cy) && maze[cy][cx] === 0) visitedMap[cy][cx] = true;
        }

        /* ===========================
           ìŠ¤í† ë¦¬(ë„ê°) í•´ê¸ˆ ë° ì˜¤ë²„ë ˆì´ í‘œì‹œ
           - unlockStory(id, text?)
           - stored format: collectedStories[id] = {unlocked:true, text: '...'} OR true
           - ì¸íŠ¸ë¡œëŠ” ì²˜ìŒ ì‹œì‘ ë²„íŠ¼ í´ë¦­ í›„ í˜¸ì¶œí•˜ì—¬ 1íšŒ í•´ê¸ˆ
           =========================== */
        function unlockStory(id, text) {
            // If already unlocked, still may show overlay if text provided? We'll avoid re-showing on duplicate unlock.
            if (!collectedStories[id]) {
                collectedStories[id] = { unlocked: true, text: text || (storyTexts[id] ? (Array.isArray(storyTexts[id]) ? storyTexts[id][0] : storyTexts[id]) : '') };
                saveStories();
            }
            // Show overlay with text (pull stored text if present)
            const data = collectedStories[id];
            const showText = (data && data.text) || text || (storyTexts[id] ? (Array.isArray(storyTexts[id]) ? storyTexts[id][0] : storyTexts[id]) : '(ê¸°ë¡ ì—†ìŒ)');
            showStoryOverlay(`${id}`, showText, 3000); // ìë™ìœ¼ë¡œ 3ì´ˆ í›„ ë‹«í˜
        }

        /* Show overlay with text and optional image; autoCloseMs = milliseconds or 0 for no auto-close */
        function showStoryOverlay(title, text, autoCloseMs = 3000) {
            overlayPanel.innerHTML = '';
            // simple layout: title, text (and placeholder for image if needed)
            const h = document.createElement('div');
            h.innerHTML = `<h3 style="margin:0 0 6px">${title}</h3>`;
            overlayPanel.appendChild(h);
            if (text && text.length > 0) {
                const p = document.createElement('p');
                p.textContent = text;
                overlayPanel.appendChild(p);
            }
            // close button area
            const actions = document.createElement('div');
            actions.className = 'actions';
            const closeBtn = document.createElement('button');
            closeBtn.className = 'ghost';
            closeBtn.textContent = 'ë‹«ê¸°';
            closeBtn.onclick = () => { overlay.style.display = 'none'; };
            actions.appendChild(closeBtn);
            overlayPanel.appendChild(actions);

            overlay.style.display = 'flex';
            if (autoCloseMs && autoCloseMs > 0) {
                setTimeout(() => { if (overlay.style.display === 'flex') overlay.style.display = 'none'; }, autoCloseMs);
            }
        }

        /* ---------------------------
           ì½”ë±ìŠ¤(ë„ê°) UI
           - ë¦¬ìŠ¤íŠ¸ í‘œì‹œ, í´ë¦­í•˜ë©´ ìƒì„¸ ë„ê° í…ìŠ¤íŠ¸ë¥¼ overlayë¡œ í‘œì‹œ
           --------------------------- */
        function openCodex() {
            codexPanel.innerHTML = '<h3 style="margin-top:0">ìŠ¤í† ë¦¬ ë„ê°</h3>';
            storySlots.forEach(s => {
                const owned = !!collectedStories[s.id];
                const mark = owned ? 'âœ…' : 'âŒ';
                // choose display text: if unlocked with text then show preview, else ??? 
                let preview = '???';
                if (owned) {
                    const d = collectedStories[s.id];
                    if (d && d.text) preview = d.text.length > 80 ? d.text.slice(0, 77) + '...' : d.text;
                    else preview = (storyTexts[s.id] && storyTexts[s.id][0]) || 'í•´ê¸ˆë¨';
                }
                const row = document.createElement('div');
                row.style.padding = '8px 0';
                row.style.borderBottom = '1px dashed #222';
                row.innerHTML = `<strong style="display:block">${mark} ${s.label}</strong><small>${preview}</small>`;
                row.style.cursor = 'pointer';
                row.onclick = () => {
                    // show detail overlay for this slot
                    const fullText = (collectedStories[s.id] && collectedStories[s.id].text) || (storyTexts[s.id] && storyTexts[s.id][0]) || '(ì ê¸ˆ)';
                    showStoryOverlay(s.label, fullText, 0); // 0 -> don't auto close, let user close
                    codexOverlay.style.display = 'none';
                };
                codexPanel.appendChild(row);
            });
            const close = document.createElement('div');
            close.style.marginTop = '8px';
            close.innerHTML = `<div style="text-align:right"><button class="primary" id="codexClose">ë‹«ê¸°</button></div>`;
            codexPanel.appendChild(close);
            codexOverlay.style.display = 'flex';
            document.getElementById('codexClose').onclick = () => { codexOverlay.style.display = 'none'; };
        }

        /* ---------------------------
           HUD ì—…ë°ì´íŠ¸
           --------------------------- */
        function updateHud() {
            levelText.textContent = level;
            itemKeyEl.textContent = collectedStories['key'] ? 'ğŸ”‘' : 'âŒ';
            // compass could be per-level: show if any compass_n unlocked for current or previous levels
            const compId = `compass_${level}`;
            const hasCompass = !!(collectedStories[compId] || collectedStories['compass']);
            itemCompassEl.textContent = hasCompass ? 'ğŸ§­' : 'âŒ';
        }

        /* ---------------------------
           ì•„ì´í…œ ìˆ˜ì§‘ ì²˜ë¦¬
           - items ë°°ì—´ì„ ìˆœíšŒí•˜ì—¬ í”Œë ˆì´ì–´ê°€ ê°€ê¹Œì´ ê°€ë©´ ìˆ˜ì§‘
           - ìˆ˜ì§‘ ì‹œ ë„ê° unlock ë° overlay í‘œì‹œ (compassëŠ” ë©”ì‹œì§€ ê¸°ë¡)
           --------------------------- */
        function tryCollectItems() {
            for (let i = items.length - 1; i >= 0; i--) {
                const it = items[i];
                if (!it) continue;
                const d = dist(player.x, player.y, it.x + 0.5, it.y + 0.5);
                if (d < 0.8) {
                    // collect
                    it.collected = true;
                    items.splice(i, 1);
                    if (it.type === 'compass') {
                        // store compass message under storyId (compass_level)
                        collectedStories[it.storyId] = { unlocked: true, text: it.message };
                        saveStories();
                        showStoryOverlay('ë‚˜ì¹¨ë°˜', it.message, 3000);
                    } else if (it.type === 'key') {
                        hasKey = true; // í˜„ì¬ ë ˆë²¨ì—ì„œ ì—´ì‡  ì†Œìœ 
                        // key: fixed story text
                        unlockStory('key', storyTexts.key[0]);
                    } else {
                        unlockStory(it.storyId, it.message || 'ì•„ì´í…œ íšë“');
                    }
                    updateHud();
                    // small toast
                    showToast(`íšë“: ${it.type}`);
                }
            }
        }

        /* ---------------------------
           í† ìŠ¤íŠ¸
           --------------------------- */
        function showToast(text, ms = 1600) {
            const t = document.createElement('div'); t.className = 'toast'; t.textContent = text;
            document.body.appendChild(t);
            setTimeout(() => { t.remove(); }, ms);
        }

        /* ---------------------------
           ëª©í‘œ(ì¶œêµ¬) ë„ë‹¬ ì²˜ë¦¬
           - ì—´ì‡ ê°€ ìˆì–´ì•¼ í†µê³¼ ê°€ëŠ¥ (key í•´ê¸ˆ)
           --------------------------- */
        let hasKey = false;

        let levelCleared = false;
        function checkGoal() {
            // í”Œë ˆì´ì–´ì™€ ëª©í‘œ ì§€ì (ì…€ ì¤‘ì•™) ê±°ë¦¬ ê³„ì‚°
            const d = dist(player.x, player.y, goal.x + 0.5, goal.y + 0.5);

            // ì¶©ë¶„íˆ ê°€ê¹Œìš°ë©´ ë„ë‹¬ë¡œ íŒì •
            if (d < 0.8 && !levelCleared) {
                if (hasKey) {
                    // if (collectedStories['key']) {
                    // ğŸ”‘ ì—´ì‡ ë¥¼ ê°€ì§„ ê²½ìš° â†’ ë ˆë²¨ í´ë¦¬ì–´ ì²˜ë¦¬
                    levelCleared = true;

                    // ë„ê°ì— ë ˆë²¨ í´ë¦¬ì–´ ìŠ¤í† ë¦¬ í•´ê¸ˆ
                    unlockStory(
                        `level${level}`,
                        (storyTexts[`level${level}`] && storyTexts[`level${level}`][0]) || `ë ˆë²¨ ${level} í´ë¦¬ì–´`
                    );

                    // ì˜¤ë²„ë ˆì´ë¡œ ì•Œë¦¼
                    showStoryOverlay('ë ˆë²¨ í´ë¦¬ì–´', `ë ˆë²¨ ${level} í´ë¦¬ì–´! ë‹¤ìŒ ë ˆë²¨ë¡œ ì´ë™í•©ë‹ˆë‹¤.`, 2500);

                    // ë‹¤ìŒ ë ˆë²¨ ì‹œì‘
                    setTimeout(() => {
                        level++;
                        startLevel(level);
                    }, 2300);

                } else {
                    // ğŸ”‘ ì—†ìœ¼ë©´ ì¶œêµ¬ í†µê³¼ ë¶ˆê°€
                    showToast('ì•„ì´í…œì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ğŸ”‘ë¥¼ ëª¨ì•„ì•¼ í•©ë‹ˆë‹¤.', 1800);
                }
            }
        }


        // function checkGoal() {
        //     const d = dist(player.x, player.y, goal.x + 0.5, goal.y + 0.5);
        //     if (d < 0.8 && !levelCleared) {
        //         if (collectedStories['key']) {
        //             levelCleared = true;
        //             // unlock level story
        //             unlockStory(`level${level}`, (storyTexts[`level${level}`] && storyTexts[`level${level}`][0]) || `ë ˆë²¨ ${level} í´ë¦¬ì–´`);
        //             showStoryOverlay('ë ˆë²¨ í´ë¦¬ì–´', `ë ˆë²¨ ${level} í´ë¦¬ì–´! ë‹¤ìŒ ë ˆë²¨ë¡œ ì´ë™í•©ë‹ˆë‹¤.`, 2500);
        //             setTimeout(() => { level++; startLevel(level); }, 2300);
        //         } else {
        //             // can't pass
        //             showToast('ì•„ì´í…œì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ğŸ”‘ë¥¼ ëª¨ì•„ì•¼ í•©ë‹ˆë‹¤.', 1800);
        //         }
        //     }
        // }

        /* ===========================
           ê·¸ë¦¬ê¸° ë¡œì§
           - ë©”ì¸ ìº”ë²„ìŠ¤: íƒ€ì¼(ë²½/ë°”ë‹¥), ë¸”ëŸ­ ì´ë¯¸ì§€ ì ìš©, ì•„ì´í…œ, í”Œë ˆì´ì–´, ì¶œêµ¬
           - ë¯¸ë‹ˆë§µ: visitedMapì— ë”°ë¼ ì§€ë‚˜ê°„ ê¸¸ë§Œ í‘œì‹œ
           =========================== */

        function getBlockRunSize(x, y) {
            // Count how many consecutive wall tiles to the right (w) and down (h), max 3
            if (maze[y][x] !== 1) return { w: 0, h: 0 };
            let w = 1, h = 1;
            for (let sx = 1; sx < 3; sx++) {
                if (inBounds(x + sx, y) && maze[y][x + sx] === 1) w++; else break;
            }
            for (let sy = 1; sy < 3; sy++) {
                if (inBounds(x, y + sy) && maze[y + sy][x] === 1) h++; else break;
            }
            w = Math.min(3, w); h = Math.min(3, h);
            return { w, h };
        }

        // function draw() {
        //     // clear
        //     ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

        //     // draw tiles. We will draw block images only for top-left of a run to avoid overlap.
        //     for (let y = 0; y < rows; y++) {
        //         for (let x = 0; x < cols; x++) {
        //             const px = x * tileSize, py = y * tileSize;
        //             // if tile not yet revealed, draw dark overlay (fog)
        //             const revealed = revealMap[y] && revealMap[y][x];
        //             if (!revealed) {
        //                 // cover with dark rectangle
        //                 ctx.fillStyle = '#050506';
        //                 ctx.fillRect(px, py, tileSize, tileSize);
        //                 continue;
        //             }
        //             if (maze[y][x] === 1) {
        //                 // draw wall using block images where appropriate
        //                 // Only draw when this tile is top-left of a block run (no wall at left and above)
        //                 const leftIsWall = (x > 0 && maze[y][x - 1] === 1);
        //                 const aboveIsWall = (y > 0 && maze[y - 1][x] === 1);
        //                 if (!leftIsWall && !aboveIsWall) {
        //                     const { w, h } = getBlockRunSize(x, y);
        //                     const key = `${w}x${h}`;
        //                     const img = blockImages[key];
        //                     if (img && img.complete && img.naturalWidth > 0) {
        //                         // draw scaled to (w*tileSize, h*tileSize)
        //                         ctx.drawImage(img, px, py, w * tileSize, h * tileSize);
        //                     } else {
        //                         // fallback fill
        //                         ctx.fillStyle = '#222';
        //                         ctx.fillRect(px, py, w * tileSize, h * tileSize);
        //                     }
        //                 } else {
        //                     // If not top-left, just leave it (it will be covered by the top-left draw), but ensure single tile fallback if images not ready:
        //                     // draw small fallback for individual uncovered wall tiles
        //                     ctx.fillStyle = '#222';
        //                     ctx.fillRect(px, py, tileSize, tileSize);
        //                 }
        //             } else {
        //                 // floor
        //                 ctx.fillStyle = '#cfcfcf';
        //                 ctx.fillRect(px, py, tileSize, tileSize);
        //             }
        //         }
        //     }

        //     // draw goal if revealed
        //     if (revealMap[goal.y] && revealMap[goal.y][goal.x]) {
        //         ctx.fillStyle = '#2ecc71';
        //         ctx.fillRect(goal.x * tileSize + tileSize * 0.15, goal.y * tileSize + tileSize * 0.15, tileSize * 0.7, tileSize * 0.7);
        //     }

        //     // draw items (only if their tile revealed)
        //     for (const it of items) {
        //         if (it.collected) continue;
        //         if (!revealMap[it.y] || !revealMap[it.y][it.x]) continue;
        //         const cx = it.x * tileSize + tileSize / 2, cy = it.y * tileSize + tileSize / 2;
        //         ctx.beginPath();
        //         ctx.arc(cx, cy, tileSize * 0.28, 0, Math.PI * 2);
        //         if (it.type === 'key') ctx.fillStyle = '#ffcc00';
        //         else if (it.type === 'compass') ctx.fillStyle = '#7f5cff';
        //         else ctx.fillStyle = '#fff';
        //         ctx.fill();
        //     }

        //     // draw player (as square)
        //     const px = player.x * tileSize, py = player.y * tileSize;
        //     const psize = player.size * tileSize;
        //     ctx.fillStyle = '#ff4b4b';
        //     ctx.fillRect(px - psize / 2, py - psize / 2, psize, psize);

        //     // debug: draw player center
        //     // ctx.fillStyle='#0f0'; ctx.fillRect(px-2,py-2,4,4);
        // }

        function getBlockType(x, y) {
            let h = 1, w = 1;

            // ì˜¤ë¥¸ìª½ì´ ë²½ì´ë©´ ê°€ë¡œ í™•ì¥
            if (maze[y][x + 1] === 1) w++;
            // ì•„ë˜ê°€ ë²½ì´ë©´ ì„¸ë¡œ í™•ì¥
            if (maze[y + 1] && maze[y + 1][x] === 1) h++;

            return `${w}x${h}`; // "1x1", "2x1", "1x2", "2x2" ë“±
        }


        function draw() {
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            // ì¹´ë©”ë¼ ì˜¤í”„ì…‹: í”Œë ˆì´ì–´ë¥¼ ì¤‘ì•™ì— ê³ ì •
            const offsetX = gameCanvas.width / 2 - player.x * tileSize;
            const offsetY = gameCanvas.height / 2 - player.y * tileSize;

            // ë°©ë¬¸ ì²´í¬ìš© ë°°ì—´
            const visited = Array.from({ length: rows }, () => Array(cols).fill(false));

            // ë²½ & ê¸¸
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] === 1 && !visited[y][x]) {
                        let placed = false;

                        // --- ê°€ë¡œ ê·¸ë£¹í•‘ (ìµœëŒ€ 3ì¹¸) ---
                        let lenX = 1;
                        while (
                            x + lenX < cols &&
                            lenX < 3 &&
                            maze[y][x + lenX] === 1 &&
                            !visited[y][x + lenX]
                        ) {
                            lenX++;
                        }
                        if (lenX > 1) {
                            let type = `1x${lenX}`; // "1x2", "1x3"
                            let img = blockImages[type] || blockImages["1x1"];
                            ctx.drawImage(
                                img,
                                x * tileSize + offsetX,
                                y * tileSize + offsetY,
                                tileSize * lenX,
                                tileSize
                            );
                            for (let i = 0; i < lenX; i++) visited[y][x + i] = true;
                            placed = true;
                        }

                        // --- ì„¸ë¡œ ê·¸ë£¹í•‘ (ìµœëŒ€ 3ì¹¸) ---
                        if (!placed) {
                            let lenY = 1;
                            while (
                                y + lenY < rows &&
                                lenY < 3 &&
                                maze[y + lenY][x] === 1 &&
                                !visited[y + lenY][x]
                            ) {
                                lenY++;
                            }
                            if (lenY > 1) {
                                let type = `${lenY}x1`; // "2x1", "3x1"
                                let img = blockImages[type] || blockImages["1x1"];
                                ctx.drawImage(
                                    img,
                                    x * tileSize + offsetX,
                                    y * tileSize + offsetY,
                                    tileSize,
                                    tileSize * lenY
                                );
                                for (let i = 0; i < lenY; i++) visited[y + i][x] = true;
                                placed = true;
                            }
                        }

                        // --- ë‹¨ì¼ ë¸”ëŸ­ ---
                        if (!placed) {
                            let img = blockImages["1x1"];
                            ctx.drawImage(
                                img,
                                x * tileSize + offsetX,
                                y * tileSize + offsetY,
                                tileSize,
                                tileSize
                            );
                            visited[y][x] = true;
                        }
                    } else if (maze[y][x] === 0) {
                        // ê¸¸
                        ctx.fillStyle = "white";
                        ctx.fillRect(
                            x * tileSize + offsetX,
                            y * tileSize + offsetY,
                            tileSize,
                            tileSize
                        );
                    }
                }
            }

            // ëª©í‘œ
            ctx.fillStyle = "green";
            ctx.fillRect(
                goal.x * tileSize + offsetX,
                goal.y * tileSize + offsetY,
                tileSize,
                tileSize
            );

            // ì•„ì´í…œ
            items.forEach(it => {
                ctx.fillStyle = it.type === "compass" ? "purple" : "gold";
                ctx.beginPath();
                ctx.arc(
                    it.x * tileSize + tileSize / 2 + offsetX,
                    it.y * tileSize + tileSize / 2 + offsetY,
                    tileSize / 3,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });

            // í”Œë ˆì´ì–´ (í•­ìƒ ì¤‘ì•™ ê³ ì •)
            const psize = tileSize * player.size;
            ctx.fillStyle = "red";
            ctx.fillRect(
                gameCanvas.width / 2 - psize / 2,
                gameCanvas.height / 2 - psize / 2,
                psize,
                psize
            );
        }



        /* ---------------------------
           ë¯¸ë‹ˆë§µ ë Œë”ë§
           - visitedMap trueì¸ path íƒ€ì¼ë§Œ í‘œì‹œ
           - player marker + goal marker
           --------------------------- */
        function drawMiniMap() {
            const w = miniCanvas.width, h = miniCanvas.height;
            miniCtx.clearRect(0, 0, w, h);
            const cellW = w / cols, cellH = h / rows;
            // background
            miniCtx.fillStyle = '#030303';
            miniCtx.fillRect(0, 0, w, h);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (visitedMap[y][x] && maze[y][x] === 0) {
                        miniCtx.fillStyle = '#bfbfbf';
                        miniCtx.fillRect(x * cellW, y * cellH, cellW, cellH);
                    }
                }
            }
            // goal marker (if visited/revealed maybe show regardless)
            miniCtx.fillStyle = '#2ecc71';
            miniCtx.fillRect(goal.x * cellW + cellW * 0.15, goal.y * cellW + cellW * 0.15, cellW * 0.7, cellH * 0.7);

            // items (if visited tile) small circles
            for (const it of items) {
                if (visitedMap[it.y] && visitedMap[it.y][it.x]) {
                    miniCtx.beginPath();
                    miniCtx.fillStyle = (it.type === 'key') ? '#ffcc00' : '#7f5cff';
                    miniCtx.arc((it.x + 0.5) * cellW, (it.y + 0.5) * cellH, Math.min(cellW, cellH) * 0.25, 0, Math.PI * 2);
                    miniCtx.fill();
                }
            }
            // player marker
            miniCtx.fillStyle = '#ff4b4b';
            miniCtx.beginPath();
            miniCtx.arc((player.x) * cellW, (player.y) * cellH, Math.min(cellW, cellH) * 0.32, 0, Math.PI * 2);
            miniCtx.fill();
        }

        /* ---------------------------
           ì…ë ¥ ì²˜ë¦¬: í‚¤ë³´ë“œ (WASD / arrows)
           --------------------------- */
        const keys = {};
        window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

        /* ---------------------------
           ì¡°ì´ìŠ¤í‹± (í•˜ë‹¨ ì¤‘ì•™ ê³ ì •)
           - touch / mouse ì§€ì›
           --------------------------- */
        const joystick = document.getElementById('joystick');
        const stick = document.getElementById('stick');
        let joyActive = false;
        let joyCenter = null;
        function initJoyCenter() { const r = joystick.getBoundingClientRect(); joyCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2 }; }
        initJoyCenter();
        window.addEventListener('resize', initJoyCenter);

        function setStickPos(dx, dy) {
            // dx,dy in range [-1,1]
            const max = (joystick.clientWidth / 2 - stick.clientWidth / 2 - 6);
            const tx = Math.max(-1, Math.min(1, dx)) * max;
            const ty = Math.max(-1, Math.min(1, dy)) * max;
            stick.style.transform = `translate(${tx}px, ${ty}px)`;
        }

        function startJoy(x, y) {
            joyActive = true;
            initJoyCenter();
            updateJoy(x, y);
        }
        function updateJoy(x, y) {
            if (!joyActive || !joyCenter) return;
            let dx = x - joyCenter.x;
            let dy = y - joyCenter.y;
            const distv = Math.hypot(dx, dy);
            const max = joystick.clientWidth / 2;
            if (distv > max) { dx = dx / distv * max; dy = dy / distv * max; }
            const nx = dx / max, ny = dy / max;
            // store velocity in tiles/sec
            player.vx = nx * speed;
            player.vy = ny * speed;
            setStickPos(nx, ny);
        }
        function endJoy() {
            joyActive = false;
            player.vx = 0; player.vy = 0;
            setStickPos(0, 0);
        }

        joystick.addEventListener('touchstart', e => { e.preventDefault(); startJoy(e.touches[0].clientX, e.touches[0].clientY); });
        joystick.addEventListener('touchmove', e => { e.preventDefault(); updateJoy(e.touches[0].clientX, e.touches[0].clientY); });
        joystick.addEventListener('touchend', e => { e.preventDefault(); endJoy(); });

        joystick.addEventListener('mousedown', e => { e.preventDefault(); startJoy(e.clientX, e.clientY); });
        window.addEventListener('mousemove', e => { if (joyActive) updateJoy(e.clientX, e.clientY); });
        window.addEventListener('mouseup', e => { if (joyActive) endJoy(); });

        /* ---------------------------
           ë©”ì¸ ì—…ë°ì´íŠ¸ ë£¨í”„
           - ì…ë ¥ ì²˜ë¦¬(í‚¤ë³´ë“œ+ì¡°ì´ìŠ¤í‹±) -> ë¬¼ë¦¬(ì¶©ëŒê²€ì‚¬) -> ì‹œì•¼/ìˆ˜ì§‘/ëª©í‘œ ì²´í¬ -> ê·¸ë¦¬ê¸°
           --------------------------- */
        // function update(now) {
        //     const dt = Math.min(0.05, (now - lastTime) / 1000);
        //     lastTime = now;

        //     // keyboard input (if no joystick active, keyboard will set velocity)
        //     if (!joyActive) {
        //         let ix = 0, iy = 0;
        //         if (keys['arrowup'] || keys['w']) iy -= 1;
        //         if (keys['arrowdown'] || keys['s']) iy += 1;
        //         if (keys['arrowleft'] || keys['a']) ix -= 1;
        //         if (keys['arrowright'] || keys['d']) ix += 1;
        //         if (ix !== 0 || iy !== 0) {
        //             const len = Math.hypot(ix, iy) || 1;
        //             player.vx = (ix / len) * speed;
        //             player.vy = (iy / len) * speed;
        //         } else {
        //             // no keys: if joystick not active, stop
        //             player.vx = 0; player.vy = 0;
        //         }
        //     }

        //     // attempt movement with sliding
        //     let nextX = player.x + player.vx * dt;
        //     let nextY = player.y + player.vy * dt;
        //     if (canMoveTo(nextX, player.y)) player.x = nextX; else player.vx = 0;
        //     if (canMoveTo(player.x, nextY)) player.y = nextY; else player.vy = 0;

        //     // reveal and mark visited
        //     revealAround(player.x, player.y);

        //     // collect items
        //     tryCollectItems();

        //     // goal check
        //     checkGoal();

        //     // draw
        //     draw();
        //     drawMiniMap();
        //     requestAnimationFrame(update);
        // }
        // í”Œë ˆì´ì–´ í¬ê¸°ë¥¼ ê³ ë ¤í•œ ì¶©ëŒ ê²€ì‚¬
        function canMoveTo(x, y) {
            const half = player.size / 2; // í”Œë ˆì´ì–´ ì ˆë°˜ í¬ê¸°

            // í”Œë ˆì´ì–´ ë„¤ ê¼­ì§“ì  ì¢Œí‘œ
            const corners = [
                { cx: x - half, cy: y - half },
                { cx: x + half, cy: y - half },
                { cx: x - half, cy: y + half },
                { cx: x + half, cy: y + half }
            ];

            for (const p of corners) {
                const gx = Math.floor(p.cx);
                const gy = Math.floor(p.cy);
                // ë²”ìœ„ ë°–ì´ê±°ë‚˜ ë²½ì´ë©´ ì´ë™ ë¶ˆê°€
                if (!inBounds(gx, gy) || maze[gy][gx] === 1) {
                    return false;
                }
            }
            return true;
        }

        // =========================
        // update í•¨ìˆ˜ (í”Œë ˆì´ì–´ ì´ë™, ì¶©ëŒ, ì•„ì´í…œ, ì¶œêµ¬ ì²˜ë¦¬)
        // =========================
        function update(now) {
            const dt = Math.min(0.05, (now - lastTime) / 1000);
            lastTime = now;

            // â”€â”€ í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬ (ì¡°ì´ìŠ¤í‹±ì´ ë¹„í™œì„±ì¼ ë•Œë§Œ)
            if (!joyActive) {
                let ix = 0, iy = 0;
                if (keys['arrowup'] || keys['w']) iy -= 1;
                if (keys['arrowdown'] || keys['s']) iy += 1;
                if (keys['arrowleft'] || keys['a']) ix -= 1;
                if (keys['arrowright'] || keys['d']) ix += 1;
                if (ix !== 0 || iy !== 0) {
                    const len = Math.hypot(ix, iy) || 1;
                    player.vx = (ix / len) * speed;
                    player.vy = (iy / len) * speed;
                } else {
                    player.vx = 0;
                    player.vy = 0;
                }
            }

            // â”€â”€ ì´ë™ ì‹œë„ (ì¶©ëŒ ê²€ì‚¬ í¬í•¨)
            let nextX = player.x + player.vx * dt;
            let nextY = player.y + player.vy * dt;

            if (canMoveTo(nextX, player.y)) {
                player.x = nextX;
            } else {
                player.vx = 0; // ë²½ ì¶©ëŒ â†’ Xë°©í–¥ ì •ì§€
            }

            if (canMoveTo(player.x, nextY)) {
                player.y = nextY;
            } else {
                player.vy = 0; // ë²½ ì¶©ëŒ â†’ Yë°©í–¥ ì •ì§€
            }

            // â”€â”€ ì‹œì•¼ & ë°©ë¬¸ ê²½ë¡œ ì—…ë°ì´íŠ¸
            revealAround(player.x, player.y);

            // â”€â”€ ì•„ì´í…œ íšë“ íŒì •
            tryCollectItems();

            // â”€â”€ ì¶œêµ¬ ë„ë‹¬ íŒì •
            checkGoal();

            // â”€â”€ í™”ë©´ ê°±ì‹ 
            draw();
            drawMiniMap();

            requestAnimationFrame(update);
        }
        /* ---------------------------
           ë ˆë²¨ / ì´ˆê¸°í™”
           --------------------------- */
        function startLevel(lv) {
            hasKey = false;
            level = lv || 1;
            // rows/cols growth: base 21 + (level-1)*2
            cols = 21 + (level - 1) * 2;
            rows = 21 + (level - 1) * 2;
            if (cols % 2 === 0) cols++;
            if (rows % 2 === 0) rows++;
            generateMaze(cols, rows);
            // reset player to start
            player.x = 1.5; player.y = 1.5; player.vx = 0; player.vy = 0;
            levelCleared = false;
            placeItemsForLevel(level);
            revealAround(player.x, player.y);
            updateHud();
        }

        /* ---------------------------
           ì¸íŠ¸ë¡œ íë¦„:
           - ì²˜ìŒ ì‹¤í–‰ ì‹œ overlayì— ì‹œì‘ ë²„íŠ¼ í‘œì‹œ
           - ë²„íŠ¼ í´ë¦­ -> ì¸íŠ¸ë¡œ í…ìŠ¤íŠ¸ ë³´ì—¬ì£¼ê¸° (ìë™ìœ¼ë¡œ ë„ê° í•´ê¸ˆ)
           --------------------------- */
        const showIntroStart = () => {
            overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">í”„ë¡¤ë¡œê·¸</h3>
    <p>ê¹Šì€ ë¯¸ê¶ìœ¼ë¡œ ë“¤ì–´ê°ˆ ì¤€ë¹„ê°€ ë˜ì—ˆë‚˜? ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ íƒí—˜ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
    <div class="actions"><button class="primary" id="startBtn">ê²Œì„ ì‹œì‘</button></div>`;
            overlay.style.display = 'flex';
            document.getElementById('startBtn').onclick = () => {
                // show intro story text, unlock in storage, then close and start level
                overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">í”„ë¡¤ë¡œê·¸</h3>
      <p>${storyTexts.intro[0]}</p>`;
                // unlock intro in storage and show
                collectedStories['intro'] = { unlocked: true, text: storyTexts.intro[0] };
                saveStories();
                setTimeout(() => { overlay.style.display = 'none'; startLevel(1); requestAnimationFrame(update); }, 2200);
            };
        };

        /* ---------------------------
           ì´ˆê¸° ë¡œë“œ: ìŠ¤í† ë¦¬ ë¶ˆëŸ¬ì˜¤ê¸° & ì‹œì‘
           --------------------------- */
        loadStories();
        updateHud();
        // If intro not yet unlocked, show start overlay; else start immediately
        if (!collectedStories['intro']) {
            showIntroStart();
        } else {
            startLevel(level);
            requestAnimationFrame(update);
        }

        /* ---------------------------
           ì½”ë±ìŠ¤ ë²„íŠ¼ ì—°ê²°
           --------------------------- */
        codexBtn.addEventListener('click', () => { openCodex(); });

        /* ---------------------------
           ìœ í‹¸: ì´ˆê¸° ë””ë²„ê·¸ ë…¸ì¶œ (ì½˜ì†”)
           --------------------------- */
        window._GAME = {
            getState: () => ({ level, rows, cols, maze, items, player, collectedStories }),
            resetStories: () => { collectedStories = {}; saveStories(); alert('stories reset'); }
        };

        /* ---------------------------
           ì£¼ì„(í™•ì¥ í¬ì¸íŠ¸)
           - ë°”ë‹¥ íƒ€ì¼ ì´ë¯¸ì§€ ì ìš©: í˜„ì¬ floorì€ ë‹¨ìƒ‰ìœ¼ë¡œ ê·¸ë ¤ì§‘ë‹ˆë‹¤.
             í–¥í›„ floorImages ê°ì²´ë¥¼ ë§Œë“¤ì–´ blockImagesì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ draw()ì—ì„œ floor ì´ë¯¸ì§€ë¥¼ drawí•˜ë©´ ë©ë‹ˆë‹¤.
           - ë¸”ëŸ­ ë””í…Œì¼: í˜„ì¬ 1x1~3x3 ê·¸ë¦¬ë“œë¥¼ ì§€ì›í•©ë‹ˆë‹¤. í•„ìš” ì‹œ ì½”ë„ˆ/ Tì/ ì‹­ì ë“± ë” ì„¬ì„¸í•œ ë§¤í•‘ ë¡œì§ì„ ì¶”ê°€í•˜ì„¸ìš”.
           - ì /íŠ¸ë© ì¶”ê°€: itemsì™€ ìœ ì‚¬í•˜ê²Œ ì  ê°ì²´(ìœ„ì¹˜, íŒ¨í„´)ë¥¼ ì¶”ê°€í•˜ê³  update()ì—ì„œ ì¶©ëŒ/ì´ë™ ë¡œì§ì„ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤.
           --------------------------- */

    </script>
</body>

</html>