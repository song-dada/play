<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ëœë¤ ë¯¸ë¡œ ê²Œì„ (ë¦¬íŒ©í† ë§ ë²„ì „)</title>
    <link rel="stylesheet" href="css/gpt.css">
    <style>
        .loading-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 6px solid rgba(255, 255, 255, 0.15);
            border-top-color: #fff;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-msg {
            font-size: 16px;
            color: #fff;
            text-align: center;
            max-width: 300px;
        }

        .toast {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 30px;
            background: #222;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            opacity: 0.95;
            z-index: 9999;
        }

        #codexPanel .group {
            padding: 10px 0;
            border-bottom: 1px dashed #333;
            cursor: pointer;
        }

        #codexPanel .group .meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #codexPanel .group .meta .title {
            font-weight: 600;
        }

        #codexPanel .group .meta .count {
            font-size: 12px;
            opacity: 0.8;
        }

        pre.story {
            white-space: pre-wrap;
            margin: 6px 0;
            background: #0f0f0f;
            color: #eaeaea;
            padding: 10px;
            border-radius: 6px;
        }

        /* ì‘ì€ ë””ë²„ê·¸ ë²„íŠ¼ (ì„ íƒ) */
        .debug-reset {
            position: fixed;
            right: 12px;
            top: 12px;
            z-index: 9999;
            font-size: 12px;
        }

        /* ë¦¬íŒ©í† ë§ëœ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .hud-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            justify-content: flex-end;
            /* ì˜¤ë¥¸ìª½ ì •ë ¬ */
        }

        .hud-actions button {
            padding: 6px 8px;
            border-radius: 6px;
            border: 0;
            cursor: pointer;
            background: #2a2a2a;
            color: #fff;
        }

        .hud-actions button.primary {
            background: #3b82f6;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div id="ads"></div>
        <div id="hubmap">
            <div class="hud">
                <div class="hubup">
                    <div class="panel" id="levelPanel">
                        ë ˆë²¨: <span id="levelText">1</span>
                    </div>
                    <div class="panel items" id="itemPanel">
                        ì•„ì´í…œ:
                        <img id="itemKeyEl" src="img/item/Bread_empty.png" alt="key" width="24" height="24">
                        <img id="itemCompassEl" src="img/item/Letter_empty.png" alt="compass" width="24" height="24">
                    </div>
                </div>
                <div class="hud-actions">
                    <button id="homeBtn">í™ˆ</button>
                    <button class="primary" id="freshStartBtn">ì²˜ìŒë¶€í„° ì‹œì‘</button>
                    <button id="codexBtn">ğŸ“– ë„ê°</button>
                </div>
            </div>
            <div id="miniWrapper"><canvas id="miniMap" width="260" height="260"></canvas></div>
        </div>

        <div id="gameWrapper">
            <canvas id="game" width="480" height="480"></canvas>
        </div>

        <div id="joystickWrap">
            <div id="joystick">
                <div id="stick"></div>
            </div>
        </div>
    </div>

    <div id="overlay" class="overlay" style="display:none">
        <div class="panel" id="overlayPanel"></div>
    </div>

    <div id="codexOverlay" class="overlay" style="display:none">
        <div class="panel" id="codexPanel"></div>
    </div>

    <button id="resetSpawn" class="debug-reset">Reset Spawn Order (session)</button>

    <script>
        (function () {
            /* =========================
               1. ìƒìˆ˜ ì •ì˜
               ========================= */
            const STORAGE_KEY = 'maze_collectedStories_v1';
            const SPAWN_KEY = 'maze_spawnOrder_v1';        // sessionStorage key for spawn order array (stringified)
            const SPAWN_INDEX_KEY = 'maze_spawnIndex_v1';  // sessionStorage key for current spawn index

            // ê·¸ë£¹ ì •ì˜ (parts ìˆœì„œ ì¤‘ìš”) - fullStoryId ì¶”ê°€
            const storyGroups = [
                { id: 'siblings', label: 'ë‚¨ë§¤ (ë§ˆíŠ¸ ê¸°ë¡)', parts: ['siblings_1', 'siblings_2', 'siblings_3'], fullStoryId: 'siblings_full' },
                { id: 'maid', label: 'ê°€ì •ë¶€ (ëŒ€ì €íƒ ê¸°ë¡)', parts: ['maid_1', 'maid_2', 'maid_3'], fullStoryId: 'maid_full' },
                { id: 'traveler', label: 'ì—¬í–‰ê° (ê¸¸ ìœ„ì˜ ê¸°ë¡)', parts: ['traveler_1', 'traveler_2', 'traveler_3'], fullStoryId: 'traveler_full' },
                { id: 'sibling_younger', label: 'ë‚¨ë§¤(ë™ìƒ) (í¬ë§ ë¶•ê´´)', parts: ['sibling_younger_1', 'sibling_younger_2', 'sibling_younger_3'], fullStoryId: 'sibling_younger_full' },
                { id: 'weak_union', label: 'ì•½ì ì—°í•© (ì—¬í–‰ê°ê³¼ í•¨ê»˜í•œ ê¸°ë¡)', parts: ['weak_union_1', 'weak_union_2', 'weak_union_3'], fullStoryId: 'weak_union_full' }
            ];

            const ALL_NOTE_IDS = [].concat(...storyGroups.map(g => g.parts));
            const storySlots = storyGroups.map(g => ({ id: g.id, label: g.label }));

            const storyTexts = {
                intro: ['ê¹Šì€ ë¯¸ê¶ ì†ìœ¼ë¡œ ë°œì„ ë‚´ë”›ì—ˆë‹¤. ì–´ë‘  ì†ì—ì„œ ë¬´ì–¸ê°€ ì†ì‚­ì´ëŠ” ë“¯í•˜ë‹¤...'],
                key: ['ë‚¡ì€ ì—´ì‡ ë¥¼ ì†ì— ë„£ì—ˆë‹¤. ë…¹ìŠ¨ ê¸ˆì†ì´ ì°¨ê°‘ê²Œ ë‹¿ëŠ”ë‹¤.'],
                // (ê¸°ì¡´ compass ë³´ì¡´ - ë‚´ë¶€ ë¡œì§ì—ì„œëŠ” ì´ì œ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
                compass: [
                    ['ì„œìª½ì—ì„œ ê¸°ë¬˜í•œ ê¸°ìš´ì´ ëŠê»´ì§„ë‹¤...', 'ë‚˜ì¹¨ë°˜ì´ ê°‘ìê¸° í”ë“¤ë¦¬ë©° ë°©í–¥ì„ ìƒëŠ”ë‹¤...'],
                    ['ë©€ë¦¬ì„œ ë‚®ì€ ìš¸ìŒì†Œë¦¬ê°€ ë“¤ë ¤ì˜¨ë‹¤...', 'ë²½ì— ìƒˆê²¨ì§„ ê³ ëŒ€ ë¬¸ì–‘ì´ ëˆˆì— ë“¤ì–´ì™”ë‹¤...'],
                    ['â€˜ì¶œêµ¬ëŠ” ì—†ë‹¤â€™ëŠ” ëª©ì†Œë¦¬ê°€ ë©”ì•„ë¦¬ì³¤ë‹¤...', 'ì°¨ê°‘ê³  ìŠµí•œ ê³µê¸°ê°€ ë” ì§™ì–´ì¡Œë‹¤...']
                ],
                level1: ['ì²« ë²ˆì§¸ ë¯¸ê¶ì„ í†µê³¼í–ˆë‹¤!'],
                level2: ['ë” ê¹Šì€ ê³³ìœ¼ë¡œ ë°œê±¸ìŒì„ ì˜®ê¸´ë‹¤...'],
                ending: ['ë“œë””ì–´ ë¯¸ê¶ì—ì„œ íƒˆì¶œí–ˆë‹¤!'],

                // user notes (ìª½ì§€ íŒŒí¸)
                siblings_1: ["ì—¬ê¸°ì„œ ì‹ëŸ‰ê³¼ ì•½í’ˆì„ í™•ë³´í–ˆë‹¤.\nì²˜ìŒì—” ì‚´ì•„ë‚¨ì•˜ë‹¤ëŠ” ì•ˆë„ë¿ì´ì—ˆë‹¤."],
                siblings_2: ["ë¼ë””ì˜¤ê°€ ì¡í˜”ë‹¤.\në…¸ì´ì¦ˆ ì†ì—ì„œâ€¦ â€œìº í”„.â€\nìƒì¡´ì ìº í”„ë¼ ë“¤ë ¸ë‹¤."],
                siblings_3: ["(38.6-34.4)â€¦ ì „ë¶€ëŠ” ë²ˆì¡Œë‹¤.\nì¢Œí‘œë‹¤. ìš°ë¦¬ëŠ” ê·¸ê³³ìœ¼ë¡œ ê°„ë‹¤."],

                maid_1: ["ì €íƒì€ ì¡°ìš©í–ˆë‹¤.\nì„¸ìƒì´ ì–´ì§€ëŸ½ë‹¤ í•´ë„, ì—¬ê¸´ ë³€í•¨ì—†ì—ˆë‹¤."],
                maid_2: ["ì§‘ì‚¬ê°€ í”¼ë¥¼ í† í–ˆë‹¤.\nì‚¬ëª¨ë‹˜ì€ ë¯¸ì†Œë¥¼ ì§€ìœ¼ì…¨ë‹¤.\nê·¸ ì›ƒìŒì´â€¦ ë‘ë ¤ì› ë‹¤."],
                maid_3: ["ì¼ì£¼ì¼ì„ ë²„í…¼ë‹¤.\në”ëŠ” ëª» í•œë‹¤.\në‚˜ëŠ” ì´ê³³ì„ ë– ë‚œë‹¤."],

                traveler_1: ["ì²˜ìŒ ë³´ëŠ” ë¬´ë¦¬ì™€ í•©ë¥˜í–ˆë‹¤.\në‚¯ì„  ë‚˜ë¥¼ ë°˜ê²¨ì£¼ì–´â€¦ ë‹¤í–‰ì´ì—ˆë‹¤."],
                traveler_2: ["ê¸¸ì€ ë§‰í˜”ê³ , ìœ„í—˜ì€ ë§ì•˜ë‹¤.\ní•˜ì§€ë§Œ í˜¼ìì˜€ë‹¤ë©´ ë²Œì¨ í¬ê¸°í–ˆì„ ê²ƒì´ë‹¤."],
                traveler_3: ["ë‚´ì¼ì€ ë” ë‚˜ì•„ì§€ë¦¬ë¼ ë¯¿ëŠ”ë‹¤.\nìš°ë¦¬ê°€ ë„ì°©í•  ê³³ì€ ì—¬ê¸° ì•„ë‹ˆë‹ˆê¹Œ."],

                sibling_younger_1: ["ëˆ„ë‚˜ê°€ ê¸°ì¹¨ì„ ì‹œì‘í–ˆë‹¤.\në©€ì©¡í–ˆë˜ ì‚¬ëŒì´, ê°‘ìê¸°."],
                sibling_younger_2: ["ì—´ì€ ì˜¤ë¥´ê³ , ê¸°ì¹¨ì€ ê±°ì¹ ì–´ì¡Œë‹¤.\në‚´ ì•½ì„ ê±´ë„¸ì§€ë§Œâ€¦ ê³ ê°¤ ì €ì—ˆë‹¤."],
                sibling_younger_3: ["ëˆ„ë‚˜ëŠ” ì“°ëŸ¬ì¡Œë‹¤.\në‚˜ëŠ” ì‚´ì•„ì„œ ìº í”„ë¡œ ê°ˆê²Œ.\nì˜ ì, ëˆ„ë‚˜."],

                weak_union_1: ["ìš°ë¦° ì•½ìì˜€ë‹¤.\nê·¸ë˜ì„œ ëª¨ì˜€ë‹¤. ì„œë¡œë¥¼ ì§€í‚¤ê¸° ìœ„í•´."],
                weak_union_2: ["ë’¤ë”°ë¥´ë˜ ê·¸ë¥¼ ë°›ì•„ë“¤ì˜€ë‹¤.\në‚¯ì„¤ì—ˆì§€ë§Œ, ì ì€ ì•„ë‹ˆì—ˆë‹¤."],
                weak_union_3: ["ì•„ì¹¨, ê·¸ëŠ” ì´ë¯¸ ì‹ì–´ ìˆì—ˆë‹¤.\nì¥ë¡€ë¥¼ ì¹˜ë¥´ê³ â€¦ ë°œê±¸ìŒì„ ë–¼ì—ˆë‹¤."],

                // --- ì „ì²´ ìŠ¤í† ë¦¬ (Full Story) - ìª½ì§€ë¥¼ ëª¨ë‘ ëª¨ì•˜ì„ ë•Œ í•´ê¸ˆë˜ëŠ” ì¥ë¬¸ ìŠ¤í† ë¦¬ ---
                siblings_full: [
                    "ëˆ„ë‚˜ëŠ” ì‹ëŸ‰ê³¼ ì•½í’ˆì„ ì±™ê¸°ëŠ” ë° ëŠ¥ìˆ™í–ˆë‹¤. í™©íí•´ì§„ ë§ˆíŠ¸ì—ì„œ ì°¾ì€ ìƒì¡´ ë¬¼í’ˆì€ ì ì‹œë‚˜ë§ˆ ì•ˆë„ê°ì„ ì£¼ì—ˆë‹¤. ê·¸ëŸ¬ë‚˜ í¬ë§ì€ ë¬´ì„  í†µì‹ ì—ì„œ ì°¾ì€ 'ìº í”„'ë¼ëŠ” ë‹¨ì–´ì˜€ë‹¤. ìš°ë¦¬ëŠ” ê·¸ê³³ìœ¼ë¡œ ê°€ê¸° ìœ„í•´ ì§€ë„ì— ì¢Œí‘œë¥¼ ìƒˆê²¼ë‹¤. ì´ì œ ì´ ë¯¸ê¶ì„ ë²—ì–´ë‚˜ ê·¸ ì¢Œí‘œ(38.6-34.4)ë¡œ í–¥í•˜ëŠ” ê²ƒì´ ìš°ë¦¬ì˜ ìœ ì¼í•œ ëª©í‘œê°€ ë˜ì—ˆë‹¤. ì´ ë‚¡ì€ ê¸°ë¡ì€ ìš°ë¦¬ì˜ ì—¬ì •ì˜ ì‹œì‘ì„ ì•Œë¦°ë‹¤."
                ],
                maid_full: [
                    "ëŒ€ì €íƒì€ ì„¸ìƒì˜ í˜¼ë€ê³¼ëŠ” ë¬´ê´€í•˜ê²Œ ê³ ìš”í–ˆë‹¤. ê°€ì •ë¶€ì¸ ë‚˜ëŠ” ì´ í‰ì˜¨í•¨ì´ ê¸°ì´í•˜ê²Œ ëŠê»´ì¡Œë‹¤. ì–´ëŠ ë‚ , ì§‘ì‚¬ë‹˜ì´ í”¼ë¥¼ í† í•˜ëŠ” ëª¨ìŠµì„ ë³´ì•˜ê³ , ê·¸ë•Œ ì‚¬ëª¨ë‹˜ì˜ ì°¨ê°€ìš´ ë¯¸ì†ŒëŠ” ë‚˜ì—ê²Œ ê³µí¬ ê·¸ ìì²´ì˜€ë‹¤. ì´ ì €íƒì€ ì•ˆì „í•œ í”¼ë‚œì²˜ê°€ ì•„ë‹ˆì—ˆë‹¤. ì¼ì£¼ì¼ì„ ë²„í‹°ê³ , ë” ì´ìƒ ë²„í‹¸ ìˆ˜ ì—†ë‹¤ê³  íŒë‹¨í•œ ë‚˜ëŠ” ëª°ë˜ ì €íƒì„ ë– ë‚˜ê¸°ë¡œ ê²°ì‹¬í–ˆë‹¤. ì´ ê¸°ë¡ì€ ë‚´ê°€ íƒˆì¶œí•˜ê¸° ì§ì „ì˜ ì‹¬ì •ì„ ë‹´ê³  ìˆë‹¤."
                ],
                traveler_full: [
                    "ë‚˜ëŠ” í™€ë¡œ ë– ëŒë˜ ì—¬í–‰ê°ì´ì—ˆë‹¤. ê¸¸ ìœ„ì—ì„œ ìš°ì—°íˆ ë§Œë‚œ ë¬´ë¦¬ëŠ” ë‚¯ì„  ë‚˜ë¥¼ ì¡°ê±´ ì—†ì´ ë°›ì•„ì£¼ì—ˆê³ , ë‚˜ëŠ” ê·¸ë“¤ì˜ ë”°ëœ»í•¨ì— ê°ì‚¬í–ˆë‹¤. ë¯¸ê¶ì€ ë§‰í˜€ìˆì—ˆê³ , ê¸¸ì€ ìœ„í—˜ìœ¼ë¡œ ê°€ë“í–ˆì§€ë§Œ, í˜¼ìì˜€ë‹¤ë©´ ì´ë¯¸ ì¢Œì ˆí–ˆì„ ê²ƒì´ë‹¤. ë‚˜ëŠ” ê·¸ë“¤ê³¼ í•¨ê»˜ë¼ë©´ ë” ë‚˜ì€ ê³³ì— ë„ì°©í•  ìˆ˜ ìˆì„ ê±°ë¼ ë¯¿ì—ˆë‹¤. ë§¤ì¼ ë°¤, ìš°ë¦¬ëŠ” ë‚´ì¼ì„ ê¸°ì•½í•˜ë©° ì ë“¤ì—ˆë‹¤. ì´ ì´ì•¼ê¸°ëŠ” ë‚´ê°€ ê·¸ë“¤ê³¼ í•¨ê»˜í–ˆë˜, ì§§ê³ ë„ í¬ë§ì°¼ë˜ ê¸°ë¡ì´ë‹¤."
                ],
                sibling_younger_full: [
                    "ëˆ„ë‚˜ê°€ ê¸°ì¹¨ì„ ì‹œì‘í•œ ê±´ ê°‘ì‘ìŠ¤ëŸ¬ìš´ ì¼ì´ì—ˆë‹¤. ì²˜ìŒì—” ë‹¨ìˆœí•œ ê°ê¸°ë¼ ìƒê°í–ˆì§€ë§Œ, ê·¸ë…€ì˜ ì—´ì€ ê±·ì¡ì„ ìˆ˜ ì—†ì´ ì˜¬ëê³  ê¸°ì¹¨ì€ í‰ì¸¡í•˜ê²Œ ê±°ì¹ ì–´ì¡Œë‹¤. ë‚˜ëŠ” í•„ì‚¬ì ìœ¼ë¡œ ì•½ì„ ê±´ë„¸ì§€ë§Œ, ëˆ„ë‚˜ëŠ” ê³ ê°œë¥¼ ì €ì—ˆë‹¤. ê·¸ë…€ëŠ” ê²°êµ­ ì“°ëŸ¬ì¡Œê³ , ë‚˜ëŠ” ê·¸ë…€ë¥¼ ë‘” ì±„ ì‚´ì•„ì„œ ìº í”„ë¡œ ê°€ì•¼ë§Œ í–ˆë‹¤. ë¯¸ì•ˆí•¨ê³¼ ìŠ¬í””ì„ ë’¤ë¡œí•œ ì±„, ë‚˜ëŠ” ëˆ„ë‚˜ì—ê²Œ ë§ˆì§€ë§‰ ì‘ë³„ ì¸ì‚¬ë¥¼ ê³ í–ˆë‹¤. ì´ ê¸°ë¡ì€ í¬ë§ì´ ë¶•ê´´ëœ ìˆœê°„ì˜ ì°¸í˜¹í•œ ì¦ì–¸ì´ë‹¤."
                ],
                weak_union_full: [
                    "ìš°ë¦¬ëŠ” ì„¸ìƒì—ì„œ ê°€ì¥ ì•½í•œ ì¡´ì¬ë“¤ì´ì—ˆê¸°ì—, ì„œë¡œë¥¼ ì§€í‚¤ê¸° ìœ„í•´ ì—°í•©í–ˆë‹¤. ìš°ë¦¬ëŠ” ìƒì¡´ì´ë¼ëŠ” ê³µë™ì˜ ëª©í‘œ ì•„ë˜ ë‚¯ì„  ì´ë“¤ì„ ë°›ì•„ë“¤ì´ëŠ” ë° ì£¼ì €í•˜ì§€ ì•Šì•˜ë‹¤. ì—¬í–‰ê°ì´ ê·¸ì¤‘ í•œ ëª…ì´ì—ˆë‹¤. ê·¸ëŠ” ì¡°ìš©í–ˆì§€ë§Œ ê°•ì¸í–ˆë‹¤. ê·¸ëŸ¬ë‚˜ ìƒì¡´ì€ ì”í˜¹í–ˆë‹¤. ì–´ëŠ ì•„ì¹¨, ê·¸ëŠ” ì´ë¯¸ ì°¨ê°‘ê²Œ ì‹ì–´ ìˆì—ˆë‹¤. ìš°ë¦¬ëŠ” ê·¸ì˜ ì¥ë¡€ë¥¼ ì¹˜ë €ê³ , ìŠ¬í””ì„ ì´ê²¨ë‚´ë©° ë‹¤ì‹œ ë°œê±¸ìŒì„ ë–¼ì—ˆë‹¤. ì´ ê¸°ë¡ì€ ì•½ìë“¤ì˜ ì—°í•©ì´ ê²ªì€ ë¹„ê·¹ê³¼ ì¬ì¶œë°œì˜ ì´ì•¼ê¸°ì´ë‹¤."
                ]
            };

            /* =========================
               2. DOM & ìº”ë²„ìŠ¤ ì°¸ì¡°
               ========================= */
            const gameCanvas = document.getElementById('game');
            const ctx = gameCanvas.getContext('2d');
            const miniCanvas = document.getElementById('miniMap');
            const miniCtx = miniCanvas.getContext('2d');

            const overlay = document.getElementById('overlay');
            const overlayPanel = document.getElementById('overlayPanel');
            const codexOverlay = document.getElementById('codexOverlay');
            const codexPanel = document.getElementById('codexPanel');

            const codexBtn = document.getElementById('codexBtn');
            const homeBtn = document.getElementById('homeBtn');
            const freshStartBtn = document.getElementById('freshStartBtn');

            const levelText = document.getElementById('levelText');
            const itemKeyEl = document.getElementById('itemKeyEl');
            const itemCompassEl = document.getElementById('itemCompassEl');

            /* =========================
               3. ì „ì—­ ìƒíƒœ (STATE)
               ========================= */
            let tileSize = 30;
            let rows = 21, cols = 21;
            let maze = []; // 1=wall,0=path,2=goal
            let revealMap = [];
            let visitedMap = [];
            let items = []; // {x,y,type,collected,storyId,message}
            let level = 1;
            let player = { x: 1.5, y: 1.5, size: 0.65, vx: 0, vy: 0 };
            let speed = 4.2; // tiles/sec
            let lastTime = performance.now();
            let goal = { x: cols - 2, y: rows - 2 };
            let startTime = 0;
            let timeLimitSeconds = 90;
            let timeUp = false;
            let hasKey = false;
            // let levelCleared = false;
            // let collectedStories = {}; // keys are note ids
            // let hasNoteInCurrentLevel = false; // âš ï¸ ì¶”ê°€: í˜„ì¬ ë ˆë²¨ì—ì„œ ìª½ì§€ íšë“ ì—¬ë¶€
            // let levelCleared = false;
            // let collectedStories = {}; // keys are note ids
            // let currentLevelNoteId = null; // âš ï¸ ì¶”ê°€: í˜„ì¬ ë ˆë²¨ì— ë°°ì¹˜ëœ ìª½ì§€ ID
            let hasNoteInCurrentLevel = false;
            let levelCleared = false;
            let collectedStories = {};
            let noteIdPlaced = null; // âš ï¸ ìˆ˜ì •: í˜„ì¬ ë ˆë²¨ì— 'ë°°ì¹˜'ëœ ìª½ì§€ ID
            let tempCollectedNoteId = null; // âš ï¸ ì‹ ê·œ ì¶”ê°€: ì´ë²ˆ ë ˆë²¨ì—ì„œ 'ì„ì‹œë¡œ íšë“'í•œ ìª½ì§€ ID (ë ˆë²¨ í´ë¦¬ì–´ ì‹œì—ë§Œ ì˜êµ¬ ì €ì¥)

            /* =========================
               4. ì´ë¯¸ì§€ ë¡œë“œ
               ========================= */
            const blockImages = {};
            const itemImages = { "note": new Image(), "key": new Image() };

            itemImages["note"].src = "img/item/Letter.png";
            itemImages["key"].src = "img/item/Bread.png";

            const BLOCK_KEYS = ["1x1", "1x2", "1x3", "2x1", "3x1"];
            BLOCK_KEYS.forEach(key => blockImages[key] = new Image());


            /* =========================
               5. ì €ì¥ì†Œ ê´€ë¦¬ (Local/Session Storage)
               ========================= */
            function loadStories() {
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    collectedStories = raw ? (JSON.parse(raw) || {}) : {};
                } catch (e) {
                    console.warn('loadStories error', e);
                    collectedStories = {};
                }
            }
            function saveStories() {
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(collectedStories)); } catch (e) { console.warn('saveStories', e); }
            }

            const resetCollectedStories = () => {
                collectedStories = {};
                saveStories();
            };


            /* =========================
               6. ìœ í‹¸ë¦¬í‹° (Utils)
               ========================= */
            function inBounds(x, y) { return y >= 0 && y < maze.length && x >= 0 && x < maze[0].length; }
            function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
            function dist(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }
            function getTimeLimitForLevel(lv) {
                if (lv <= 1) return 90;
                if (lv === 2) return 120;
                if (lv === 3) return 150;
                return 150 + (lv - 3) * 30;
            }

            /* =========================
               7. HUD / UI (í† ìŠ¤íŠ¸, ì—…ë°ì´íŠ¸)
               ========================= */
            function updateHud() {
                levelText.textContent = level;

                // âš ï¸ ìˆ˜ì •: HUDëŠ” ì´ì œ í˜„ì¬ ë ˆë²¨ì˜ íšë“ ìƒíƒœë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.
                // Key ì´ë¯¸ì§€ (ë¹µ): í˜„ì¬ ë ˆë²¨ì—ì„œ íšë“í–ˆëŠ”ì§€ ì—¬ë¶€ì— ë”°ë¼ empty/full ë³€ê²½
                itemKeyEl.src = hasKey
                    ? "img/item/Bread.png"
                    : "img/item/Bread_empty.png";

                // Note ì´ë¯¸ì§€ (í¸ì§€): í˜„ì¬ ë ˆë²¨ì—ì„œ ìª½ì§€ë¥¼ íšë“í–ˆëŠ”ì§€ ì—¬ë¶€ì— ë”°ë¼ empty/full ë³€ê²½
                itemCompassEl.src = hasNoteInCurrentLevel
                    ? "img/item/Letter.png"
                    : "img/item/Letter_empty.png";
            }
            // function updateHud() {
            //     levelText.textContent = level;
            //     // Key ì´ë¯¸ì§€ (ë¹µ)
            //     itemKeyEl.src = collectedStories['key']
            //         ? "img/item/Bread.png"
            //         : "img/item/Bread_empty.png";
            //     // Note ì´ë¯¸ì§€ (í¸ì§€)
            //     const anyNote = ALL_NOTE_IDS.some(id => !!collectedStories[id]);
            //     itemCompassEl.src = anyNote
            //         ? "img/item/Letter.png"
            //         : "img/item/Letter_empty.png";
            // }

            function showToast(text, ms = 1600) {
                const t = document.createElement('div'); t.className = 'toast'; t.textContent = text;
                document.body.appendChild(t);
                setTimeout(() => { t.remove(); }, ms);
            }

            function showLoadingOverlay(message = 'ë‹¤ìŒ ë ˆë²¨ ë¡œë”© ì¤‘...') {
                overlayPanel.innerHTML = '';
                const box = document.createElement('div');
                box.className = 'loading-box';
                const spinner = document.createElement('div'); spinner.className = 'spinner';
                const msg = document.createElement('div'); msg.className = 'loading-msg'; msg.textContent = message;
                box.appendChild(spinner); box.appendChild(msg);
                overlayPanel.appendChild(box);
                overlay.style.display = 'flex';
            }
            function hideOverlay() { overlay.style.display = 'none'; overlayPanel.innerHTML = ''; }

            /* =========================
               8. ë¯¸ë¡œ ìƒì„± & ì•„ì´í…œ ë°°ì¹˜
               ========================= */
            function createEmptyMaze(w, h) {
                const m = [];
                for (let y = 0; y < h; y++) { m[y] = []; for (let x = 0; x < w; x++) m[y][x] = 1; }
                return m;
            }
            function generateMaze(w, h) {
                cols = w; rows = h;
                maze = createEmptyMaze(cols, rows);
                const stack = [];
                maze[1][1] = 0;
                stack.push({ x: 1, y: 1 });
                const deltas = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                while (stack.length) {
                    const cur = stack[stack.length - 1];
                    let neighbors = [];
                    for (const d of deltas) {
                        const nx = cur.x + d[0], ny = cur.y + d[1];
                        if (inBounds(nx, ny) && maze[ny][nx] === 1) neighbors.push(d);
                    }
                    if (neighbors.length === 0) { stack.pop(); continue; }
                    const ch = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const betweenX = cur.x + ch[0] / 2;
                    const betweenY = cur.y + ch[1] / 2;
                    const nx = cur.x + ch[0];
                    const ny = cur.y + ch[1];
                    maze[betweenY][betweenX] = 0;
                    maze[ny][nx] = 0;
                    stack.push({ x: nx, y: ny });
                }

                let possibleGoals = [];
                for (let x = 1; x < cols - 1; x++) { if (maze[1][x] === 0) possibleGoals.push({ x, y: 0 }); }
                for (let x = 1; x < cols - 1; x++) { if (maze[rows - 2][x] === 0) possibleGoals.push({ x, y: rows - 1 }); }
                for (let y = 1; y < rows - 1; y++) { if (maze[y][1] === 0) possibleGoals.push({ x: 0, y }); }
                for (let y = 1; y < rows - 1; y++) { if (maze[y][cols - 2] === 0) possibleGoals.push({ x: cols - 1, y }); }
                if (possibleGoals.length === 0) possibleGoals.push({ x: cols - 2, y: rows - 2 });
                goal = possibleGoals[Math.floor(Math.random() * possibleGoals.length)];
                maze[goal.y][goal.x] = 2;

                revealMap = Array.from({ length: rows }, () => Array(cols).fill(false));
                visitedMap = Array.from({ length: rows }, () => Array(cols).fill(false));
            }

            function findRandomPathCell(avoidNearStart = true) {
                for (let tries = 0; tries < 5000; tries++) {
                    const x = randInt(1, cols - 2);
                    const y = randInt(1, rows - 2);
                    if (maze[y][x] !== 0) continue;
                    if (avoidNearStart) {
                        if (Math.abs(x - 1) + Math.abs(y - 1) < 4) continue;
                        if (Math.abs(x - goal.x) + Math.abs(y - goal.y) < 4) continue;
                    }
                    return { x, y };
                }
                for (let y = 1; y < rows - 1; y++) for (let x = 1; x < cols - 1; x++) if (maze[y][x] === 0) return { x, y };
                return { x: 1, y: 1 };
            }

            // function placeItemsForLevel(lv) {
            //     items = [];
            //     // always place key
            //     const k = findRandomPathCell(true);
            //     items.push({ type: 'key', x: k.x, y: k.y, collected: false, storyId: 'key' });

            //     // determine note to spawn according to spawnOrder and spawnIndex
            //     const spawnOrder = ensureSpawnOrder();
            //     const spawnIndex = getSpawnIndex();
            //     let noteId = null;
            //     if (spawnIndex < spawnOrder.length) noteId = spawnOrder[spawnIndex];
            //     // fallback: pick any uncollected
            //     if (!noteId) {
            //         const uncollected = ALL_NOTE_IDS.filter(id => !collectedStories[id]);
            //         noteId = uncollected.length ? uncollected[Math.floor(Math.random() * uncollected.length)] : ALL_NOTE_IDS[Math.floor(Math.random() * ALL_NOTE_IDS.length)];
            //     }

            //     // place the note (one per level)
            //     const p = findRandomPathCell(true);
            //     items.push({ type: 'note', x: p.x, y: p.y, collected: false, storyId: noteId, message: storyTexts[noteId] || null });

            //     // advance spawn index so next level uses next slot
            //     incrementSpawnIndex();
            // }
            // function placeItemsForLevel(lv) {
            //     items = [];
            //     // í•­ìƒ í‚¤ ì•„ì´í…œ ë°°ì¹˜
            //     const k = findRandomPathCell(true);
            //     items.push({ type: 'key', x: k.x, y: k.y, collected: false, storyId: 'key' });

            //     // íšë“í•˜ì§€ ì•Šì€ ì²« ë²ˆì§¸ ìª½ì§€ë¥¼ ìˆœì„œëŒ€ë¡œ ì°¾ê¸°
            //     const spawnOrder = ensureSpawnOrder();
            //     let noteId = null;

            //     // 1. spawnOrderë¥¼ ìˆœíšŒí•˜ë©° íšë“í•˜ì§€ ì•Šì€ ì²« ìª½ì§€ IDë¥¼ ì°¾ìŒ
            //     for (const id of spawnOrder) {
            //         // idê°€ ì •ì˜ë˜ì–´ ìˆê³  (nullì´ ì•„ë‹ˆë©°) ì•„ì§ collectedStoriesì— ì—†ëŠ” ê²½ìš°
            //         if (id && !collectedStories[id]) {
            //             noteId = id;
            //             break;
            //         }
            //     }

            //     // í´ë°±: ìˆœì„œì˜ ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•˜ê±°ë‚˜, ìˆœì„œ ì™¸ì˜ ìª½ì§€ê°€ ë‚¨ì•„ìˆì„ ê²½ìš°
            //     if (!noteId) {
            //         const uncollected = ALL_NOTE_IDS.filter(id => !collectedStories[id]);
            //         // íšë“í•˜ì§€ ì•Šì€ ìª½ì§€ê°€ ìˆìœ¼ë©´ ëœë¤ìœ¼ë¡œ ë°°ì¹˜
            //         if (uncollected.length) {
            //             noteId = uncollected[Math.floor(Math.random() * uncollected.length)];
            //         } else {
            //             // ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•˜ë‹¤ë©´, ë‹¤ì‹œ ê°€ì¥ ì²« ë²ˆì§¸ ìª½ì§€ë¥¼ í‘œì‹œ (ë””ë²„ê·¸/ì¬í™•ì¸ìš©)
            //             noteId = ALL_NOTE_IDS[0];
            //         }
            //     }

            //     // ìª½ì§€ ë°°ì¹˜
            //     const p = findRandomPathCell(true);
            //     items.push({ type: 'note', x: p.x, y: p.y, collected: false, storyId: noteId, message: storyTexts[noteId] || null });

            //     // ì´ì œ session indexë¥¼ ê´€ë¦¬í•˜ëŠ” í•¨ìˆ˜ í˜¸ì¶œì´ ë¶ˆí•„ìš”í•©ë‹ˆë‹¤.
            // }
            // function placeItemsForLevel(lv) {
            //     items = [];
            //     // í•­ìƒ í‚¤ ì•„ì´í…œ ë°°ì¹˜
            //     const k = findRandomPathCell(true);
            //     items.push({ type: 'key', x: k.x, y: k.y, collected: false, storyId: 'key' });

            //     const spawnOrder = ensureSpawnOrder();
            //     let noteIdToSpawn = null;

            //     // 1. spawnOrderë¥¼ ìˆœíšŒí•˜ë©° íšë“í•˜ì§€ ì•Šì€ ì²« ìª½ì§€ IDë¥¼ ì°¾ìŒ (ìˆœì„œ ë³´ì¥)
            //     for (const id of spawnOrder) {
            //         if (id && !collectedStories[id]) {
            //             noteIdToSpawn = id;
            //             break;
            //         }
            //     }

            //     // 2. í´ë°± ë¡œì§ (ëª¨ë‘ ëª¨ì•˜ê±°ë‚˜ ìˆœì„œ ì™¸ ìª½ì§€ê°€ ë‚¨ì€ ê²½ìš°)
            //     if (!noteIdToSpawn) {
            //         const uncollected = ALL_NOTE_IDS.filter(id => !collectedStories[id]);
            //         if (uncollected.length) {
            //             noteIdToSpawn = uncollected[Math.floor(Math.random() * uncollected.length)];
            //         } else {
            //             noteIdToSpawn = ALL_NOTE_IDS[0];
            //         }
            //     }

            //     // ìª½ì§€ ë°°ì¹˜
            //     currentLevelNoteId = noteIdToSpawn; // âš ï¸ í˜„ì¬ ë ˆë²¨ ìª½ì§€ ID ê¸°ë¡
            //     const p = findRandomPathCell(true);
            //     items.push({ type: 'note', x: p.x, y: p.y, collected: false, storyId: currentLevelNoteId, message: storyTexts[currentLevelNoteId] || null });
            // }
            function placeItemsForLevel(lv) {
                items = [];
                // í•­ìƒ í‚¤ ì•„ì´í…œ ë°°ì¹˜
                const k = findRandomPathCell(true);
                items.push({ type: 'key', x: k.x, y: k.y, collected: false, storyId: 'key' });

                const spawnOrder = ensureSpawnOrder();
                let noteIdToSpawn = null;

                // íšë“í•˜ì§€ ì•Šì€ ì²« ìª½ì§€ IDë¥¼ ì°¾ìŒ (ìˆœì„œ ë³´ì¥)
                for (const id of spawnOrder) {
                    if (id && !collectedStories[id]) {
                        noteIdToSpawn = id;
                        break;
                    }
                }

                // í´ë°± ë¡œì§
                if (!noteIdToSpawn) {
                    const uncollected = ALL_NOTE_IDS.filter(id => !collectedStories[id]);
                    if (uncollected.length) {
                        noteIdToSpawn = uncollected[Math.floor(Math.random() * uncollected.length)];
                    } else {
                        noteIdToSpawn = ALL_NOTE_IDS[0];
                    }
                }

                // ìª½ì§€ ë°°ì¹˜
                noteIdPlaced = noteIdToSpawn; // âš ï¸ ë°°ì¹˜ëœ ìª½ì§€ ID ê¸°ë¡
                tempCollectedNoteId = null; // âš ï¸ ë ˆë²¨ ì‹œì‘ ì‹œ ì„ì‹œ íšë“ ID ì´ˆê¸°í™” (í•µì‹¬)
                const p = findRandomPathCell(true);
                items.push({ type: 'note', x: p.x, y: p.y, collected: false, storyId: noteIdPlaced, message: storyTexts[noteIdPlaced] || null });
            }


            /* =========================
               9. ìŠ¤í° ìˆœì„œ ê´€ë¦¬ (Session)
               ========================= */
            function buildDefaultSpawnOrder() {
                const order = new Array(15).fill(null);
                order[0] = 'siblings_1'; order[1] = 'siblings_2'; order[2] = 'siblings_3';
                order[3] = 'maid_1'; order[4] = 'maid_2'; order[5] = 'maid_3';
                order[12] = 'sibling_younger_1'; order[13] = 'sibling_younger_2'; order[14] = 'sibling_younger_3';

                const used = new Set(order.filter(Boolean));
                const remaining = ALL_NOTE_IDS.filter(id => !used.has(id));
                for (let i = remaining.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [remaining[i], remaining[j]] = [remaining[j], remaining[i]];
                }

                let idx = 0;
                for (let pos = 6; pos <= 11; pos++) {
                    order[pos] = remaining[idx++] || null;
                }
                for (let i = 0; i < order.length; i++) if (!order[i] && idx < remaining.length) order[i] = remaining[idx++];

                return order;
            }

            function ensureSpawnOrder() {
                try {
                    const raw = sessionStorage.getItem(SPAWN_KEY);
                    if (raw) {
                        const arr = JSON.parse(raw);
                        if (Array.isArray(arr) && arr.length >= 15) return arr.slice(0, 15);
                    }
                } catch (e) { /* ignore parse errors */ }

                const built = buildDefaultSpawnOrder();
                try { sessionStorage.setItem(SPAWN_KEY, JSON.stringify(built)); } catch (e) { }
                return built;
            }

            // function getSpawnIndex() {
            //     try {
            //         const raw = sessionStorage.getItem(SPAWN_INDEX_KEY);
            //         const n = raw ? parseInt(raw, 10) : 0;
            //         return Number.isFinite(n) ? Math.max(0, n) : 0;
            //     } catch (e) { return 0; }
            // }
            // function incrementSpawnIndex() {
            //     try {
            //         let n = getSpawnIndex();
            //         n = Math.min(n + 1, 1000);
            //         sessionStorage.setItem(SPAWN_INDEX_KEY, String(n));
            //     } catch (e) { }
            // }
            function resetSpawnSession() {
                try {
                    sessionStorage.removeItem(SPAWN_KEY);
                    sessionStorage.removeItem(SPAWN_INDEX_KEY);
                } catch (e) { }
            }

            /* =========================
               10. ì¶©ëŒ & ìˆ˜ì§‘ íŒì •
               ========================= */
            function canMoveToPos(x, y) {
                const half = player.size / 2;
                const corners = [
                    { x: x - half, y: y - half }, { x: x + half, y: y - half },
                    { x: x - half, y: y + half }, { x: x + half, y: y + half }
                ];
                for (const c of corners) {
                    const tx = Math.floor(c.x);
                    const ty = Math.floor(c.y);
                    if (!inBounds(tx, ty) || !maze[ty] || maze[ty][tx] === undefined || maze[ty][tx] === 1) return false;
                }
                return true;
            }

            // function tryCollectItems() {
            //     for (let i = items.length - 1; i >= 0; i--) {
            //         const it = items[i];
            //         if (!it) continue;
            //         const d = dist(player.x, player.y, it.x + 0.5, it.y + 0.5);
            //         if (d < 0.8) {
            //             it.collected = true;
            //             items.splice(i, 1);
            //             if (it.type === 'key') {
            //                 hasKey = true;
            //                 unlockNote('key');
            //                 showStoryOverlay('ì—´ì‡  íšë“', storyTexts.key[0], 2000);
            //             } else if (it.type === 'note') {
            //                 const nid = it.storyId;
            //                 unlockNote(nid);
            //                 const content = collectedStories[nid] && collectedStories[nid].text ? collectedStories[nid].text : storyTexts[nid];
            //                 showStoryOverlay('ìª½ì§€', content, 0);
            //             } else {
            //                 if (it.storyId) { unlockNote(it.storyId); showStoryOverlay('ìª½ì§€', storyTexts[it.storyId] || it.message || '(ë‚´ìš© ì—†ìŒ)', 0); }
            //                 else showToast('ì•„ì´í…œ íšë“');
            //             }
            //             updateHud();
            //         }
            //     }
            // }
            // function tryCollectItems() {
            //     for (let i = items.length - 1; i >= 0; i--) {
            //         const it = items[i];
            //         if (!it) continue;
            //         const d = dist(player.x, player.y, it.x + 0.5, it.y + 0.5);
            //         if (d < 0.8) {
            //             it.collected = true;
            //             items.splice(i, 1);
            //             if (it.type === 'key') {
            //                 hasKey = true;
            //                 unlockNote('key');
            //                 showStoryOverlay('ì—´ì‡  íšë“', storyTexts.key[0], 2000);
            //             } else if (it.type === 'note') {
            //                 const nid = it.storyId;
            //                 unlockNote(nid);
            //                 hasNoteInCurrentLevel = true; // âš ï¸ í˜„ì¬ ë ˆë²¨ ìª½ì§€ íšë“ ìƒíƒœ ê°±ì‹ 
            //                 const content = collectedStories[nid] && collectedStories[nid].text ? collectedStories[nid].text : storyTexts[nid];
            //                 showStoryOverlay('ìª½ì§€', content, 0);
            //             } else {
            //                 if (it.storyId) {
            //                     unlockNote(it.storyId);
            //                     hasNoteInCurrentLevel = true; // âš ï¸ í˜„ì¬ ë ˆë²¨ ìª½ì§€ íšë“ ìƒíƒœ ê°±ì‹ 
            //                     showStoryOverlay('ìª½ì§€', storyTexts[it.storyId] || it.message || '(ë‚´ìš© ì—†ìŒ)', 0);
            //                 }
            //                 else showToast('ì•„ì´í…œ íšë“');
            //             }
            //             updateHud();
            //         }
            //     }
            // }
            function tryCollectItems() {
                for (let i = items.length - 1; i >= 0; i--) {
                    const it = items[i];
                    if (!it) continue;
                    const d = dist(player.x, player.y, it.x + 0.5, it.y + 0.5);
                    if (d < 0.8) {
                        it.collected = true;
                        items.splice(i, 1);
                        if (it.type === 'key') {
                            hasKey = true;
                            unlockNote('key'); // í‚¤ëŠ” ì¦‰ì‹œ ì˜êµ¬ ì €ì¥ ìœ ì§€
                            showStoryOverlay('ì—´ì‡  íšë“', storyTexts.key[0], 2000);
                        } else if (it.type === 'note') {
                            const nid = it.storyId;
                            // unlockNote(nid); // âš ï¸ ì˜êµ¬ ì €ì¥ ë¡œì§ ì œê±°!
                            tempCollectedNoteId = nid; // âš ï¸ ìª½ì§€ IDë¥¼ ì„ì‹œ ì €ì¥
                            hasNoteInCurrentLevel = true;
                            const content = collectedStories[nid] && collectedStories[nid].text ? collectedStories[nid].text : storyTexts[nid];
                            showStoryOverlay('ìª½ì§€', content, 0);
                        } else {
                            if (it.storyId) {
                                // ... (other item logic)
                            }
                            else showToast('ì•„ì´í…œ íšë“');
                        }
                        updateHud();
                    }
                }
            }

            /* =========================
             11. ëª©í‘œ ë„ë‹¬ í™•ì¸ (Check Goal)
             ========================= */
            function checkGoal() {
                const px = Math.floor(player.x);
                const py = Math.floor(player.y);

                // ëª©í‘œ ì§€ì  (Exit)ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸
                // ê¸°ì¡´ ëª©í‘œ ì§€ì  í™•ì¸ ë¡œì§ (ê±°ë¦¬ ê¸°ë°˜ d < 0.8) ëŒ€ì‹  íƒ€ì¼ ì¢Œí‘œ ê¸°ë°˜ ë¡œì§ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ í†µì¼ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.
                // ë‹¤ë§Œ, ì œê³µí•˜ì‹  ì½”ë“œì—ëŠ” distë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, ê·¸ëŒ€ë¡œ dist ë¡œì§ì„ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤.

                const d = dist(player.x, player.y, goal.x + 0.5, goal.y + 0.5);

                if (d < 0.8 && !levelCleared) {
                    if (hasKey) {
                        // âš ï¸ ê¸°ì¡´ ë ˆë²¨ í´ë¦¬ì–´ ë¡œì§ì„ ì‹ ê·œ í•¨ìˆ˜ í˜¸ì¶œë¡œ ëŒ€ì²´ (ìª½ì§€ ì €ì¥ ë²„ê·¸ í•´ê²° í•µì‹¬)
                        completeLevelAndProgress();
                        // completeLevelAndProgress í•¨ìˆ˜ ë‚´ì—ì„œ levelCleared = true ì„¤ì • ë° ë‹¤ìŒ ë ˆë²¨ ë¡œë”©ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
                    } else {
                        showToast("ì•„ì´í…œì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ë¬¼ìë¥¼ ëª¨ì•„ì•¼ í•©ë‹ˆë‹¤.", 1800);
                    }
                }
            }
            // function checkGoal() {
            //     const d = dist(player.x, player.y, goal.x + 0.5, goal.y + 0.5);
            //     if (d < 0.8 && !levelCleared) {
            //         if (hasKey) {
            //             levelCleared = true;
            //             const nextLevel = level + 1; const MAX_LEVEL = 15;
            //             if (level >= MAX_LEVEL) {
            //                 showLoadingOverlay('ì—”ë”©ì„ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤...');
            //                 setTimeout(() => {
            //                     hideOverlay();
            //                     unlockNote('ending');
            //                     showStoryOverlay('ì—”ë”©', storyTexts.ending[0], 0);
            //                 }, 800);
            //                 return;
            //             }
            //             showLoadingOverlay(`ë ˆë²¨ ${nextLevel} ë¡œë”© ì¤‘...`);
            //             setTimeout(() => {
            //                 level = nextLevel;
            //                 startLevel(level);
            //                 hideOverlay();
            //                 levelCleared = false;
            //                 lastTime = performance.now();
            //             }, 700);
            //         } else {
            //             showToast("ì•„ì´í…œì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ë¬¼ìë¥¼ ëª¨ì•„ì•¼ í•©ë‹ˆë‹¤.", 1800);
            //         }
            //     }
            // }

            /* =========================
               11. ì‹œì•¼ & ë¯¸ë‹ˆë§µ
               ========================= */
            let revealRadius = 3;
            function revealAround(px, py) {
                const cx = Math.floor(px), cy = Math.floor(py);
                for (let dy = -revealRadius; dy <= revealRadius; dy++) {
                    for (let dx = -revealRadius; dx <= revealRadius; dx++) {
                        const x = cx + dx, y = cy + dy;
                        if (inBounds(x, y)) revealMap[y][x] = true;
                    }
                }
                if (inBounds(cx, cy) && maze[cy][cx] === 0) visitedMap[cy][cx] = true;
            }

            function drawMiniMap() {
                const w = miniCanvas.width, h = miniCanvas.height;
                miniCtx.clearRect(0, 0, w, h);
                const cellW = w / cols, cellH = h / rows;

                miniCtx.fillStyle = '#030303'; miniCtx.fillRect(0, 0, w, h);

                for (let y = 0; y < rows; y++) {
                    if (!visitedMap[y] || !maze[y]) continue;
                    for (let x = 0; x < cols; x++) {
                        if (visitedMap[y][x] && maze[y][x] === 0) {
                            miniCtx.fillStyle = '#bfbfbf';
                            miniCtx.fillRect(x * cellW, y * cellH, cellW, cellH);
                        }
                    }
                }
                // Goal
                miniCtx.fillStyle = '#2ecc71'; miniCtx.fillRect(goal.x * cellW + cellW * 0.15, goal.y * cellH + cellH * 0.15, cellW * 0.7, cellH * 0.7);
                // Items
                for (const it of items) {
                    if (visitedMap[it.y] && visitedMap[it.y][it.x]) {
                        miniCtx.beginPath();
                        miniCtx.fillStyle = (it.type === 'key') ? '#ffcc00' : '#7f5cff';
                        miniCtx.arc((it.x + 0.5) * cellW, (it.y + 0.5) * cellH, Math.min(cellW, cellH) * 0.25, 0, Math.PI * 2);
                        miniCtx.fill();
                    }
                }
                // Player
                miniCtx.fillStyle = '#ff4b4b';
                miniCtx.beginPath();
                miniCtx.arc((player.x) * cellW, (player.y) * cellH, Math.min(cellW, cellH) * 0.32, 0, Math.PI * 2);
                miniCtx.fill();
            }

            /* =========================
               12. ë„ê° / ìŠ¤í† ë¦¬
               ========================= */
            function unlockNote(id) {
                if (!collectedStories[id]) {
                    const txt = storyTexts[id] || '(ê¸°ë¡ ì—†ìŒ)';
                    collectedStories[id] = { unlocked: true, text: txt };
                    saveStories();
                }
            }
            function showStoryOverlay(title, text, autoCloseMs = 3000) {
                overlayPanel.innerHTML = '';
                const h = document.createElement('h3'); h.style.margin = '0 0 6px'; h.textContent = title || 'ìƒì„¸';
                overlayPanel.appendChild(h);
                let content = Array.isArray(text) ? text.join('\n\n') : String(text || '');
                if (content) {
                    const p = document.createElement('pre'); p.className = 'story'; p.textContent = content;
                    overlayPanel.appendChild(p);
                }
                const actions = document.createElement('div'); actions.className = 'actions';
                const closeBtn = document.createElement('button'); closeBtn.className = 'primary'; closeBtn.textContent = 'ë‹«ê¸°';
                closeBtn.onclick = () => { overlay.style.display = 'none'; };
                actions.appendChild(closeBtn);
                overlayPanel.appendChild(actions);
                overlay.style.display = 'flex';
                if (autoCloseMs && autoCloseMs > 0) {
                    setTimeout(() => { if (overlay.style.display === 'flex') overlay.style.display = 'none'; }, autoCloseMs);
                }
            }
            /* =========================
               ê·¸ë£¹ ë·° (íšë“ëœ ìª½ì§€ í•©ì³ì„œ ë³´ê¸°)
               ========================= */

            // ìª½ì§€ ì „ì²´ íšë“ ì‹œ ì™„ì„±ëœ ìŠ¤í† ë¦¬ í‘œì‹œ ë¡œì§ (ìˆ˜ì • ë° ì „ì²´ ìŠ¤í† ë¦¬ ë³´ê¸° ë²„íŠ¼ ì¶”ê°€)
            function showGroupOverlay(group) {
                const parts = group.parts;
                const collectedParts = parts.filter(pid => !!collectedStories[pid]);
                const collectedCount = collectedParts.length;
                const total = parts.length;
                const gotAll = collectedCount === total;
                const fullStoryId = group.fullStoryId;
                const fullStoryText = fullStoryId ? storyTexts[fullStoryId] : null; // ì¥ë¬¸ ìŠ¤í† ë¦¬ í…ìŠ¤íŠ¸

                if (collectedCount === 0) {
                    showToast('íšë“í•œ ìª½ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                let storyContentHtml = '';

                if (gotAll) {
                    // ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•˜ì„ ê²½ìš°, í•©ì³ì§„ ìŠ¤í† ë¦¬ ì™„ì„± (ì‚¬ìš©ì ìš”ì²­ í¬ë§· ì ìš©)
                    storyContentHtml += '<div style="margin-bottom: 15px; font-weight: bold; color: #ffeb3b;">ìŠ¤í† ë¦¬ ì™„ì„±!</div>';
                    parts.forEach((pid, index) => {
                        const txt = collectedStories[pid].text || storyTexts[pid];
                        let content = Array.isArray(txt) ? txt.join('\n\n') : String(txt || '');
                        // title formatting: siblings_1 -> Siblings 1
                        const titleParts = pid.split('_');
                        const title = titleParts.map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');

                        storyContentHtml += `<div style="font-size: 1.1em; margin-bottom: 4px; color: #9be6ff;">-- Part ${index + 1}: ${title} --</div>`;
                        storyContentHtml += `<pre class="story">${content}</pre>`;
                    });
                } else {
                    // ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ìœ¼ì§€ ëª»í–ˆì„ ê²½ìš°, íšë“í•œ ìª½ì§€ë§Œ ë³´ì—¬ì¤Œ
                    storyContentHtml += '<div style="margin-bottom: 10px; opacity: 0.8;">(ì¼ë¶€ íšë“)</div>';
                    collectedParts.forEach((pid, index) => {
                        const txt = collectedStories[pid].text || storyTexts[pid];
                        let content = Array.isArray(txt) ? txt.join('\n\n') : String(txt || '');
                        const titleParts = pid.split('_');
                        const title = titleParts.map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                        storyContentHtml += `<div style="font-size: 1.1em; margin-bottom: 4px; color: #9be6ff;">-- Part ${index + 1}: ${title} --</div>`;
                        storyContentHtml += `<pre class="story">${content}</pre>`;
                    });
                }

                overlayPanel.innerHTML = '';
                const h = document.createElement('h3'); h.style.margin = '0 0 8px'; h.textContent = group.label;
                overlayPanel.appendChild(h);

                const noteContainer = document.createElement('div');
                noteContainer.innerHTML = storyContentHtml;
                overlayPanel.appendChild(noteContainer);

                // === ì „ì²´ ìŠ¤í† ë¦¬ ë³´ê¸° ë²„íŠ¼ ì¶”ê°€ ===
                if (gotAll && fullStoryText) {
                    const fullStoryBtn = document.createElement('button');
                    fullStoryBtn.className = 'primary';
                    fullStoryBtn.textContent = 'ğŸ“– ì „ì²´ ìŠ¤í† ë¦¬ ë³´ê¸°';
                    fullStoryBtn.style.marginTop = '15px';
                    fullStoryBtn.style.marginBottom = '8px';
                    fullStoryBtn.style.width = '100%';
                    fullStoryBtn.onclick = () => {
                        // í˜„ì¬ ì˜¤ë²„ë ˆì´ ë‹«ê³ , ì „ì²´ ìŠ¤í† ë¦¬ ì˜¤ë²„ë ˆì´ ì—´ê¸°
                        overlay.style.display = 'none';
                        // showStoryOverlayë¥¼ ì´ìš©í•´ ì¥ë¬¸ì˜ ì „ì²´ ìŠ¤í† ë¦¬ë¥¼ í‘œì‹œ
                        showStoryOverlay(`[${group.label}] - ì „ì²´ ìŠ¤í† ë¦¬`, fullStoryText, 0);
                    };
                    overlayPanel.appendChild(fullStoryBtn);
                }
                // ==============================

                const hint = document.createElement('p'); hint.style.opacity = '0.9'; hint.style.marginTop = '8px';
                hint.textContent = gotAll
                    ? `ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•˜ìŠµë‹ˆë‹¤. ì™„ì„±ëœ ìŠ¤í† ë¦¬ê°€ í•´ê¸ˆë˜ì—ˆìŠµë‹ˆë‹¤.`
                    : `ëª¨ì€ ìª½ì§€: ${collectedCount}/${total}. ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•„ì•¼ ì™„ì„±ëœ ìŠ¤í† ë¦¬ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
                overlayPanel.appendChild(hint);

                const actions = document.createElement('div'); actions.className = 'actions';
                // ë‹«ê¸° ë²„íŠ¼ì€ ë³´ì¡° ìƒ‰ìƒ(ghost)ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ì „ì²´ ìŠ¤í† ë¦¬ ë³´ê¸° ë²„íŠ¼ì„ ê°•ì¡°
                const closeBtn = document.createElement('button'); closeBtn.className = 'ghost'; closeBtn.textContent = 'ë‹«ê¸°';
                closeBtn.onclick = () => { overlay.style.display = 'none'; };
                actions.appendChild(closeBtn);
                overlayPanel.appendChild(actions);
                overlay.style.display = 'flex';
            }
            // function showGroupOverlay(group) {
            //     const parts = group.parts;
            //     const collectedParts = parts.filter(pid => !!collectedStories[pid]);
            //     const collectedCount = collectedParts.length;
            //     const total = parts.length;
            //     const gotAll = collectedCount === total;

            //     if (collectedCount === 0) {
            //         showToast('íšë“í•œ ìª½ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
            //         return;
            //     }

            //     let combined = [];
            //     let storyContentHtml = '';

            //     // ìš”ì²­ 1. ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•˜ì„ ê²½ìš°, í•©ì³ì§„ ìŠ¤í† ë¦¬ ì™„ì„±
            //     if (gotAll) {
            //         combined = parts.map(pid => storyTexts[pid] || '');
            //         storyContentHtml += '<div style="margin-bottom: 15px; font-weight: bold; color: #ffeb3b;">ìŠ¤í† ë¦¬ ì™„ì„±!</div>';
            //         combined.flat().forEach((para, index) => {
            //             const title = parts[index].split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
            //             storyContentHtml += `<div style="font-size: 1.1em; margin-bottom: 4px; color: #9be6ff;">-- Part ${index + 1}: ${title} --</div>`;
            //             storyContentHtml += `<pre class="story">${para}</pre>`;
            //         });
            //     } else {
            //         // ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ìœ¼ì§€ ëª»í–ˆì„ ê²½ìš°, íšë“í•œ ìª½ì§€ë§Œ ë³´ì—¬ì¤Œ
            //         storyContentHtml += '<div style="margin-bottom: 10px; opacity: 0.8;">(ì¼ë¶€ íšë“)</div>';
            //         collectedParts.forEach((pid) => {
            //             const txt = collectedStories[pid].text || storyTexts[pid];
            //             let content = Array.isArray(txt) ? txt.join('\n\n') : String(txt || '');
            //             const titlePart = pid.split('_').pop();
            //             storyContentHtml += `<div style="font-size: 1.1em; margin-bottom: 4px; color: #9be6ff;">-- Part: ${titlePart} --</div>`;
            //             storyContentHtml += `<pre class="story">${content}</pre>`;
            //         });
            //     }

            //     overlayPanel.innerHTML = '';
            //     const h = document.createElement('h3'); h.style.margin = '0 0 8px'; h.textContent = group.label;
            //     overlayPanel.appendChild(h);

            //     const noteContainer = document.createElement('div');
            //     noteContainer.innerHTML = storyContentHtml;
            //     overlayPanel.appendChild(noteContainer);

            //     const hint = document.createElement('p'); hint.style.opacity = '0.9'; hint.style.marginTop = '8px';
            //     hint.textContent = gotAll ? `ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•˜ìŠµë‹ˆë‹¤. ì™„ì„±ëœ ìŠ¤í† ë¦¬ê°€ í•´ê¸ˆë˜ì—ˆìŠµë‹ˆë‹¤.` : `ëª¨ì€ ìª½ì§€: ${collectedCount}/${total}. ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•„ì•¼ ì™„ì„±ëœ ìŠ¤í† ë¦¬ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
            //     overlayPanel.appendChild(hint);

            //     const actions = document.createElement('div'); actions.className = 'actions';
            //     const closeBtn = document.createElement('button'); closeBtn.className = 'primary'; closeBtn.textContent = 'ë‹«ê¸°';
            //     closeBtn.onclick = () => { overlay.style.display = 'none'; };
            //     actions.appendChild(closeBtn);
            //     overlayPanel.appendChild(actions);
            //     overlay.style.display = 'flex';
            // }

            // function showGroupOverlay(group) {
            //     const parts = group.parts;
            //     const collectedParts = parts.filter(pid => !!collectedStories[pid]);
            //     if (collectedParts.length === 0) {
            //         showToast('íšë“í•œ ìª½ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
            //         return;
            //     }

            //     let combined = [];
            //     for (const pid of parts) {
            //         if (collectedStories[pid]) {
            //             const t = collectedStories[pid].text || storyTexts[pid] || '';
            //             if (Array.isArray(t)) combined = combined.concat(t);
            //             else combined.push(String(t));
            //         }
            //     }

            //     const gotAll = collectedParts.length === parts.length;
            //     overlayPanel.innerHTML = '';
            //     const h = document.createElement('h3'); h.style.margin = '0 0 8px'; h.textContent = group.label;
            //     overlayPanel.appendChild(h);

            //     const noteContainer = document.createElement('div');
            //     combined.forEach((para) => {
            //         const p = document.createElement('pre'); p.className = 'story'; p.textContent = para;
            //         noteContainer.appendChild(p);
            //     });
            //     overlayPanel.appendChild(noteContainer);

            //     const hint = document.createElement('p'); hint.style.opacity = '0.9'; hint.style.marginTop = '8px';
            //     hint.textContent = gotAll ? `ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•˜ìŠµë‹ˆë‹¤. ì „ì²´ ìŠ¤í† ë¦¬ê°€ í•´ê¸ˆë˜ì—ˆìŠµë‹ˆë‹¤.` : `ëª¨ì€ ìª½ì§€: ${collectedParts.length}/${parts.length}. ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ìœ¼ë©´ ê´€ë ¨ ìŠ¤í† ë¦¬ê°€ ì™„ì „íˆ í•´ê¸ˆë©ë‹ˆë‹¤.`;
            //     overlayPanel.appendChild(hint);

            //     const actions = document.createElement('div'); actions.className = 'actions';
            //     const closeBtn = document.createElement('button'); closeBtn.className = 'primary'; closeBtn.textContent = 'ë‹«ê¸°';
            //     closeBtn.onclick = () => { overlay.style.display = 'none'; };
            //     actions.appendChild(closeBtn);
            //     overlayPanel.appendChild(actions);
            //     overlay.style.display = 'flex';
            // }

            function openCodex() {
                codexPanel.innerHTML = '<h3 style="margin-top:0">ìŠ¤í† ë¦¬ ë„ê°</h3>';
                storyGroups.forEach(g => {
                    const parts = g.parts;
                    const collectedCount = parts.filter(pid => !!collectedStories[pid]).length;
                    const total = parts.length;
                    const row = document.createElement('div'); row.className = 'group';
                    const meta = document.createElement('div'); meta.className = 'meta';
                    const title = document.createElement('div'); title.className = 'title'; title.textContent = g.label;
                    const count = document.createElement('div'); count.className = 'count'; count.textContent = `${collectedCount}/${total}`;
                    meta.appendChild(title); meta.appendChild(count);
                    row.appendChild(meta);

                    const preview = document.createElement('div'); preview.style.marginTop = '6px'; preview.style.opacity = '0.9';
                    if (collectedCount === 0) {
                        preview.textContent = 'ì ê¸ˆ â€” ì•„ì§ íšë“í•œ ìª½ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.';
                    } else {
                        const firstCollectedId = parts.find(pid => !!collectedStories[pid]);
                        let excerpt = '';
                        const txt = (collectedStories[firstCollectedId] && collectedStories[firstCollectedId].text) || storyTexts[firstCollectedId];
                        if (Array.isArray(txt)) excerpt = txt[0].slice(0, 80) + (txt[0].length > 80 ? '...' : '');
                        else excerpt = String(txt).slice(0, 80) + (String(txt).length > 80 ? '...' : '');
                        preview.textContent = excerpt;
                    }
                    row.appendChild(preview);

                    row.onclick = () => {
                        const collectedCountNow = parts.filter(pid => !!collectedStories[pid]).length;
                        if (collectedCountNow === 0) {
                            showToast('íšë“í•œ ìª½ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                            return;
                        }
                        showGroupOverlay(g);
                        codexOverlay.style.display = 'none';
                    };

                    codexPanel.appendChild(row);
                });

                const close = document.createElement('div');
                close.style.marginTop = '8px';
                close.innerHTML = `<div style="text-align:right"><button class="primary" id="codexClose">ë‹«ê¸°</button></div>`;
                codexPanel.appendChild(close);
                codexOverlay.style.display = 'flex';
                document.getElementById('codexClose').onclick = () => { codexOverlay.style.display = 'none'; };
            }

            /* =========================
               13. ë Œë”ë§ (Draw)
               ========================= */
            function drawTimer(ctx, rem) {
                const sec = Math.floor(rem);
                const mm = Math.floor(sec / 60);
                const ss = sec % 60;
                const text = `${mm}:${String(ss).padStart(2, '0')}`;
                ctx.save();
                ctx.font = '18px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillStyle = rem <= 10 ? 'tomato' : '#fff';
                ctx.fillText(`ì‹œê°„: ${text}`, 12, 14);
                ctx.restore();
            }

            function drawUrgency(nowTs, rem) {
                if (rem > 20) return;
                const p = Math.max(0, Math.min(1, rem / 20));
                const startR = Math.max(gameCanvas.width, gameCanvas.height) * 0.9;
                const endR = Math.max(48, Math.min(gameCanvas.width, gameCanvas.height) * 0.12);
                const radius = endR + (startR - endR) * p;
                const pulseSpeed = 6 + (1 - p) * 18;
                const pulseAmount = 1 + 0.06 * (1 - p) * Math.sin(nowTs / 1000 * pulseSpeed);
                const drawR = radius * pulseAmount;
                ctx.save();
                ctx.fillStyle = `rgba(120,10,10,${0.22 + (1 - p) * 0.28})`;
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                const cx = gameCanvas.width / 2;
                const cy = gameCanvas.height / 2;
                ctx.arc(cx, cy, drawR, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
                const strokeAlpha = Math.min(1, 0.8 - p * 0.5 + (1 - p) * 0.2);
                ctx.beginPath();
                ctx.arc(cx, cy, drawR, 0, Math.PI * 2);
                ctx.lineWidth = Math.max(3, (1 - p) * 18);
                ctx.strokeStyle = `rgba(255,80,80,${strokeAlpha})`;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy, drawR - (ctx.lineWidth * 0.6), 0, Math.PI * 2);
                ctx.lineWidth = 1.2;
                ctx.strokeStyle = `rgba(255,200,200,${0.18 + (1 - p) * 0.25})`;
                ctx.stroke();
                ctx.restore();
            }

            function draw(nowTs) {
                ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                const offsetX = gameCanvas.width / 2 - player.x * tileSize;
                const offsetY = gameCanvas.height / 2 - player.y * tileSize;
                const visited = Array.from({ length: rows }, () => Array(cols).fill(false));

                for (let y = 0; y < rows; y++) {
                    if (!maze[y]) continue;
                    for (let x = 0; x < cols; x++) {
                        if (maze[y][x] === undefined) continue;
                        if (maze[y][x] === 1 && !visited[y][x]) {
                            // Optimized wall rendering
                            let lenX = 1; while (x + lenX < cols && lenX < 3 && maze[y][x + lenX] === 1 && !visited[y][x + lenX]) lenX++;
                            if (lenX > 1) {
                                const img = blockImages[`1x${lenX}`] || blockImages["1x1"];
                                ctx.drawImage(img, x * tileSize + offsetX, y * tileSize + offsetY, tileSize * lenX, tileSize);
                                for (let i = 0; i < lenX; i++) visited[y][x + i] = true;
                                continue;
                            }

                            let lenY = 1; while (y + lenY < rows && lenY < 3 && maze[y + lenY] && maze[y + lenY][x] === 1 && !visited[y + lenY][x]) lenY++;
                            if (lenY > 1) {
                                const img = blockImages[`${lenY}x1`] || blockImages["1x1"];
                                ctx.drawImage(img, x * tileSize + offsetX, y * tileSize + offsetY, tileSize, tileSize * lenY);
                                for (let i = 0; i < lenY; i++) visited[y + i][x] = true;
                                continue;
                            }

                            ctx.drawImage(blockImages["1x1"], x * tileSize + offsetX, y * tileSize + offsetY, tileSize, tileSize);
                            visited[y][x] = true;
                        } else if (maze[y][x] === 0) {
                            ctx.fillStyle = "white";
                            ctx.fillRect(x * tileSize + offsetX, y * tileSize + offsetY, tileSize, tileSize);
                        }
                    }
                }

                // Goal
                ctx.fillStyle = "green";
                ctx.fillRect(goal.x * tileSize + offsetX, goal.y * tileSize + offsetY, tileSize, tileSize);

                // Items
                for (const it of items) {
                    const img = itemImages[it.type];
                    const size = tileSize * 0.8;
                    const px = it.x * tileSize + tileSize / 2 - size / 2 + offsetX;
                    const py = it.y * tileSize + tileSize / 2 - size / 2 + offsetY;
                    if (img) ctx.drawImage(img, px, py, size, size);
                }

                // Player
                const psize = tileSize * player.size;
                ctx.fillStyle = "red";
                ctx.fillRect(gameCanvas.width / 2 - psize / 2, gameCanvas.height / 2 - psize / 2, psize, psize);

                const rem = getRemainingSeconds();
                drawTimer(ctx, rem);
                drawUrgency(nowTs, rem);
            }

            /* =========================
               14. ì‹œê°„/ê²Œì„ì˜¤ë²„
               ========================= */
            function getRemainingSeconds() {
                if (!startTime) return timeLimitSeconds;
                const elapsed = (Date.now() - startTime) / 1000;
                return Math.max(0, timeLimitSeconds - elapsed);
            }
            function handleTimeUp() {
                if (timeUp) return;
                timeUp = true;
                const elapsedTotal = ((Date.now() - startTime) / 1000).toFixed(1);
                showGameOverOverlay({ title: 'ì‹œê°„ ì´ˆê³¼!', message: `í”Œë ˆì´íƒ€ì„: ${elapsedTotal}ì´ˆ\në ˆë²¨ì„ ë‹¤ì‹œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?` });
            }
            function showGameOverOverlay({ title = 'ê²Œì„ ì˜¤ë²„', message = '' } = {}) {
                overlayPanel.innerHTML = '';
                const panel = document.createElement('div'); panel.className = 'panel';
                const h3 = document.createElement('h3'); h3.textContent = title; panel.appendChild(h3);
                if (message) { const p = document.createElement('p'); p.innerText = message; panel.appendChild(p); }
                const actions = document.createElement('div'); actions.className = 'actions';
                const restartBtn = document.createElement('button'); restartBtn.className = 'primary'; restartBtn.textContent = 'ë‹¤ì‹œ ì‹œì‘';
                restartBtn.onclick = () => { overlay.style.display = 'none'; timeUp = false; startLevel(level); requestAnimationFrame(update); };
                actions.appendChild(restartBtn);
                const exitBtn = document.createElement('button'); exitBtn.className = 'ghost'; exitBtn.style.marginLeft = '8px'; exitBtn.textContent = 'ì¢…ë£Œ';
                exitBtn.onclick = () => { overlay.style.display = 'none'; timeUp = false; if (typeof showIntroStart === 'function') showIntroStart(); };
                actions.appendChild(exitBtn);
                panel.appendChild(actions);
                overlayPanel.appendChild(panel);
                overlay.style.display = 'flex';
            }
            function checkTimeout() { if (timeUp) return; const rem = getRemainingSeconds(); if (rem <= 0) handleTimeUp(); }

            /* =========================
               15. ë©”ì¸ ë£¨í”„ (Update)
               ========================= */
            const keys = {};
            function update(now) {
                try {
                    const dt = Math.min(0.05, (now - lastTime) / 1000);
                    lastTime = now;

                    // 1. ì…ë ¥ ì²˜ë¦¬ (í‚¤ë³´ë“œ)
                    if (!joyActive) {
                        let ix = 0, iy = 0;
                        if (keys['arrowup'] || keys['w']) iy -= 1;
                        if (keys['arrowdown'] || keys['s']) iy += 1;
                        if (keys['arrowleft'] || keys['a']) ix -= 1;
                        if (keys['arrowright'] || keys['d']) ix += 1;
                        if (ix !== 0 || iy !== 0) {
                            const len = Math.hypot(ix, iy) || 1;
                            player.vx = (ix / len) * speed;
                            player.vy = (iy / len) * speed;
                        } else { player.vx = 0; player.vy = 0; }
                    }

                    // 2. ì´ë™ ë° ì¶©ëŒ
                    let nextX = player.x + player.vx * dt;
                    let nextY = player.y + player.vy * dt;

                    if (canMoveToPos(nextX, player.y)) { player.x = nextX; } else { player.vx = 0; }
                    if (canMoveToPos(player.x, nextY)) { player.y = nextY; } else { player.vy = 0; }

                    // 3. ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
                    checkTimeout();
                    revealAround(player.x, player.y);
                    tryCollectItems();
                    checkGoal();

                    // 4. ë Œë”ë§
                    draw(now);
                    drawMiniMap();

                    requestAnimationFrame(update);
                } catch (err) {
                    console.error('ê²Œì„ ë£¨í”„ ì—ëŸ¬:', err);
                    lastTime = performance.now();
                    requestAnimationFrame(update);
                }
            }

            // 
            /* =========================
              16. ë ˆë²¨ ì‹œì‘ & ì¸íŠ¸ë¡œ
              ========================= */
            function startLevel(lv) {
                // âš ï¸ í˜„ì¬ ë ˆë²¨ ì•„ì´í…œ íšë“ ìƒíƒœ ì´ˆê¸°í™”
                hasKey = false;
                hasNoteInCurrentLevel = false;

                const PATHS = {
                    ROAD: "img/c/tiles_road/",
                    MART: "img/c/tiles_mart/",
                    MANSION: "img/c/tiles_mansion/",
                    RUINS: "img/c/tiles_ruins/",
                    OUTSIDE: "img/c/tiles_outside/"
                };

                // ë ˆë²¨ ìˆœì„œ ì •ì˜ (Level 1ë¶€í„° ì‹œì‘)
                const TILE_SET_SEQUENCE = [
                    null,          // ë ˆë²¨ 0 (ë¯¸ì‚¬ìš©)
                    PATHS.ROAD,    // 1: road
                    PATHS.MART,    // 2: mart
                    PATHS.ROAD,    // 3: road
                    PATHS.MANSION, // 4: house (mansion)
                    PATHS.ROAD,    // 5: road
                    PATHS.RUINS,   // 6: forest (ruins)
                    PATHS.RUINS,   // 7: forest
                    PATHS.RUINS,   // 8: forest
                    PATHS.RUINS,   // 9: forest
                ];

                const levelToLoad = lv || 1;

                const basePath = TILE_SET_SEQUENCE[levelToLoad] || PATHS.RUINS;


                const loadPromises = [];
                for (const key in blockImages) {
                    loadPromises.push(
                        new Promise((resolve) => {
                            const img = blockImages[key];
                            img.onload = () => resolve();
                            img.src = `${basePath}block_${key}.png`;
                        })
                    );
                }

                Promise.all(loadPromises).then(() => {
                    level = levelToLoad;
                    cols = 21 + (level - 1) * 2;
                    rows = 21 + (level - 1) * 2;
                    if (cols % 2 === 0) cols++; if (rows % 2 === 0) rows++;

                    timeLimitSeconds = getTimeLimitForLevel(level);
                    startTime = Date.now();
                    timeUp = false;

                    generateMaze(cols, rows);
                    player.x = 1.5; player.y = 1.5; player.vx = 0; player.vy = 0;
                    levelCleared = false;
                    placeItemsForLevel(level);
                    revealAround(player.x, player.y);
                    updateHud();
                });
            }
            // function startLevel(lv) {
            //     hasKey = false;

            //     // âš ï¸ ìˆ˜ì •: ë ˆë²¨ë³„ íƒ€ì¼ì…‹ ê²½ë¡œë¥¼ ì‚¬ìš©ìê°€ ìš”ì²­í•œ ìˆœì„œë¡œ ë³€ê²½ (road, mart, road, house, road, forest...)
            //     const PATHS = {
            //         ROAD: "img/c/tiles_road/",
            //         MART: "img/c/tiles_mart/",
            //         MANSION: "img/c/tiles_mansion/", // 'house'ë¡œ ê°„ì£¼
            //         RUINS: "img/c/tiles_ruins/",     // 'forest'ë¡œ ê°„ì£¼ (Level 6ë¶€í„° ë°˜ë³µ ì ìš©)
            //         OUTSIDE: "img/c/tiles_outside/"
            //     };

            //     // ë ˆë²¨ ìˆœì„œ ì •ì˜ (Level 1ë¶€í„° ì‹œì‘)
            //     const TILE_SET_SEQUENCE = [
            //         null,          // ë ˆë²¨ 0 (ë¯¸ì‚¬ìš©)
            //         PATHS.ROAD,    // 1: road
            //         PATHS.MART,    // 2: mart
            //         PATHS.ROAD,    // 3: road
            //         PATHS.MANSION, // 4: house (mansion)
            //         PATHS.ROAD,    // 5: road
            //         PATHS.RUINS,   // 6: forest (ruins)
            //         PATHS.RUINS,   // 7: forest
            //         PATHS.RUINS,   // 8: forest
            //         PATHS.RUINS,   // 9: forest
            //     ];

            //     const levelToLoad = lv || 1;

            //     // TILE_SET_SEQUENCEì— ì •ì˜ëœ ë ˆë²¨ì„ ì‚¬ìš©í•˜ê±°ë‚˜, ì—†ìœ¼ë©´ RUINSë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‚¬ìš©
            //     const basePath = TILE_SET_SEQUENCE[levelToLoad] || PATHS.RUINS;


            //     const loadPromises = [];
            //     for (const key in blockImages) {
            //         loadPromises.push(
            //             new Promise((resolve) => {
            //                 const img = blockImages[key];
            //                 img.onload = () => resolve();
            //                 img.src = `${basePath}block_${key}.png`;
            //             })
            //         );
            //     }

            //     Promise.all(loadPromises).then(() => {
            //         level = levelToLoad;
            //         cols = 21 + (level - 1) * 2;
            //         rows = 21 + (level - 1) * 2;
            //         if (cols % 2 === 0) cols++; if (rows % 2 === 0) rows++;

            //         timeLimitSeconds = getTimeLimitForLevel(level);
            //         startTime = Date.now();
            //         timeUp = false;

            //         generateMaze(cols, rows);
            //         player.x = 1.5; player.y = 1.5; player.vx = 0; player.vy = 0;
            //         levelCleared = false;
            //         placeItemsForLevel(level);
            //         revealAround(player.x, player.y);
            //         updateHud();
            //     });
            // }

            const showIntroStart = () => {
                overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">í”„ë¡¤ë¡œê·¸</h3>
                <p>ê¹Šì€ ë¯¸ê¶ ì†ìœ¼ë¡œ ë°œì„ ë‚´ë”›ì—ˆë‹¤. ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ íƒí—˜ì„ ì‹œì‘í•˜ì„¸ìš”.</p>
                <div class="actions"><button class="primary" id="startBtn">ê²Œì„ ì‹œì‘</button></div>`;
                overlay.style.display = 'flex';
                document.getElementById('startBtn').onclick = () => {
                    overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">í”„ë¡¤ë¡œê·¸</h3><p>${storyTexts.intro[0]}</p>`;
                    collectedStories['intro'] = { unlocked: true, text: storyTexts.intro[0] };
                    saveStories();
                    setTimeout(() => { overlay.style.display = 'none'; startLevel(1); requestAnimationFrame(update); }, 1200);
                };
            };

            /* =========================
              17. ë ˆë²¨ í´ë¦¬ì–´/ì§„í–‰
              ========================= */
            function completeLevelAndProgress() {
                // 1. ìª½ì§€ ì˜êµ¬ ì €ì¥ í™•ì¸ (ë²„ê·¸ í•´ê²° í•µì‹¬!)
                if (tempCollectedNoteId) {
                    // ì„ì‹œ íšë“í•œ ìª½ì§€ë¥¼ ì˜êµ¬ ì €ì¥í•˜ê³  ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ë°˜ì˜
                    unlockNote(tempCollectedNoteId);
                    showToast(`ìª½ì§€ [${tempCollectedNoteId}]ê°€ ë„ê°ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    tempCollectedNoteId = null; // ì´ˆê¸°í™”
                }

                // 2. ë ˆë²¨ í´ë¦¬ì–´ ë° ë‹¤ìŒ ë ˆë²¨ë¡œ ì§„í–‰
                levelCleared = true;
                showStoryOverlay(`Level ${level} í´ë¦¬ì–´!`, storyTexts[`level${level}`] || ['ë¯¸ê¶ì„ ë²—ì–´ë‚¬ë‹¤.'], 1500);

                // 3. ë‹¤ìŒ ë ˆë²¨ ì‹œì‘
                setTimeout(() => {
                    if (level < 99) {
                        startLevel(level + 1);
                        requestAnimationFrame(update); // update loop ì¬ì‹œì‘
                    } else {
                        showStoryOverlay('ì—”ë”©', storyTexts.ending[0], 0);
                    }
                }, 1500);
            }


            /* =========================
               18. ì…ë ¥ / ì¡°ì´ìŠ¤í‹± ì´ˆê¸°í™”
               ========================= */
            const joystick = document.getElementById('joystick');
            const stick = document.getElementById('stick');
            let joyActive = false; let joyCenter = null;
            function initJoyCenter() { const r = joystick.getBoundingClientRect(); joyCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2 }; }
            initJoyCenter(); window.addEventListener('resize', initJoyCenter);
            function setStickPos(dx, dy) { const max = (joystick.clientWidth / 2 - stick.clientWidth / 2 - 6); const tx = Math.max(-1, Math.min(1, dx)) * max; const ty = Math.max(-1, Math.min(1, dy)) * max; stick.style.transform = `translate(${tx}px, ${ty}px)`; }
            function startJoy(x, y) { joyActive = true; initJoyCenter(); updateJoy(x, y); }
            function updateJoy(x, y) { if (!joyActive || !joyCenter) return; let dx = x - joyCenter.x; let dy = y - joyCenter.y; const distv = Math.hypot(dx, dy); const max = joystick.clientWidth / 2; if (distv > max) { dx = dx / distv * max; dy = dy / distv * max; } const nx = dx / max, ny = dy / max; player.vx = nx * speed; player.vy = ny * speed; setStickPos(nx, ny); }
            function endJoy() { joyActive = false; player.vx = 0; player.vy = 0; setStickPos(0, 0); }

            function initInput() {
                // Keyboard
                window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
                window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
                // Joystick
                joystick.addEventListener('touchstart', e => { e.preventDefault(); startJoy(e.touches[0].clientX, e.touches[0].clientY); });
                joystick.addEventListener('touchmove', e => { e.preventDefault(); updateJoy(e.touches[0].clientX, e.touches[0].clientY); });
                joystick.addEventListener('touchend', e => { e.preventDefault(); endJoy(); });
                joystick.addEventListener('mousedown', e => { e.preventDefault(); startJoy(e.clientX, e.clientY); });
                window.addEventListener('mousemove', e => { if (joyActive) updateJoy(e.clientX, e.clientY); });
                window.addEventListener('mouseup', e => { if (joyActive) endJoy(); });
            }

            /* =========================
               19. ì´ë²¤íŠ¸ ë°”ì¸ë”© (Buttons)
               ========================= */
            function initListeners() {
                // Debug Reset Spawn Order
                document.getElementById('resetSpawn').addEventListener('click', () => {
                    resetSpawnSession();
                    showToast('ì„¸ì…˜ ìŠ¤í° ìˆœì„œ ì´ˆê¸°í™” ì™„ë£Œ.');
                });

                // Codex open
                codexBtn.addEventListener('click', () => { openCodex(); });

                // Home button
                homeBtn.addEventListener('click', () => { showIntroStart(); });

                // Fresh start
                freshStartBtn.addEventListener('click', () => {
                    if (!confirm('ì •ë§ ì²˜ìŒë¶€í„° ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ë„ê°/íšë“í•œ ìª½ì§€ ëª¨ë‘ ì´ˆê¸°í™”ë©ë‹ˆë‹¤)')) return;
                    resetCollectedStories();
                    resetSpawnSession();
                    updateHud();
                    showToast('ë„ê°ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    showIntroStart();
                });
            }

            /* =========================
               20. ì´ˆê¸° ì‹¤í–‰
               ========================= */
            loadStories();
            initInput();
            initListeners();
            updateHud();

            if (!collectedStories['intro']) {
                showIntroStart();
            } else {
                startLevel(level);
                requestAnimationFrame(update);
            }

            // Global Debug Access (ìœ ì§€)
            window._GAME = {
                getState: () => ({ level, rows, cols, maze, items, player, collectedStories }),
                resetStories: () => { collectedStories = {}; saveStories(); alert('stories reset'); },
                resetSpawnSession: () => { resetSpawnSession(); alert('spawn session reset'); }
            };
        })();
    </script>
</body>

</html>