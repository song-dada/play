<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>ëœë¤ ë¯¸ë¡œ ê²Œì„ (Add Story)</title>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>

    <div id="gameWrapper">
        <canvas id="game" width="480" height="480"></canvas>
    </div>
    <canvas id="miniMap" width="260" height="260"></canvas>
    <div class="hud" id="hud"></div>
    <div id="overlay"></div>
    <div id="joystick">
        <div id="stick"></div>
    </div>

    <div id="hud"></div>

    <button id="logBtn" class="codex-btn">ğŸ“– ìŠ¤í† ë¦¬ ë„ê°</button>
    <div id="codexOverlay" class="codex-overlay" style="display:none;"></div>


    <script>
        const gameCanvas = document.getElementById("game");
        const gameCtx = gameCanvas.getContext("2d");
        const miniCanvas = document.getElementById("miniMap");
        const miniCtx = miniCanvas.getContext("2d");
        const hud = document.getElementById("hud");
        const overlay = document.getElementById("overlay");
        const joystick = document.getElementById("joystick");
        const stick = document.getElementById("stick");

        // ìƒíƒœ
        let rows, cols, tileSize = 30;
        let revealRadius;
        let maze, revealed, player, goal, items;
        const collected = new Set();
        let level = 1;
        let inTransition = false;
        let velocity = { x: 0, y: 0 };
        const speed = 0.08;

        // ë²½ ë¸”ëŸ­ ì´ë¯¸ì§€ (ìµœëŒ€ 3x3)
        const blockImages = {
            "1x1": new Image(), "1x2": new Image(), "1x3": new Image(),
            "2x1": new Image(), "2x2": new Image(), "2x3": new Image(),
            "3x1": new Image(), "3x2": new Image(), "3x3": new Image()
        };
        // (ì´ë¯¸ì§€ ê²½ë¡œëŠ” êµì²´í•˜ì„¸ìš”)
        blockImages["1x1"].src = "img/block_1x1.png";
        blockImages["1x2"].src = "img/block_1x2.png";
        blockImages["1x3"].src = "img/block_1x3.png";
        blockImages["2x1"].src = "img/block_2x1.png";
        blockImages["2x2"].src = "img/block_2x2.png";
        blockImages["2x3"].src = "img/block_2x3.png";
        blockImages["3x1"].src = "img/block_3x1.png";
        blockImages["3x2"].src = "img/block_3x2.png";
        blockImages["3x3"].src = "img/block_3x3.png";

        let wallGroups = [];

        // -----------------------------------------
        // [ADD] ìŠ¤í† ë¦¬ ë„ê°: ê³ ì • ìŠ¬ë¡¯ ìˆœì„œ(ì—”ë”©ìˆ˜ì§‘ ê°™ì€ ëŠë‚Œìœ¼ë¡œ)
        const storySlots = [
            { id: "intro", label: "í”„ë¡¤ë¡œê·¸" },
            { id: "key", label: "ì—´ì‡ " },
            { id: "gem", label: "ë³´ì„" },
            { id: "compass", label: "ë‚˜ì¹¨ë°˜" },
            { id: "level1", label: "ë ˆë²¨ 1" },
            { id: "level2", label: "ë ˆë²¨ 2" },
            { id: "level3", label: "ë ˆë²¨ 3" },
            { id: "ending", label: "ì—”ë”©" },
        ];

        const storyTexts = {
            key: ["ë‚¡ì€ ì—´ì‡ ë¥¼ ì†ì— ë„£ì—ˆë‹¤..."],
            gem: ["ë³´ì„ì´ ë°˜ì§ì´ë©° ë¶ˆê¸¸í•˜ê²Œ ë¹›ë‚œë‹¤..."],

            // í° ë‚˜ì¹¨ë°˜ ìŠ¤í† ë¦¬ â†’ ì‘ì€ ì¡°ê°ë“¤
            compass: [
                [
                    "ì„œìª½ì—ì„œ ê¸°ë¬˜í•œ ê¸°ìš´ì´ ëŠê»´ì§„ë‹¤...",
                    "ë‚˜ì¹¨ë°˜ì´ ê°‘ìê¸° í”ë“¤ë¦¬ë©° ë°©í–¥ì„ ìƒëŠ”ë‹¤..."
                ],
                [
                    "ë©€ë¦¬ì„œ ë‚®ì€ ìš¸ìŒì†Œë¦¬ê°€ ë“¤ë ¤ì˜¨ë‹¤...",
                    "ë²½ì— ìƒˆê²¨ì§„ ê³ ëŒ€ ë¬¸ì–‘ì´ ëˆˆì— ë“¤ì–´ì™”ë‹¤..."
                ],
                [
                    "â€˜ì¶œêµ¬ëŠ” ì—†ë‹¤â€™ëŠ” ëª©ì†Œë¦¬ê°€ ë©”ì•„ë¦¬ì³¤ë‹¤...",
                    "ì°¨ê°‘ê³  ìŠµí•œ ê³µê¸°ê°€ ë” ì§™ì–´ì¡Œë‹¤..."
                ]
            ],

            level1: ["ì²« ë²ˆì§¸ ë¯¸ê¶ì„ í†µê³¼í–ˆë‹¤!"],
            level2: ["ë” ê¹Šì€ ê³³ìœ¼ë¡œ ë°œê±¸ìŒì„ ì˜®ê¸´ë‹¤..."],
            ending: ["ë“œë””ì–´ ë¯¸ê¶ì—ì„œ íƒˆì¶œí–ˆë‹¤!"]
        };

        // [ADD] íšë“ ì—¬ë¶€(ê³ ì • ìˆœì„œë¡œ ìˆ˜ì§‘)
        const collectedStories = Object.fromEntries(storySlots.map(s => [s.id, false]));

        // -----------------------------------------
        let compassProgress = 0;             // ì§€ê¸ˆê¹Œì§€ ëª‡ ê°œ ì—´ì—ˆëŠ”ì§€
        let unlockedCompassParts = new Set();// í•´ê¸ˆëœ ì¡°ê° ID ê¸°ë¡

        function handleCompassStory() {
            if (compassProgress === 0) {
                unlockCompassPart(0, 0); // ì²« ì¡°ê° ê³ ì •
            } else if (compassProgress === 1) {
                unlockCompassPart(0, 1); // ë‘ ë²ˆì§¸ ì¡°ê° ê³ ì •
            } else {
                // ë‚¨ì€ ê²ƒ ì¤‘ ëœë¤ ì„ íƒ
                const available = [];
                storyTexts.compass.forEach((group, gi) => {
                    group.forEach((_, si) => {
                        const id = `compass_${gi}_${si}`;
                        if (!unlockedCompassParts.has(id)) available.push({ gi, si });
                    });
                });
                if (available.length) {
                    const pick = available[Math.floor(Math.random() * available.length)];
                    unlockCompassPart(pick.gi, pick.si);
                } else {
                    unlockStory("compass_done", "ë‚˜ì¹¨ë°˜ ìŠ¤í† ë¦¬ëŠ” ëª¨ë‘ í•´ê¸ˆë˜ì—ˆìŠµë‹ˆë‹¤!");
                }
            }

            compassProgress++;
        }

        function unlockCompassPart(gi, si) {
            const id = `compass_${gi}_${si}`;
            const text = storyTexts.compass[gi][si];
            unlockedCompassParts.add(id);
            unlockStory(id, text);
        }

        // -----------------------------------------
        // ìœ í‹¸
        function inBounds(x, y) { return x >= 0 && y >= 0 && x < cols && y < rows; }

        // ë¯¸ë¡œ ìƒì„±
        function generateMaze(w, h) {
            const mz = Array.from({ length: h }, () => Array(w).fill(1));
            function carve(x, y) {
                const dirs = [[0, -2], [0, 2], [-2, 0], [2, 0]];
                mz[y][x] = 0;
                dirs.sort(() => Math.random() - 0.5);
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (ny > 0 && ny < h - 1 && nx > 0 && nx < w - 1 && mz[ny][nx] === 1) {
                        mz[y + dy / 2][x + dx / 2] = 0;
                        carve(nx, ny);
                    }
                }
            }
            carve(1, 1);
            return mz;
        }

        function openEntrances(mz) {
            const h = mz.length, w = mz[0].length;
            const top = [], bot = [];
            for (let x = 1; x < w - 1; x += 2) {
                if (mz[1][x] === 0) top.push(x);
                if (mz[h - 2][x] === 0) bot.push(x);
            }
            const topX = top.length ? top[Math.floor(Math.random() * top.length)] : 1;
            const botX = bot.length ? bot[Math.floor(Math.random() * bot.length)] : w - 2;
            mz[0][topX] = 0; mz[h - 1][botX] = 0;
            return [{ x: topX, y: 0 }, { x: botX, y: h - 1 }];
        }

        function farthestBorderFrom(start) {
            const h = maze.length, w = maze[0].length;
            const dist = Array.from({ length: h }, () => Array(w).fill(-1));
            const q = [start]; dist[start.y][start.x] = 0; let best = start;
            while (q.length) {
                const { x, y } = q.shift();
                for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                    const nx = x + dx, ny = y + dy;
                    if (inBounds(nx, ny) && maze[ny][nx] === 0 && dist[ny][nx] === -1) {
                        dist[ny][nx] = dist[y][x] + 1;
                        q.push({ x: nx, y: ny });
                        if ((nx === 0 || ny === 0 || nx === w - 1 || ny === h - 1) && dist[ny][nx] > dist[best.y][best.x])
                            best = { x: nx, y: ny };
                    }
                }
            }
            return best;
        }

        function placeItems() {
            const candidates = [];
            for (let y = 0; y < rows; y++)for (let x = 0; x < cols; x++) {
                if (maze[y][x] === 0 && !(x === Math.floor(player.x) && y === Math.floor(player.y)) && !(x === goal.x && y === goal.y))
                    candidates.push({ x, y });
            }
            items = [];
            const types = ["key", "gem", "compass"];
            for (const type of types) {
                if (!candidates.length) break;
                const idx = Math.floor(Math.random() * candidates.length);
                const pos = candidates.splice(idx, 1)[0];
                items.push({ ...pos, type });
            }
        }

        function revealAround(px, py, r = revealRadius) {
            const r2 = r * r;
            for (let y = Math.max(0, py - r); y <= Math.min(rows - 1, py + r); y++) {
                for (let x = Math.max(0, px - r); x <= Math.min(cols - 1, px + r); x++) {
                    const dx = x - px, dy = y - py;
                    if (dx * dx + dy * dy <= r2) revealed[y][x] = true;
                }
            }
        }

        // ë²½ ê·¸ë£¹í•‘ (ìµœëŒ€ 3x3)
        function groupWalls() {
            const used = Array.from({ length: rows }, () => Array(cols).fill(false));
            wallGroups = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] !== 1 || used[y][x]) continue;
                    let bestW = 1, bestH = 1;
                    for (let h = 1; h <= 3; h++) {
                        for (let w = 1; w <= 3; w++) {
                            if (x + w > cols || y + h > rows) continue;
                            let valid = true;
                            for (let yy = y; yy < y + h; yy++) {
                                for (let xx = x; xx < x + w; xx++) {
                                    if (maze[yy][xx] !== 1 || used[yy][xx]) { valid = false; break; }
                                }
                                if (!valid) break;
                            }
                            if (valid) { bestW = w; bestH = h; }
                        }
                    }
                    wallGroups.push({ x, y, w: bestW, h: bestH });
                    for (let yy = y; yy < y + bestH; yy++)for (let xx = x; xx < x + bestW; xx++)used[yy][xx] = true;
                }
            }
        }

        function initLevel() {
            rows = 21 + (level - 1) * 2; cols = 21 + (level - 1) * 2;
            if (rows % 2 === 0) rows++; if (cols % 2 === 0) cols++;
            revealRadius = 3 - Math.min(level - 1, 3);
            maze = generateMaze(cols, rows);
            const [topEntrance] = openEntrances(maze);
            player = { x: topEntrance.x + 0.5, y: topEntrance.y + 0.5, size: 0.65 };
            goal = farthestBorderFrom({ x: topEntrance.x, y: topEntrance.y });
            revealed = Array.from({ length: rows }, () => Array(cols).fill(false));
            collected.clear();
            placeItems();
            revealAround(Math.floor(player.x), Math.floor(player.y));
            groupWalls(); // ê·¸ë£¹í•‘
            updateHud();
        }

        function updateHud() {
            const needKey = collected.has("key") ? "ğŸ”‘íšë“" : "ğŸ”‘ì—†ìŒ";
            const needGem = collected.has("gem") ? "ğŸ’íšë“" : "ğŸ’ì—†ìŒ";
            const opt = collected.has("compass") ? "ğŸ§­íšë“" : "ğŸ§­ì—†ìŒ";
            hud.textContent = `ë ˆë²¨ ${level} / ì•„ì´í…œ: ${needKey} / ${needGem} / ${opt}`;
        }

        function canMoveTo(cx, cy) {
            const half = player.size / 2, eps = 1e-8;
            const minX = Math.floor(cx - half + eps), maxX = Math.floor(cx + half - eps);
            const minY = Math.floor(cy - half + eps), maxY = Math.floor(cy + half - eps);
            for (let y = minY; y <= maxY; y++)for (let x = minX; x <= maxX; x++)
                if (!inBounds(x, y) || maze[y][x] === 1) return false;
            return true;
        }

        function updatePlayer() {
            const nx = player.x + velocity.x * speed, ny = player.y + velocity.y * speed;
            if (canMoveTo(nx, ny)) { player.x = nx; player.y = ny; }
            else {
                if (canMoveTo(nx, player.y)) player.x = nx;
                if (canMoveTo(player.x, ny)) player.y = ny;
            }
            revealAround(Math.floor(player.x), Math.floor(player.y));
            for (let i = items.length - 1; i >= 0; i--) {
                if (Math.hypot(items[i].x + 0.5 - player.x, items[i].y + 0.5 - player.y) < 0.6) {
                    const type = items[i].type; // --------
                    collected.add(items[i].type);

                    // ì•„ì´í…œ ìŠ¤í† ë¦¬ í•´ê¸ˆ
                    if (type === "compass") {
                        handleCompassStory();
                    } else {
                        unlockStory(type, storyTexts[type][0]);
                    }

                    // if (type === "compass") {
                    //     handleCompassStory();
                    // } else {
                    //     unlockStory(type, storyTexts[type][0]); // ë°°ì—´ ì²« ìš”ì†Œë§Œ
                    // }

                    items.splice(i, 1); updateHud();
                }
            }
            if (Math.hypot(goal.x + 0.5 - player.x, goal.y + 0.5 - player.y) < 0.6) {
                if (collected.has("key") && collected.has("gem")) showStory();
                else alert("ì•„ì´í…œì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ğŸ”‘ì™€ ğŸ’ë¥¼ ëª¨ë‘ ëª¨ìœ¼ì„¸ìš”.");
            }
        }

        function draw() {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            const offsetX = Math.floor(player.x * tileSize - gameCanvas.width / 2);
            const offsetY = Math.floor(player.y * tileSize - gameCanvas.height / 2);

            // ë²½
            for (const g of wallGroups) {
                const screenX = g.x * tileSize - offsetX;
                const screenY = g.y * tileSize - offsetY;
                const img = blockImages[`${g.w}x${g.h}`];
                if (img) gameCtx.drawImage(img, screenX, screenY, g.w * tileSize, g.h * tileSize);
                else {
                    gameCtx.fillStyle = "black";
                    gameCtx.fillRect(screenX, screenY, g.w * tileSize, g.h * tileSize);
                }
            }

            // ëª©í‘œ
            const gx = goal.x * tileSize - offsetX, gy = goal.y * tileSize - offsetY;
            gameCtx.fillStyle = "green"; gameCtx.fillRect(gx, gy, tileSize, tileSize);

            // ì•„ì´í…œ
            for (const item of items) {
                const ix = item.x * tileSize - offsetX, iy = item.y * tileSize - offsetY;
                if (item.type === "key") gameCtx.fillStyle = "gold";
                else if (item.type === "gem") gameCtx.fillStyle = "dodgerblue";
                else if (item.type === "compass") gameCtx.fillStyle = "purple";
                gameCtx.beginPath();
                gameCtx.arc(ix + tileSize / 2, iy + tileSize / 2, tileSize / 3, 0, Math.PI * 2);
                gameCtx.fill();
            }

            // í”Œë ˆì´ì–´
            const psizePx = tileSize * player.size;
            const px = gameCanvas.width / 2 - psizePx / 2;
            const py = gameCanvas.height / 2 - psizePx / 2;
            gameCtx.fillStyle = "red";
            gameCtx.fillRect(px, py, psizePx, psizePx);
        }

        function drawMiniMap() {
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            const scale = Math.min((miniCanvas.width - 20) / cols, (miniCanvas.height - 20) / rows);
            const ox = 10, oy = 10;
            for (let y = 0; y < rows; y++)for (let x = 0; x < cols; x++) {
                miniCtx.fillStyle = revealed[y][x] ? (maze[y][x] === 1 ? "#000" : "#fff") : "#333";
                miniCtx.fillRect(ox + x * scale, oy + y * scale, scale, scale);
            }
            miniCtx.fillStyle = "green";
            miniCtx.fillRect(ox + goal.x * scale, oy + goal.y * scale, scale, scale);
            miniCtx.fillStyle = "red";
            miniCtx.beginPath();
            miniCtx.arc(ox + player.x * scale, oy + player.y * scale, scale * 0.4, 0, Math.PI * 2);
            miniCtx.fill();
        }

        function showStory() {
            if (inTransition) return;
            inTransition = true;

            // ë ˆë²¨ í´ë¦¬ì–´ ë©”ì‹œì§€
            overlay.textContent = `ë ˆë²¨ ${level} í´ë¦¬ì–´!`;
            overlay.style.display = "flex";

            // === ìŠ¤í† ë¦¬ í•´ê¸ˆ ===
            if (level === 1) unlockStory("level1", storyTexts.level1);
            else if (level === 2) unlockStory("level2", storyTexts.level2);
            else if (level === 3) unlockStory("level3", storyTexts.level3);
            // ...í•„ìš”í•˜ë©´ ê³„ì† ì¶”ê°€

            setTimeout(() => {
                overlay.textContent = "ê¹Šì€ ë¯¸ê¶ ì†ìœ¼ë¡œ...";
            }, 1500);

            setTimeout(() => {
                overlay.style.display = "none";
                level++;
                initLevel();
                inTransition = false;
            }, 3000);
        }


        // [ADD] ë„ê° ì—´ê¸°/ë‹«ê¸°
        function openCodex() {
            const box = document.getElementById("codexOverlay");
            let html = "<div class='panel'><h3>ìŠ¤í† ë¦¬ ë„ê°</h3>";

            // ê¸°ë³¸ ìŠ¬ë¡¯ (intro, key, gem, level, ending)
            storySlots.forEach(s => {
                if (!s.id.startsWith("compass")) {
                    const owned = collectedStories[s.id];
                    const text = owned ? storyTexts[s.id][0] : "???";
                    const mark = owned ? "âœ…" : "âŒ";
                    html += `<div><strong>${mark} ${s.label}</strong><br>${text}</div><hr>`;
                }
            });

            // ë‚˜ì¹¨ë°˜ì€ ê·¸ë£¹ êµ¬ì¡°ë¡œ ì¶œë ¥
            html += "<h3>ğŸ§­ ë‚˜ì¹¨ë°˜ ì´ì•¼ê¸°</h3>";
            storyTexts.compass.forEach((group, gi) => {
                html += `<div><strong>ë‚˜ì¹¨ë°˜ ì´ì•¼ê¸° ${gi + 1}</strong><ul>`;
                group.forEach((text, si) => {
                    const id = `compass_${gi}_${si}`;
                    const owned = collectedStories[id];
                    html += `<li>${owned ? text : "???"}</li>`;
                });
                html += "</ul></div><hr>";
            });

            html += `<button id="codexClose">ë‹«ê¸°</button></div>`;
            box.innerHTML = html;
            box.style.display = "flex";
            document.getElementById("codexClose").onclick = () => box.style.display = "none";
        }

        document.getElementById("logBtn").onclick = openCodex;


        // [ADD] ë„ê° í•´ê¸ˆ(ì¤‘ë³µ ë°©ì§€ + ì§§ì€ í† ìŠ¤íŠ¸ ë©”ì‹œì§€)
        function unlockStory(id, toastMsg = null) {
            if (!collectedStories[id]) {
                collectedStories[id] = true;
                if (toastMsg) showToast(toastMsg);
            }
        }

        // -----------------------------------------
        // [ADD] ì§§ì€ í† ìŠ¤íŠ¸(ê¸°ì¡´ ë ˆë²¨ í´ë¦¬ì–´ overlayì™€ ì¶©ëŒ ë°©ì§€ìš©)
        let toastTimer = null;
        function showToast(text, ms = 1500) {
            const el = document.createElement("div");
            el.style.position = "fixed"; el.style.left = "50%"; el.style.top = "14%";
            el.style.transform = "translate(-50%,0)";
            el.style.background = "rgba(0,0,0,.75)"; el.style.color = "#fff";
            el.style.padding = "10px 14px"; el.style.borderRadius = "10px";
            el.style.zIndex = "2000"; el.textContent = text;
            document.body.appendChild(el);
            clearTimeout(toastTimer);
            toastTimer = setTimeout(() => el.remove(), ms);
        }
        // -----------------------------------------


        // ì¡°ì´ìŠ¤í‹±
        let joyCenter = null, joyActive = false;
        function setStick(dx, dy) { stick.style.left = 50 + dx * 40 + "%"; stick.style.top = 50 + dy * 40 + "%"; }
        function startInput(x, y) { const r = joystick.getBoundingClientRect(); joyCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2 }; joyActive = true; updateInput(x, y); }
        function updateInput(x, y) { if (!joyActive || !joyCenter) return; let dx = x - joyCenter.x, dy = y - joyCenter.y, dist = Math.hypot(dx, dy), max = 50; if (dist > max) { dx = dx / dist * max; dy = dy / dist * max; } const nx = dx / max, ny = dy / max; velocity.x = nx; velocity.y = ny; setStick(nx, ny); }
        function endInput() { joyActive = false; velocity.x = 0; velocity.y = 0; setStick(0, 0); }
        joystick.addEventListener("touchstart", e => startInput(e.touches[0].clientX, e.touches[0].clientY));
        joystick.addEventListener("touchmove", e => updateInput(e.touches[0].clientX, e.touches[0].clientY));
        joystick.addEventListener("touchend", endInput);
        joystick.addEventListener("mousedown", e => startInput(e.clientX, e.clientY));
        window.addEventListener("mousemove", e => { if (joyActive) updateInput(e.clientX, e.clientY); });
        window.addEventListener("mouseup", endInput);

        function gameLoop() { updatePlayer(); draw(); drawMiniMap(); requestAnimationFrame(gameLoop); }
        initLevel();
        gameLoop();
    </script>

</body>

</html>