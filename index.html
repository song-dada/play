<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <title>ëœë¤ ë¯¸ë¡œ ê²Œì„ (ë²½ ì´ë¯¸ì§€ + íšŒì „ ë§ê·¸ë¦¬ê¸°)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            color-scheme: light dark;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 14px;
            margin: 0;
            padding: 24px;
            background: #eee;
            font-family: system-ui, -apple-system, sans-serif;
        }

        #gameWrapper {
            width: 480px;
            height: 480px;
            overflow: hidden;
            border-radius: 50%;
            position: relative;
            background: #222;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .25) inset, 0 8px 20px rgba(0, 0, 0, .2);
        }

        #game {
            position: absolute;
            top: 0;
            left: 0;
            background: #222;
        }

        #miniMap {
            border: 2px solid #333;
            background: #111;
            box-shadow: 0 4px 12px rgba(0, 0, 0, .15);
        }

        .hud {
            font-size: 14px;
            color: #333;
        }

        #overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, .7);
            color: #fff;
            font-weight: bold;
            font-size: 24px;
            z-index: 999;
        }

        #joystick {
            position: fixed;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, .1);
            border: 2px solid #666;
            touch-action: none;
            z-index: 1000;
        }

        #stick {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 0, 0, .6);
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>

<body>
    <div id="gameWrapper">
        <canvas id="game" width="480" height="480" aria-label="ê²Œì„ í™”ë©´"></canvas>
    </div>
    <canvas id="miniMap" width="260" height="260" aria-label="ë¯¸ë‹ˆë§µ"></canvas>
    <div class="hud" id="hud"></div>
    <div id="overlay"></div>
    <div id="joystick">
        <div id="stick"></div>
    </div>

    <script>
        const gameCanvas = document.getElementById("game");
        const gameCtx = gameCanvas.getContext("2d");
        const miniCanvas = document.getElementById("miniMap");
        const miniCtx = miniCanvas.getContext("2d");
        const hud = document.getElementById("hud");
        const overlay = document.getElementById("overlay");
        const joystick = document.getElementById("joystick");
        const stick = document.getElementById("stick");

        // ===== ìƒíƒœ =====
        let rows, cols, tileSize = 30;
        let revealRadius;
        let maze, revealed, player, goal, items;
        const collected = new Set();
        let level = 1;
        let inTransition = false;
        let velocity = { x: 0, y: 0 };
        const speed = 0.08;

        function inBounds(x, y) { return x >= 0 && y >= 0 && x < cols && y < rows; }

        // ===== ë¯¸ë¡œ ìƒì„± (DFS) =====
        function generateMaze(w, h) {
            const mz = Array.from({ length: h }, () => Array(w).fill(1));
            function carve(x, y) {
                const dirs = [[0, -2], [0, 2], [-2, 0], [2, 0]];
                mz[y][x] = 0;
                dirs.sort(() => Math.random() - 0.5);
                for (const [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (ny > 0 && ny < h - 1 && nx > 0 && nx < w - 1 && mz[ny][nx] === 1) {
                        mz[y + dy / 2][x + dx / 2] = 0;
                        carve(nx, ny);
                    }
                }
            }
            carve(1, 1);
            return mz;
        }

        function openEntrances(mz) {
            const h = mz.length, w = mz[0].length;
            const top = [], bot = [];
            for (let x = 1; x < w - 1; x += 2) {
                if (mz[1][x] === 0) top.push(x);
                if (mz[h - 2][x] === 0) bot.push(x);
            }
            const topX = top.length ? top[Math.floor(Math.random() * top.length)] : 1;
            const botX = bot.length ? bot[Math.floor(Math.random() * bot.length)] : w - 2;
            mz[0][topX] = 0; mz[h - 1][botX] = 0;
            return [{ x: topX, y: 0 }, { x: botX, y: h - 1 }];
        }

        function farthestBorderFrom(start) {
            const h = maze.length, w = maze[0].length;
            const dist = Array.from({ length: h }, () => Array(w).fill(-1));
            const q = [start]; dist[start.y][start.x] = 0; let best = start;
            while (q.length) {
                const { x, y } = q.shift();
                for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                    const nx = x + dx, ny = y + dy;
                    if (inBounds(nx, ny) && maze[ny][nx] === 0 && dist[ny][nx] === -1) {
                        dist[ny][nx] = dist[y][x] + 1;
                        q.push({ x: nx, y: ny });
                        const isBorder = (nx === 0 || ny === 0 || nx === w - 1 || ny === h - 1);
                        if (isBorder && dist[ny][nx] > dist[best.y][best.x]) best = { x: nx, y: ny };
                    }
                }
            }
            return best;
        }

        function placeItems() {
            const candidates = [];
            for (let y = 0; y < rows; y++)for (let x = 0; x < cols; x++) {
                if (maze[y][x] === 0 && !(x === Math.floor(player.x) && y === Math.floor(player.y)) && !(x === goal.x && y === goal.y))
                    candidates.push({ x, y });
            }
            items = [];
            const types = ["key", "gem", "compass"]; // compassëŠ” ì„ íƒ ì•„ì´í…œ
            for (const type of types) {
                if (!candidates.length) break;
                const idx = Math.floor(Math.random() * candidates.length);
                const pos = candidates.splice(idx, 1)[0];
                items.push({ ...pos, type });
            }
        }

        function revealAround(px, py, r = revealRadius) {
            const r2 = r * r;
            for (let y = Math.max(0, py - r); y <= Math.min(rows - 1, py + r); y++) {
                for (let x = Math.max(0, px - r); x <= Math.min(cols - 1, px + r); x++) {
                    const dx = x - px, dy = y - py;
                    if (dx * dx + dy * dy <= r2) revealed[y][x] = true;
                }
            }
        }

        function initLevel() {
            rows = 21 + (level - 1) * 2;
            cols = 21 + (level - 1) * 2;
            if (rows % 2 === 0) rows++; if (cols % 2 === 0) cols++;
            revealRadius = 3 - Math.min(level - 1, 3); // ë¯¸ë‹ˆë§µ ë°íˆê¸° ë²”ìœ„

            maze = generateMaze(cols, rows);
            const [topEntrance] = openEntrances(maze);
            player = { x: topEntrance.x + 0.5, y: topEntrance.y + 0.5, size: 0.65 };
            goal = farthestBorderFrom({ x: topEntrance.x, y: topEntrance.y });
            revealed = Array.from({ length: rows }, () => Array(cols).fill(false));
            collected.clear();
            placeItems();
            revealAround(Math.floor(player.x), Math.floor(player.y));
            updateHud();
        }

        function updateHud() {
            const needKey = collected.has("key") ? "ğŸ”‘íšë“" : "ğŸ”‘ì—†ìŒ";
            const needGem = collected.has("gem") ? "ğŸ’íšë“" : "ğŸ’ì—†ìŒ";
            const optionalCompass = collected.has("compass") ? "ğŸ§­íšë“" : "ğŸ§­ì—†ìŒ";
            hud.textContent = `ë ˆë²¨ ${level} / ì•„ì´í…œ: ${needKey} / ${needGem} / ${optionalCompass}`;
        }

        // ===== ì¶©ëŒ (AABB) =====
        function canMoveTo(cx, cy) {
            const half = player.size / 2, eps = 1e-8;
            const minX = Math.floor(cx - half + eps), maxX = Math.floor(cx + half - eps);
            const minY = Math.floor(cy - half + eps), maxY = Math.floor(cy + half - eps);
            for (let y = minY; y <= maxY; y++) for (let x = minX; x <= maxX; x++) {
                if (!inBounds(x, y) || maze[y][x] === 1) return false;
            }
            return true;
        }

        function updatePlayer() {
            const nx = player.x + velocity.x * speed;
            const ny = player.y + velocity.y * speed;

            if (canMoveTo(nx, ny)) { player.x = nx; player.y = ny; }
            else {
                if (canMoveTo(nx, player.y)) player.x = nx;
                if (canMoveTo(player.x, ny)) player.y = ny;
            }

            revealAround(Math.floor(player.x), Math.floor(player.y));

            for (let i = items.length - 1; i >= 0; i--) {
                if (Math.hypot(items[i].x + 0.5 - player.x, items[i].y + 0.5 - player.y) < 0.6) {
                    collected.add(items[i].type);
                    items.splice(i, 1);
                    updateHud();
                }
            }

            if (Math.hypot(goal.x + 0.5 - player.x, goal.y + 0.5 - player.y) < 0.6) {
                if (collected.has("key") && collected.has("gem")) {
                    showStory();
                } else {
                    alert("ì•„ì´í…œì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ğŸ”‘ì™€ ğŸ’ë¥¼ ëª¨ë‘ ëª¨ìœ¼ì„¸ìš”.");
                }
            }
        }

        // ===== ë²½ ì´ë¯¸ì§€ ë¦¬ì†ŒìŠ¤ (íšŒì „ìš©) =====
        const wallImages = {
            horizontal: new Image(),
            vertical: new Image(),
            corner: new Image(),
            T: new Image(),
            cross: new Image(),
            end: new Image(),
            solid: new Image() // í´ë°±
        };
        // ê²½ë¡œëŠ” ì›í•˜ëŠ” íŒŒì¼ëª…ìœ¼ë¡œ êµì²´
        wallImages.horizontal.src = "img/wall_horizontal.png";
        wallImages.vertical.src = "img/wall_vertical.png";
        wallImages.corner.src = "img/wall_corner.png";
        wallImages.T.src = "img/wall_T.png";
        wallImages.cross.src = "img/wall_cross.png";
        wallImages.end.src = "img/wall_end.png";
        wallImages.solid.src = "img/wall_solid.png";

        // ì´ ì´ë¯¸ì§€ê°€ ë¡œë“œëëŠ”ì§€ ì²´í¬
        function ready(img) { return img && img.complete && img.naturalWidth > 0; }

        // ì´ì›ƒ ë²½ì„ ë³´ê³  íƒ€ì… + ê°ë„(ë¼ë””ì•ˆ) íŒë³„
        function getWallInfo(x, y) {
            if (maze[y][x] !== 1) return null;
            const up = (y > 0 && maze[y - 1][x] === 1);
            const down = (y < rows - 1 && maze[y + 1][x] === 1);
            const left = (x > 0 && maze[y][x - 1] === 1);
            const right = (x < cols - 1 && maze[y][x + 1] === 1);
            const cnt = (up ? 1 : 0) + (down ? 1 : 0) + (left ? 1 : 0) + (right ? 1 : 0);

            // êµì°¨
            if (cnt === 4) return { type: "cross", angle: 0 };

            // ì¼ì
            if (cnt === 2 && left && right) return { type: "horizontal", angle: 0 };
            if (cnt === 2 && up && down) return { type: "vertical", angle: 0 };

            // ì½”ë„ˆ (ë‘ ë°©í–¥ì´ ë§Œë‚˜ëŠ” ê²½ìš°)
            if (cnt === 2) {
                // up+right (â”” ëª¨ì–‘ì„ 90ë„ íšŒì „í•œ í˜•íƒœ)
                if (up && right) return { type: "corner", angle: 0 };
                // right+down
                if (right && down) return { type: "corner", angle: Math.PI / 2 };
                // down+left
                if (down && left) return { type: "corner", angle: Math.PI };
                // left+up
                if (left && up) return { type: "corner", angle: Math.PI * 3 / 2 };
            }

            // Tì (í•œ ë°©í–¥ë§Œ ë¹„ì–´ ìˆìŒ)
            if (cnt === 3) {
                // ìœ„ê°€ ë¹„ì–´ ìˆìœ¼ë©´ Tê°€ ìœ„ë¥¼ í–¥í•¨ (Tì˜ ë¨¸ë¦¬ê°€ ìœ„)
                if (!up) return { type: "T", angle: 0 };
                if (!right) return { type: "T", angle: Math.PI / 2 };
                if (!down) return { type: "T", angle: Math.PI };
                if (!left) return { type: "T", angle: Math.PI * 3 / 2 };
            }

            // ë(ë§‰ë‹¤ë¥¸) â€” ì—°ê²°ëœ í•œ ë°©í–¥ ê¸°ì¤€ìœ¼ë¡œ ë°©í–¥ ê²°ì •
            if (cnt === 1) {
                if (up) return { type: "end", angle: Math.PI };
                if (right) return { type: "end", angle: Math.PI * 3 / 2 };
                if (down) return { type: "end", angle: 0 };
                if (left) return { type: "end", angle: Math.PI / 2 };
            }

            // ì£¼ë³€ì´ ì „ë¶€ ë¹ˆ ê²½ìš°(ì™¸ê³½ ë‹¨ë… íƒ€ì¼ ë“±)
            return { type: "solid", angle: 0 };
        }

        // íšŒì „ ê·¸ë¦¬ê¸° ìœ í‹¸
        function drawRotated(img, x, y, size, angle) {
            gameCtx.save();
            gameCtx.translate(x + size / 2, y + size / 2);
            gameCtx.rotate(angle);
            gameCtx.drawImage(img, -size / 2, -size / 2, size, size);
            gameCtx.restore();
        }

        // ===== ê·¸ë¦¬ê¸° =====
        function draw() {
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            const offsetX = Math.floor(player.x * tileSize - gameCanvas.width / 2);
            const offsetY = Math.floor(player.y * tileSize - gameCanvas.height / 2);

            // ë°”ë‹¥/ë²½ ê¸°ë³¸ í‘œí˜„ ë¨¼ì €
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const screenX = x * tileSize - offsetX;
                    const screenY = y * tileSize - offsetY;
                    if (screenX + tileSize < 0 || screenX > gameCanvas.width ||
                        screenY + tileSize < 0 || screenY > gameCanvas.height) continue;

                    if (maze[y][x] === 1) {
                        gameCtx.fillStyle = "black";
                        gameCtx.fillRect(screenX, screenY, tileSize, tileSize);
                    } else {
                        gameCtx.fillStyle = "white";
                        gameCtx.fillRect(screenX, screenY, tileSize, tileSize);
                    }
                }
            }

            // ë²½ ì´ë¯¸ì§€ ë§ê·¸ë¦¬ê¸° (íƒ€ì… + ê°ë„)
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] !== 1) continue;
                    const info = getWallInfo(x, y);
                    if (!info) continue;

                    const img = wallImages[info.type] || wallImages.solid;
                    if (!ready(img)) continue; // ë¡œë“œ ì „ì´ë©´ ìŠ¤í‚µ(ê²€ì€ ë²½ë§Œ ë³´ì´ê²Œ)

                    const screenX = x * tileSize - offsetX;
                    const screenY = y * tileSize - offsetY;
                    if (screenX + tileSize < 0 || screenX > gameCanvas.width ||
                        screenY + tileSize < 0 || screenY > gameCanvas.height) continue;

                    drawRotated(img, screenX, screenY, tileSize, info.angle);
                }
            }

            // ëª©í‘œ (ì¶œêµ¬) â€” ë¯¸ë‹ˆë§µì—ì„œë§Œ ë°í˜€ì¡Œì„ ë•Œ ì´ˆë¡ìœ¼ë¡œ ë³´ì´ë˜ ê¸°ì¡´ ë™ì‘ì„ ìœ ì§€í•  ìˆ˜ë„ ìˆì§€ë§Œ
            // ë©”ì¸ í™”ë©´ì€ ì‹œì•¼ì œí•œì„ ì ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ í•­ìƒ ë³´ì´ê²Œ ìœ ì§€
            const gx = goal.x * tileSize - offsetX;
            const gy = goal.y * tileSize - offsetY;
            if (gx + tileSize >= 0 && gx <= gameCanvas.width && gy + tileSize >= 0 && gy <= gameCanvas.height) {
                gameCtx.fillStyle = "green";
                gameCtx.fillRect(gx, gy, tileSize, tileSize);
            }

            // ì•„ì´í…œ
            for (const item of items) {
                const sx = item.x * tileSize - offsetX;
                const sy = item.y * tileSize - offsetY;
                if (sx + tileSize < 0 || sx > gameCanvas.width || sy + tileSize < 0 || sy > gameCanvas.height) continue;
                if (item.type === "key") gameCtx.fillStyle = "gold";
                else if (item.type === "gem") gameCtx.fillStyle = "dodgerblue";
                else if (item.type === "compass") gameCtx.fillStyle = "purple";
                gameCtx.beginPath();
                gameCtx.arc(sx + tileSize / 2, sy + tileSize / 2, tileSize / 3, 0, Math.PI * 2);
                gameCtx.fill();
            }

            // í”Œë ˆì´ì–´(í™”ë©´ ì¤‘ì•™ ê³ ì •)
            const psizePx = tileSize * player.size;
            const px = gameCanvas.width / 2 - psizePx / 2;
            const py = gameCanvas.height / 2 - psizePx / 2;
            gameCtx.fillStyle = "red";
            gameCtx.fillRect(px, py, psizePx, psizePx);
        }

        // ===== ë¯¸ë‹ˆë§µ =====
        function drawMiniMap() {
            miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
            const scale = Math.min((miniCanvas.width - 20) / cols, (miniCanvas.height - 20) / rows);
            const ox = 10, oy = 10;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    miniCtx.fillStyle = revealed[y][x] ? (maze[y][x] === 1 ? "#000" : "#fff") : "#333";
                    miniCtx.fillRect(ox + x * scale, oy + y * scale, scale, scale);
                }
            }
            if (revealed[goal.y][goal.x]) {
                miniCtx.fillStyle = "green";
                miniCtx.fillRect(ox + goal.x * scale, oy + goal.y * scale, scale, scale);
            }
            miniCtx.fillStyle = "red";
            miniCtx.beginPath();
            miniCtx.arc(ox + player.x * scale, oy + player.y * scale, scale * 0.4, 0, Math.PI * 2);
            miniCtx.fill();
        }

        function showStory() {
            if (inTransition) return;
            inTransition = true;
            overlay.textContent = `ë ˆë²¨ ${level} í´ë¦¬ì–´!`;
            overlay.style.display = "flex";
            setTimeout(() => { overlay.textContent = "ê¹Šì€ ë¯¸ê¶ ì†ìœ¼ë¡œ..."; }, 1500);
            setTimeout(() => {
                overlay.style.display = "none";
                level++; initLevel(); inTransition = false;
            }, 3000);
        }

        // ===== ê°€ìƒ ì¡°ì´ìŠ¤í‹± =====
        let joyCenter = null, joyActive = false;
        function setStick(dx, dy) { stick.style.left = 50 + dx * 40 + "%"; stick.style.top = 50 + dy * 40 + "%"; }
        function startInput(x, y) {
            const rect = joystick.getBoundingClientRect();
            joyCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            joyActive = true; updateInput(x, y);
        }
        function updateInput(x, y) {
            if (!joyActive || !joyCenter) return;
            let dx = x - joyCenter.x, dy = y - joyCenter.y;
            const dist = Math.hypot(dx, dy), maxDist = 50;
            if (dist > maxDist) { dx = dx / dist * maxDist; dy = dy / dist * maxDist; }
            const nx = dx / maxDist, ny = dy / maxDist;
            velocity.x = nx; velocity.y = ny; setStick(nx, ny);
        }
        function endInput() { joyActive = false; velocity.x = 0; velocity.y = 0; setStick(0, 0); }

        joystick.addEventListener("touchstart", e => startInput(e.touches[0].clientX, e.touches[0].clientY));
        joystick.addEventListener("touchmove", e => updateInput(e.touches[0].clientX, e.touches[0].clientY));
        joystick.addEventListener("touchend", endInput);
        joystick.addEventListener("mousedown", e => startInput(e.clientX, e.clientY));
        window.addEventListener("mousemove", e => { if (joyActive) updateInput(e.clientX, e.clientY); });
        window.addEventListener("mouseup", endInput);

        // ===== ë©”ì¸ ë£¨í”„ =====
        function gameLoop() { updatePlayer(); draw(); drawMiniMap(); requestAnimationFrame(gameLoop); }

        initLevel();
        gameLoop();
    </script>
</body>

</html>
