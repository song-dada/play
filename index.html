<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ëœë¤ ë¯¸ë¡œ ê²Œì„ (ì‚¬ìš´ë“œ ìˆ˜ì • 3ì°¨)</title>
    <link rel="stylesheet" href="css/new.css">
</head>

<body>
    <div class="wrap">
        <div id="ads"></div>
        <div id="hubmap">
            <div class="hud">
                <div class="hubup">
                    <div class="panel" id="levelPanel">
                        ë ˆë²¨: <span id="levelText">1</span>
                    </div>
                    <div class="panel items" id="itemPanel">
                        ì•„ì´í…œ:
                        <img id="itemKeyEl" src="img/item/Bread_empty.png" alt="key" width="24" height="24">
                        <img id="itemCompassEl" src="img/item/Letter_empty.png" alt="compass" width="24" height="24">
                    </div>
                </div>
                <div class="hud-actions">
                    <button id="homeBtn">í™ˆ</button>
                    <button class="primary" id="freshStartBtn">ì²˜ìŒë¶€í„° ì‹œì‘</button>
                    <button id="codexBtn">ğŸ“– ë„ê°</button>
                </div>
            </div>
            <div id="miniWrapper"><canvas id="miniMap" width="260" height="260"></canvas></div>
        </div>

        <div id="gameWrapper">
            <canvas id="game" width="480" height="480"></canvas>
        </div>

        <div id="joystickWrap">
            <div id="joystick">
                <div id="stick"></div>
            </div>
        </div>
    </div>

    <div id="overlay" class="overlay" style="display:none">
        <div class="panel" id="overlayPanel"></div>
    </div>

    <div id="codexOverlay" class="overlay" style="display:none">
        <div class="panel" id="codexPanel"></div>
    </div>

    <button id="resetSpawn" class="debug-reset">Reset Spawn Order (session)</button>

    <button id="bgmToggle" class="sound-btn">ğŸ”Š BGM ì¼œì§</button>

    <audio id="bgm" loop></audio>


    <script>
        const MazeGame = {
            /**
             * 1. ì„¤ì • (Configuration)
             * - ê²Œì„ì˜ í•µì‹¬ ìƒìˆ˜, ë°ì´í„°, í…ìŠ¤íŠ¸ ë“±ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
             */
            config: {
                STORAGE_KEY: 'maze_collectedStories_v1',
                SPAWN_KEY: 'maze_spawnOrder_v1',
                SPAWN_INDEX_KEY: 'maze_spawnIndex_v1',
                STORY_GROUPS: [
                    { id: 'siblings', label: 'ë‚¨ë§¤', parts: ['siblings_1', 'siblings_2', 'siblings_3'], fullStoryId: 'siblings_full' },
                    { id: 'maid', label: 'ê°€ì •ë¶€', parts: ['maid_1', 'maid_2', 'maid_3'], fullStoryId: 'maid_full' },
                    { id: 'traveler', label: 'ì—¬í–‰ê°', parts: ['traveler_1', 'traveler_2', 'traveler_3'], fullStoryId: 'traveler_full' },
                    { id: 'sibling_younger', label: 'ë™ìƒ', parts: ['sibling_younger_1', 'sibling_younger_2', 'sibling_younger_3'], fullStoryId: 'sibling_younger_full' },
                    { id: 'weak_union', label: 'ì•½ì ì—°í•©', parts: ['weak_union_1', 'weak_union_2', 'weak_union_3'], fullStoryId: 'weak_union_full' }
                ],
                // in MazeGame.config
                BGM_PATHS: {
                    1: 'bgm/city_core.wav',
                    2: 'bgm/level_2_mart.mp3',
                    3: 'bgm/city_core.wav',
                    4: 'bgm/mansion.mp3',
                    5: 'bgm/mansion.mp3',
                    6: 'bgm/level_6_ruins.mp3',
                    DEFAULT: 'bgm/default_ruins.mp3' // 6ë ˆë²¨ ì´ˆê³¼ ì‹œ ì‚¬ìš©í•  ê¸°ë³¸ BGM
                },
                // ... (ê¸°ì¡´ STORY_TEXTS ë“±)
                STORY_TEXTS: {
                    intro: ['ì„¸ìƒì´ í˜¼ë€ì— ë¹ ì§€ê³  15ì¼, ë°”ë‹¥ì„ ë³´ì¸ ì‹ëŸ‰ì— ë‚˜ëŠ” ë¬¼ìë¥¼ êµ¬í•˜ê¸° ìœ„í•´ ë°–ìœ¼ë¡œ ë‚˜ì„°ë‹¤...'],
                    level1: ['ì²« ë²ˆì§¸ ë¯¸ê¶ì„ í†µê³¼í–ˆë‹¤!'],
                    level2: ['ë” ê¹Šì€ ê³³ìœ¼ë¡œ ë°œê±¸ìŒì„ ì˜®ê¸´ë‹¤...'],
                    ending: ['ë“œë””ì–´ ë¯¸ê¶ì—ì„œ íƒˆì¶œí–ˆë‹¤!'],
                    siblings_1: ["ì—¬ê¸°ì„œ ì‹ëŸ‰ê³¼ ì•½í’ˆì„ í™•ë³´í–ˆë‹¤.\nì²˜ìŒì—” ì‚´ì•„ë‚¨ì•˜ë‹¤ëŠ” ì•ˆë„ë¿ì´ì—ˆë‹¤."],
                    siblings_2: ["ë¼ë””ì˜¤ê°€ ì¡í˜”ë‹¤.\në…¸ì´ì¦ˆ ì†ì—ì„œâ€¦ â€œìº í”„.â€\nìƒì¡´ì ìº í”„ë¼ ë“¤ë ¸ë‹¤."],
                    siblings_3: ["(38.6-34.4)â€¦ ì „ë¶€ëŠ” ë²ˆì¡Œë‹¤.\nì¢Œí‘œë‹¤. ìš°ë¦¬ëŠ” ê·¸ê³³ìœ¼ë¡œ ê°„ë‹¤."],
                    maid_1: ["ì €íƒì€ ì¡°ìš©í–ˆë‹¤.\nì„¸ìƒì´ ì–´ì§€ëŸ½ë‹¤ í•´ë„, ì—¬ê¸´ ë³€í•¨ì—†ì—ˆë‹¤."],
                    maid_2: ["ì§‘ì‚¬ê°€ í”¼ë¥¼ í† í–ˆë‹¤.\nì‚¬ëª¨ë‹˜ì€ ë¯¸ì†Œë¥¼ ì§€ìœ¼ì…¨ë‹¤.\nê·¸ ì›ƒìŒì´â€¦ ë‘ë ¤ì› ë‹¤."],
                    maid_3: ["ì¼ì£¼ì¼ì„ ë²„í…¼ë‹¤.\në”ëŠ” ëª» í•œë‹¤.\në‚˜ëŠ” ì´ê³³ì„ ë– ë‚œë‹¤."],
                    traveler_1: ["ì²˜ìŒ ë³´ëŠ” ë¬´ë¦¬ì™€ í•©ë¥˜í–ˆë‹¤.\në‚¯ì„  ë‚˜ë¥¼ ë°˜ê²¨ì£¼ì–´â€¦ ë‹¤í–‰ì´ì—ˆë‹¤."],
                    traveler_2: ["ê¸¸ì€ ë§‰í˜”ê³ , ìœ„í—˜ì€ ë§ì•˜ë‹¤.\ní•˜ì§€ë§Œ í˜¼ìì˜€ë‹¤ë©´ ë²Œì¨ í¬ê¸°í–ˆì„ ê²ƒì´ë‹¤."],
                    traveler_3: ["ë‚´ì¼ì€ ë” ë‚˜ì•„ì§€ë¦¬ë¼ ë¯¿ëŠ”ë‹¤.\nìš°ë¦¬ê°€ ë„ì°©í•  ê³³ì€ ì—¬ê¸° ì•„ë‹ˆë‹ˆê¹Œ."],
                    sibling_younger_1: ["ëˆ„ë‚˜ê°€ ê¸°ì¹¨ì„ ì‹œì‘í–ˆë‹¤.\në©€ì©¡í–ˆë˜ ì‚¬ëŒì´, ê°‘ìê¸°."],
                    sibling_younger_2: ["ì—´ì€ ì˜¤ë¥´ê³ , ê¸°ì¹¨ì€ ê±°ì¹ ì–´ì¡Œë‹¤.\në‚´ ì•½ì„ ê±´ëƒˆëƒˆì§€ë§Œâ€¦ ê³ ê°¤ ì €ì—ˆë‹¤."],
                    sibling_younger_3: ["ëˆ„ë‚˜ëŠ” ì“°ëŸ¬ì¡Œë‹¤.\në‚˜ëŠ” ì‚´ì•„ì„œ ìº í”„ë¡œ ê°ˆê²Œ.\nì˜ ì, ëˆ„ë‚˜."],
                    weak_union_1: ["ìš°ë¦° ì•½ìì˜€ë‹¤.\nê·¸ë˜ì„œ ëª¨ì˜€ë‹¤. ì„œë¡œë¥¼ ì§€í‚¤ê¸° ìœ„í•´."],
                    weak_union_2: ["ë’¤ë”°ë¥´ë˜ ê·¸ë¥¼ ë°›ì•„ë“¤ì˜€ë‹¤.\në‚¯ì„¤ì—ˆì§€ë§Œ, ì ì€ ì•„ë‹ˆì—ˆë‹¤."],
                    weak_union_3: ["ì•„ì¹¨, ê·¸ëŠ” ì´ë¯¸ ì‹ì–´ ìˆì—ˆë‹¤.\nì¥ë¡€ë¥¼ ì¹˜ë¥´ê³ â€¦ ë°œê±¸ìŒì„ ë–¼ì—ˆë‹¤."],
                    siblings_full: ["ëˆ„ë‚˜ëŠ” ì‹ëŸ‰ê³¼ ì•½í’ˆì„ ì±™ê¸°ëŠ” ë° ëŠ¥ìˆ™í–ˆë‹¤. í™©íí•´ì§„ ë§ˆíŠ¸ì—ì„œ ì°¾ì€ ìƒì¡´ ë¬¼í’ˆì€ ì ì‹œë‚˜ë§ˆ ì•ˆë„ê°ì„ ì£¼ì—ˆë‹¤. ê·¸ëŸ¬ë‚˜ í¬ë§ì€ ë¬´ì„  í†µì‹ ì—ì„œ ì°¾ì€ 'ìº í”„'ë¼ëŠ” ë‹¨ì–´ì˜€ë‹¤. ìš°ë¦¬ëŠ” ê·¸ê³³ìœ¼ë¡œ ê°€ê¸° ìœ„í•´ ì§€ë„ì— ì¢Œí‘œë¥¼ ìƒˆê²¼ë‹¤. ì´ì œ ì´ ë¯¸ê¶ì„ ë²—ì–´ë‚˜ ê·¸ ì¢Œí‘œ(38.6-34.4)ë¡œ í–¥í•˜ëŠ” ê²ƒì´ ìš°ë¦¬ì˜ ìœ ì¼í•œ ëª©í‘œê°€ ë˜ì—ˆë‹¤. ì´ ë‚¡ì€ ê¸°ë¡ì€ ìš°ë¦¬ì˜ ì—¬ì •ì˜ ì‹œì‘ì„ ì•Œë¦°ë‹¤."],
                    maid_full: ["ëŒ€ì €íƒì€ ì„¸ìƒì˜ í˜¼ë€ê³¼ëŠ” ë¬´ê´€í•˜ê²Œ ê³ ìš”í–ˆë‹¤. ê°€ì •ë¶€ì¸ ë‚˜ëŠ” ì´ í‰ì˜¨í•¨ì´ ê¸°ì´í•˜ê²Œ ëŠê»´ì¡Œë‹¤. ì–´ëŠ ë‚ , ì§‘ì‚¬ë‹˜ì´ í”¼ë¥¼ í† í•˜ëŠ” ëª¨ìŠµì„ ë³´ì•˜ê³ , ê·¸ë•Œ ì‚¬ëª¨ë‹˜ì˜ ì°¨ê°€ìš´ ë¯¸ì†ŒëŠ” ë‚˜ì—ê²Œ ê³µí¬ ê·¸ ìì²´ì˜€ë‹¤. ì´ ì €íƒì€ ì•ˆì „í•œ í”¼ë‚œì²˜ê°€ ì•„ë‹ˆì—ˆë‹¤. ì¼ì£¼ì¼ì„ ë²„í‹°ê³ , ë” ì´ìƒ ë²„í‹¸ ìˆ˜ ì—†ë‹¤ê³  íŒë‹¨í•œ ë‚˜ëŠ” ëª°ë˜ ì €íƒì„ ë– ë‚˜ê¸°ë¡œ ê²°ì‹¬í–ˆë‹¤. ì´ ê¸°ë¡ì€ ë‚´ê°€ íƒˆì¶œí•˜ê¸° ì§ì „ì˜ ì‹¬ì •ì„ ë‹´ê³  ìˆë‹¤."],
                    traveler_full: ["ë‚˜ëŠ” í™€ë¡œ ë– ëŒë˜ ì—¬í–‰ê°ì´ì—ˆë‹¤. ê¸¸ ìœ„ì—ì„œ ìš°ì—°íˆ ë§Œë‚œ ë¬´ë¦¬ëŠ” ë‚¯ì„  ë‚˜ë¥¼ ì¡°ê±´ ì—†ì´ ë°›ì•„ì£¼ì—ˆê³ , ë‚˜ëŠ” ê·¸ë“¤ì˜ ë”°ëœ»í•¨ì— ê°ì‚¬í–ˆë‹¤. ë¯¸ê¶ì€ ë§‰í˜€ìˆì—ˆê³ , ê¸¸ì€ ìœ„í—˜ìœ¼ë¡œ ê°€ë“í–ˆì§€ë§Œ, í˜¼ìì˜€ë‹¤ë©´ ì´ë¯¸ ì¢Œì ˆí–ˆì„ ê²ƒì´ë‹¤. ë‚˜ëŠ” ê·¸ë“¤ê³¼ í•¨ê»˜ë¼ë©´ ë” ë‚˜ì€ ê³³ì— ë„ì°©í•  ìˆ˜ ìˆì„ ê±°ë¼ ë¯¿ì—ˆë‹¤. ë§¤ì¼ ë°¤, ìš°ë¦¬ëŠ” ë‚´ì¼ì„ ê¸°ì•½í•˜ë©° ì ë“¤ì—ˆë‹¤. ì´ ì´ì•¼ê¸°ëŠ” ë‚´ê°€ ê·¸ë“¤ê³¼ í•¨ê»˜í–ˆë˜, ì§§ê³ ë„ í¬ë§ì°¼ë˜ ê¸°ë¡ì´ë‹¤."],
                    sibling_younger_full: ["ëˆ„ë‚˜ê°€ ê¸°ì¹¨ì„ ì‹œì‘í•œ ê±´ ê°‘ì‘ìŠ¤ëŸ¬ìš´ ì¼ì´ì—ˆë‹¤. ì²˜ìŒì—” ë‹¨ìˆœí•œ ê°ê¸°ë¼ ìƒê°í–ˆì§€ë§Œ, ê·¸ë…€ì˜ ì—´ì€ ê±·ì¡ì„ ìˆ˜ ì—†ì´ ì˜¬ëê³  ê¸°ì¹¨ì€ í‰ì¸¡í•˜ê²Œ ê±°ì¹ ì–´ì¡Œë‹¤. ë‚˜ëŠ” í•„ì‚¬ì ìœ¼ë¡œ ì•½ì„ ê±´ë„¸ì§€ë§Œ, ëˆ„ë‚˜ëŠ” ê³ ê°œë¥¼ ì €ì—ˆë‹¤. ê·¸ë…€ëŠ” ê²°êµ­ ì“°ëŸ¬ì¡Œê³ , ë‚˜ëŠ” ê·¸ë…€ë¥¼ ë‘” ì±„ ì‚´ì•„ì„œ ìº í”„ë¡œ ê°€ì•¼ë§Œ í–ˆë‹¤. ë¯¸ì•ˆí•¨ê³¼ ìŠ¬í””ì„ ë’¤ë¡œí•œ ì±„, ë‚˜ëŠ” ëˆ„ë‚˜ì—ê²Œ ë§ˆì§€ë§‰ ì‘ë³„ ì¸ì‚¬ë¥¼ ê³ í–ˆë‹¤. ì´ ê¸°ë¡ì€ í¬ë§ì´ ë¶•ê´´ëœ ìˆœê°„ì˜ ì°¸í˜¹í•œ ì¦ì–¸ì´ë‹¤."],
                    weak_union_full: ["ìš°ë¦¬ëŠ” ì„¸ìƒì—ì„œ ê°€ì¥ ì•½í•œ ì¡´ì¬ë“¤ì´ì—ˆê¸°ì—, ì„œë¡œë¥¼ ì§€í‚¤ê¸° ìœ„í•´ ì—°í•©í–ˆë‹¤. ìš°ë¦¬ëŠ” ìƒì¡´ì´ë¼ëŠ” ê³µë™ì˜ ëª©í‘œ ì•„ë˜ ë‚¯ì„  ì´ë“¤ì„ ë°›ì•„ë“¤ì´ëŠ” ë° ì£¼ì €í•˜ì§€ ì•Šì•˜ë‹¤. ì—¬í–‰ê°ì´ ê·¸ì¤‘ í•œ ëª…ì´ì—ˆë‹¤. ê·¸ëŠ” ì¡°ìš©í–ˆì§€ë§Œ ê°•ì¸í–ˆë‹¤. ê·¸ëŸ¬ë‚˜ ìƒì¡´ì€ ì”í˜¹í–ˆë‹¤. ì–´ëŠ ì•„ì¹¨, ê·¸ëŠ” ì´ë¯¸ ì°¨ê°‘ê²Œ ì‹ì–´ ìˆì—ˆë‹¤. ìš°ë¦¬ëŠ” ê·¸ì˜ ì¥ë¡€ë¥¼ ì¹˜ë €ê³ , ìŠ¬í””ì„ ì´ê²¨ë‚´ë©° ë‹¤ì‹œ ë°œê±¸ìŒì„ ë–¼ì—ˆë‹¤. ì´ ê¸°ë¡ì€ ì•½ìë“¤ì˜ ì—°í•©ì´ ê²ªì€ ë¹„ê·¹ê³¼ ì¬ì¶œë°œì˜ ì´ì•¼ê¸°ì´ë‹¤."]
                },
                get ALL_NOTE_IDS() {
                    return [].concat(...this.STORY_GROUPS.map(g => g.parts));
                }
            },

            /**
             * 2. ìƒíƒœ (State)
             * - ê²Œì„ ì§„í–‰ ì¤‘ ê³„ì† ë³€í•˜ëŠ” ëª¨ë“  ë°ì´í„°ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
             */
            state: {
                tileSize: 30,
                rows: 21, cols: 21,
                maze: [],
                revealMap: [],
                visitedMap: [],
                items: [],
                level: 1,
                player: { x: 1.5, y: 1.5, size: 0.65, vx: 0, vy: 0 },
                speed: 4.2,
                lastTime: 0,
                goal: { x: 19, y: 19 },
                startTime: 0,
                timeLimitSeconds: 90,
                timeUp: false,
                hasKey: false,
                levelCleared: false,
                collectedStories: {},
                hasNoteInCurrentLevel: false,
                currentLevelNoteId: null,
                keys: {},
                joyActive: false,
                joyCenter: null,
                blockImages: {},
                itemImages: { "note": new Image(), "key": new Image() },
                isRunning: true,
                audioReady: false,

                // player
                playerImages: { up: new Image(), down: new Image(), left: new Image(), right: new Image() },
                // ê¸°ë³¸ ë°©í–¥ (ì•„ë¬´ ì…ë ¥ ì—†ì„ ë•Œ)
                playerDirection: "down",
                currentBGM: null, // âœ… ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš”
            },

            /**
             * 3. DOM ìš”ì†Œ ë° ì»¨í…ìŠ¤íŠ¸
             * - ìì£¼ ì‚¬ìš©í•˜ëŠ” DOM ê°ì²´ì™€ ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë³´ê´€í•©ë‹ˆë‹¤.
             */
            dom: {
                gameCanvas: null, ctx: null,
                miniCanvas: null, miniCtx: null,
                overlay: null, overlayPanel: null,
                codexOverlay: null, codexPanel: null,
                codexBtn: null, homeBtn: null, freshStartBtn: null,
                levelText: null, itemKeyEl: null, itemCompassEl: null,
                joystick: null, stick: null
            },

            /**
             * 4. ìœ í‹¸ë¦¬í‹° (Utils)
             * - ë²”ìš©ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” í—¬í¼ í•¨ìˆ˜ë“¤ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
             */
            utils: {
                inBounds: (x, y) => y >= 0 && y < MazeGame.state.maze.length && x >= 0 && x < MazeGame.state.maze[0].length,
                randInt: (a, b) => Math.floor(Math.random() * (b - a + 1)) + a,
                dist: (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by),
                getTimeLimitForLevel(lv) {
                    if (lv <= 1) return 90;
                    if (lv === 2) return 120;
                    if (lv === 3) return 150;
                    return 150 + (lv - 3) * 30;
                }
            },

            /**
             * 5. UI ê´€ë¦¬
             * - HUD ì—…ë°ì´íŠ¸, í† ìŠ¤íŠ¸ ë©”ì‹œì§€, ì˜¤ë²„ë ˆì´ ë“± UI ê´€ë ¨ ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
             */
            ui: {
                updateHud() {
                    MazeGame.dom.levelText.textContent = MazeGame.state.level;
                    MazeGame.dom.itemKeyEl.src = MazeGame.state.hasKey ? "img/item/Bread.png" : "img/item/Bread_empty.png";
                    MazeGame.dom.itemCompassEl.src = MazeGame.state.hasNoteInCurrentLevel ? "img/item/Letter.png" : "img/item/Letter_empty.png";
                },
                showToast(text, ms = 1600) {
                    const t = document.createElement('div'); t.className = 'toast'; t.textContent = text;
                    document.body.appendChild(t);
                    setTimeout(() => t.remove(), ms);
                },
                showLoadingOverlay(message = 'ë‹¤ìŒ ë ˆë²¨ ë¡œë”© ì¤‘...') {
                    const { overlay, overlayPanel } = MazeGame.dom;
                    overlayPanel.innerHTML = '';
                    const box = document.createElement('div'); box.className = 'loading-box';
                    const spinner = document.createElement('div'); spinner.className = 'spinner';
                    const msg = document.createElement('div'); msg.className = 'loading-msg'; msg.textContent = message;
                    box.appendChild(spinner); box.appendChild(msg);
                    overlayPanel.appendChild(box);
                    overlay.style.display = 'flex';
                },
                hideOverlay() {
                    MazeGame.dom.overlay.style.display = 'none';
                    MazeGame.dom.overlayPanel.innerHTML = '';
                },

                // in MazeGame.ui
                showStoryOverlay(title, text, autoCloseMs = 3000, backContextGroup = null) {
                    const { overlay, overlayPanel } = MazeGame.dom;
                    overlayPanel.innerHTML = '';
                    const h = document.createElement('h3'); h.style.margin = '0 0 6px'; h.textContent = title || 'ìƒì„¸';
                    overlayPanel.appendChild(h);
                    let content = Array.isArray(text) ? text.join('\n\n') : String(text || '');
                    if (content) {
                        const p = document.createElement('pre'); p.className = 'story'; p.textContent = content;
                        overlayPanel.appendChild(p);
                    }
                    const actions = document.createElement('div');
                    actions.className = 'actions';
                    Object.assign(actions.style, {
                        display: 'flex',
                        justifyContent: 'space-between', // ì–‘ìª½ ì •ë ¬
                        marginTop: '12px',
                    });

                    // â–¼ "ì´ì „ìœ¼ë¡œ" ë²„íŠ¼ ë¡œì§ (backContextGroupì´ ìˆì„ ë•Œë§Œ ìƒì„±) â–¼
                    if (backContextGroup) {
                        const backBtn = document.createElement('button');
                        backBtn.className = 'secondary'; // "ì´ì „" ë²„íŠ¼
                        backBtn.textContent = 'ì´ì „ìœ¼ë¡œ';
                        backBtn.onclick = () => {
                            overlay.style.display = 'none'; // í˜„ì¬ ì˜¤ë²„ë ˆì´ ë‹«ê¸°
                            // ì´ì „ì— ë´¤ë˜ ê·¸ë£¹ ì˜¤ë²„ë ˆì´(ìª½ì§€ ëª¨ìŒì°½)ë¥¼ ë‹¤ì‹œ ì—½ë‹ˆë‹¤.
                            MazeGame.codex.showGroupOverlay(backContextGroup);
                        };
                        actions.appendChild(backBtn); // ì™¼ìª½ì— "ì´ì „ìœ¼ë¡œ"
                    } else {
                        // "ì´ì „" ë²„íŠ¼ì´ ì—†ì„ ê²½ìš° ê³µê°„ì„ ì°¨ì§€í•  ë¹ˆ divë¥¼ ì¶”ê°€í•˜ì—¬ "ë‹«ê¸°" ë²„íŠ¼ì„ ì˜¤ë¥¸ìª½ ì •ë ¬
                        actions.appendChild(document.createElement('div'));
                    }

                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'ghost'; // "ë‹«ê¸°" ë²„íŠ¼
                    closeBtn.textContent = 'ë‹«ê¸°';
                    closeBtn.onclick = () => { overlay.style.display = 'none'; };
                    actions.appendChild(closeBtn); // ì˜¤ë¥¸ìª½ì— "ë‹«ê¸°"
                    overlayPanel.appendChild(actions);

                    overlay.style.display = 'flex';
                    if (autoCloseMs > 0 && !backContextGroup) { // "ì´ì „" ë²„íŠ¼ì´ ì—†ìœ¼ë©´ ìë™ ë‹«ê¸° í™œì„±í™”
                        setTimeout(() => { if (overlay.style.display === 'flex') overlay.style.display = 'none'; }, autoCloseMs);
                    }
                },
                showGameOverOverlay({ title = 'ê²Œì„ ì˜¤ë²„', message = '' } = {}) {
                    const { overlay, overlayPanel } = MazeGame.dom;
                    overlayPanel.innerHTML = '';
                    const panel = document.createElement('div'); panel.className = 'panel';
                    const h3 = document.createElement('h3'); h3.textContent = title; panel.appendChild(h3);
                    if (message) { const p = document.createElement('p'); p.innerText = message; panel.appendChild(p); }
                    const actions = document.createElement('div'); actions.className = 'actions';
                    const restartBtn = document.createElement('button'); restartBtn.className = 'primary'; restartBtn.textContent = 'ë‹¤ì‹œ ì‹œì‘';
                    // restartBtn.onclick = () => {
                    //     overlay.style.display = 'none';
                    //     MazeGame.state.timeUp = false;
                    //     MazeGame.engine.startLevel(MazeGame.state.level);
                    //     requestAnimationFrame(MazeGame.engine.update);
                    // };
                    restartBtn.onclick = () => {
                        overlay.style.display = 'none';
                        MazeGame.state.timeUp = false;

                        // âœ… ì˜¤ë””ì˜¤ ê¶Œí•œ í”Œë˜ê·¸ ì„¤ì • (ë¸Œë¼ìš°ì € í—ˆìš© í›„ ìë™ ì¬ìƒ ê°€ëŠ¥)
                        localStorage.setItem('audioUnlocked', 'true');
                        MazeGame.state.audioReady = true;

                        // âœ… ë ˆë²¨ì— ë§ëŠ” BGM ì§€ì • ë° ì¬ìƒ
                        if (MazeGame.audio && typeof MazeGame.audio.playBGM === 'function') {
                            MazeGame.audio.playBGM(MazeGame.state.level);
                        } else {
                            console.warn('âš ï¸ playBGM í•¨ìˆ˜ê°€ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                        }

                        // âœ… ê²Œì„ ì¬ì‹œì‘
                        MazeGame.engine.startLevel(MazeGame.state.level);
                        requestAnimationFrame(MazeGame.engine.update.bind(MazeGame.engine));
                    };


                    // restartBtn.onclick = () => {
                    //     overlay.style.display = 'none';
                    //     MazeGame.state.timeUp = false;

                    //     // ğŸ”¹ ì˜¤ë””ì˜¤ ê¶Œí•œ ë° ì¬ìƒ ì²˜ë¦¬ (í´ë¦­ ì´ë²¤íŠ¸ ë‚´ë¶€ â€” ì•ˆì „)
                    //     const bgm = document.getElementById('bgm');
                    //     if (bgm && bgm.paused) {
                    //         bgm.volume = 0.4;
                    //         bgm.play()
                    //             .then(() => {
                    //                 localStorage.setItem('audioUnlocked', 'true');
                    //                 console.log('ğŸµ ì˜¤ë””ì˜¤ ê¶Œí•œ íšë“ ë° BGM ì¬ìƒ ì‹œì‘');
                    //             })
                    //             .catch(e => console.warn('BGM ì¬ìƒ ì‹¤íŒ¨:', e));
                    //     }

                    //     // ğŸ”¹ ì´í›„ ê²Œì„ ì¬ì‹œì‘ ë¡œì§
                    //     MazeGame.engine.startLevel(MazeGame.state.level);
                    //     // .bind(MazeGame.engine)ì„ ì¶”ê°€í•˜ì—¬ 'this'ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ë°”ì¸ë”©í•©ë‹ˆë‹¤.
                    //     requestAnimationFrame(MazeGame.engine.update.bind(MazeGame.engine));
                    // };

                    actions.appendChild(restartBtn);
                    const exitBtn = document.createElement('button'); exitBtn.className = 'ghost'; exitBtn.style.marginLeft = '8px'; exitBtn.textContent = 'ì¢…ë£Œ';

                    exitBtn.onclick = () => {
                        overlay.style.display = 'none';
                        MazeGame.state.timeUp = false;

                        // âœ… ë£¨í”„ ì¤‘ë‹¨
                        MazeGame.state.isRunning = false;

                        // âœ… ìƒíƒœ ë¦¬ì…‹ (ë¯¸ë¡œ, ì•„ì´í…œ, í”Œë ˆì´ì–´ ë“±)
                        MazeGame.state.maze = [];
                        MazeGame.state.revealMap = [];
                        MazeGame.state.visitedMap = [];
                        MazeGame.state.items = [];
                        MazeGame.state.hasKey = false;
                        MazeGame.state.hasNoteInCurrentLevel = false;
                        MazeGame.state.levelCleared = false;
                        MazeGame.state.joyActive = false;
                        MazeGame.state.player = { x: 1.5, y: 1.5, size: 0.65, vx: 0, vy: 0 };

                        MazeGame.ui.updateHud();

                        // âœ… í™ˆí™”ë©´ í‘œì‹œ
                        MazeGame.engine.showIntroStart();
                    };

                    actions.appendChild(exitBtn);
                    panel.appendChild(actions);
                    overlayPanel.appendChild(panel);
                    overlay.style.display = 'flex';
                }
            },

            // MazeGame ê°ì²´ ë‚´ë¶€ì— audio ëª¨ë“ˆ ì¶”ê°€
            audio: {
                playBGM(level) {
                    const bgm = document.getElementById('bgm');
                    if (!bgm) return;

                    // âœ… ìë™ base path ê°ì§€
                    const basePath = (() => {
                        const path = window.location.pathname;
                        // ê¹ƒí—ˆë¸Œ Pagesìš©: "/repo-name/" í˜•íƒœë©´ repo ì´ë¦„ ì¶”ì¶œ
                        const match = path.match(/^\/([^/]+)\//);
                        return match ? `/${match[1]}/` : './';  // ë¡œì»¬ì—ì„  "./", ê¹ƒí—ˆë¸Œì—ì„  "/repo-name/"
                    })();

                    let src = '';
                    if (level >= 1 && level <= 3) src = `${basePath}audio/bgm_SCP-x7x.mp3`;
                    else if (level >= 4 && level <= 5) src = `${basePath}audio/bgm_Despair_and_Triumph.mp3`;
                    else if (level >= 6 && level <= 12) src = `${basePath}audio/bgm_SCP-x5x.mp3`;
                    else if (level >= 13 && level <= 15) src = `${basePath}audio/bgm_SCP-x6x.mp3`;
                    else src = `${basePath}audio/bgm_Ossuary_6_Air.mp3`;

                    // ğŸ”¹ ìœ ì € í—ˆìš© ì—†ìœ¼ë©´ ì¬ìƒ ì˜ˆì•½ë§Œ
                    if (!MazeGame.state.audioReady) {
                        console.warn('ğŸ§ ì•„ì§ ì˜¤ë””ì˜¤ í—ˆìš© ì•ˆ ë¨ â€” ë‹¤ìŒ í´ë¦­ ì‹œ ì¬ì‹œë„ ì˜ˆì •');
                        const tryPlay = () => {
                            MazeGame.state.audioReady = true;
                            MazeGame.audio.playBGM(level);
                            document.removeEventListener('click', tryPlay);
                            document.removeEventListener('touchstart', tryPlay);
                        };
                        document.addEventListener('click', tryPlay);
                        document.addEventListener('touchstart', tryPlay);
                        return;
                    }

                    bgm.pause();
                    bgm.src = src;
                    bgm.volume = 0.4;
                    bgm.load();
                    bgm.play().catch(e => console.warn('BGM ì¬ìƒ ì‹¤íŒ¨:', e));
                },


                stopBGM() {
                    const bgm = document.getElementById('bgm');
                    if (bgm) bgm.pause();
                },

                toggle() {
                    const bgm = document.getElementById('bgm');
                    const btn = document.getElementById('bgmToggle');
                    this.muted = !this.muted;
                    if (bgm) bgm.volume = this.muted ? 0 : 0.4;
                    if (btn) btn.textContent = this.muted ? 'ğŸ”‡ BGM êº¼ì§' : 'ğŸ”Š BGM ì¼œì§';
                },
            },
            // ... (ê¸°ì¡´ storage, input ë“±)

            /**
             * 6. ë„ê° (Codex) ê´€ë¦¬
             * - ìŠ¤í† ë¦¬ ë„ê° ì—´ê¸°, ê·¸ë£¹ë³„ ìŠ¤í† ë¦¬ ë³´ê¸° ë“± ë„ê° ê´€ë ¨ ê¸°ëŠ¥ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
             */
            codex: {
                showGroupOverlay(group) {
                    const { collectedStories } = MazeGame.state;
                    const { STORY_TEXTS } = MazeGame.config;
                    const { overlay, overlayPanel } = MazeGame.dom;
                    const parts = group.parts;
                    const collectedParts = parts.filter(pid => !!collectedStories[pid]);
                    const collectedCount = collectedParts.length;
                    const total = parts.length;
                    const gotAll = collectedCount === total;
                    const fullStoryId = group.fullStoryId;
                    const fullStoryText = fullStoryId ? STORY_TEXTS[fullStoryId] : null;

                    if (collectedCount === 0) {
                        MazeGame.ui.showToast('íšë“í•œ ìª½ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        return;
                    }

                    let storyContentHtml = '';
                    const displayParts = gotAll ? parts : collectedParts;
                    if (gotAll) {
                        storyContentHtml += '<div style="margin-bottom: 15px; font-weight: bold; color: #ffeb3b;">ìŠ¤í† ë¦¬ ì™„ì„±!</div>';
                    } else {
                        storyContentHtml += '<div style="margin-bottom: 10px; opacity: 0.8;">(ì¼ë¶€ íšë“)</div>';
                    }

                    displayParts.forEach((pid) => {
                        const txt = collectedStories[pid]?.text || STORY_TEXTS[pid];
                        let content = Array.isArray(txt) ? txt.join('\n\n') : String(txt || '');
                        storyContentHtml += `<pre class="story">${content}</pre>`;
                    });

                    // âœ… íŒ¨ë„ ì´ˆê¸°í™” ë° ë‚´ìš© ì‚½ì…
                    overlayPanel.innerHTML = '';
                    const h = document.createElement('h3');
                    h.style.margin = '0 0 8px';
                    h.textContent = group.label;
                    overlayPanel.appendChild(h);

                    const noteContainer = document.createElement('div');
                    noteContainer.innerHTML = storyContentHtml;
                    overlayPanel.appendChild(noteContainer);

                    // âœ… ì „ì²´ ìŠ¤í† ë¦¬ ë²„íŠ¼
                    if (gotAll && fullStoryText) {
                        const fullStoryBtn = document.createElement('button');
                        fullStoryBtn.className = 'primary';
                        fullStoryBtn.textContent = 'ğŸ“– ì „ì²´ ìŠ¤í† ë¦¬ ë³´ê¸°';
                        Object.assign(fullStoryBtn.style, { marginTop: '15px', marginBottom: '8px', width: '100%' });
                        fullStoryBtn.onclick = () => {
                            overlay.style.display = 'none';
                            MazeGame.ui.showStoryOverlay(`[${group.label}] - ì „ì²´ ìŠ¤í† ë¦¬`, fullStoryText, 0, group);

                            // MazeGame.ui.showStoryOverlay(`[${group.label}] - ì „ì²´ ìŠ¤í† ë¦¬`, fullStoryText, 0);
                        };
                        overlayPanel.appendChild(fullStoryBtn);
                    }

                    const hint = document.createElement('p');
                    Object.assign(hint.style, { opacity: '0.9', marginTop: '8px' });
                    hint.textContent = gotAll
                        ? `ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•˜ìŠµë‹ˆë‹¤. ì™„ì„±ëœ ìŠ¤í† ë¦¬ê°€ í•´ê¸ˆë˜ì—ˆìŠµë‹ˆë‹¤.`
                        : `ëª¨ì€ ìª½ì§€: ${collectedCount}/${total}. ëª¨ë“  ìª½ì§€ë¥¼ ëª¨ì•„ì•¼ ì™„ì„±ëœ ìŠ¤í† ë¦¬ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
                    overlayPanel.appendChild(hint);

                    // âœ… ë²„íŠ¼ ì˜ì—­ (ì´ì „ìœ¼ë¡œ + ë‹«ê¸°)
                    const actions = document.createElement('div');
                    actions.className = 'actions';
                    Object.assign(actions.style, {
                        display: 'flex',
                        justifyContent: 'space-between',
                        marginTop: '12px',
                    });

                    const backBtn = document.createElement('button');
                    backBtn.className = 'secondary';
                    backBtn.textContent = 'ì´ì „ìœ¼ë¡œ';
                    backBtn.onclick = () => {
                        overlay.style.display = 'none';
                        MazeGame.codex.open(); // ğŸ”¥ ë„ê° ëª©ë¡ìœ¼ë¡œ ë³µê·€
                    };

                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'ghost';
                    closeBtn.textContent = 'ë‹«ê¸°';
                    closeBtn.onclick = () => {
                        overlay.style.display = 'none';
                    };

                    actions.appendChild(backBtn);
                    actions.appendChild(closeBtn);
                    overlayPanel.appendChild(actions);

                    overlay.style.display = 'flex';
                },

                open() {
                    const { codexPanel, codexOverlay } = MazeGame.dom;
                    const { collectedStories } = MazeGame.state;
                    const { STORY_GROUPS, STORY_TEXTS } = MazeGame.config;

                    codexPanel.innerHTML = '<h3 style="margin-top:0">ìŠ¤í† ë¦¬ ë„ê°</h3>';
                    STORY_GROUPS.forEach(g => {
                        const collectedCount = g.parts.filter(pid => !!collectedStories[pid]).length;
                        const row = document.createElement('div'); row.className = 'group';
                        const meta = document.createElement('div'); meta.className = 'meta';
                        const title = document.createElement('div'); title.className = 'title'; title.textContent = g.label;
                        const count = document.createElement('div'); count.className = 'count'; count.textContent = `${collectedCount}/${g.parts.length}`;
                        meta.appendChild(title); meta.appendChild(count);
                        row.appendChild(meta);

                        const preview = document.createElement('div');
                        Object.assign(preview.style, { marginTop: '6px', opacity: '0.9' });
                        if (collectedCount === 0) {
                            preview.textContent = 'ì ê¸ˆ â€” ì•„ì§ íšë“í•œ ìª½ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.';
                        } else {
                            const firstCollectedId = g.parts.find(pid => !!collectedStories[pid]);
                            const txt = (collectedStories[firstCollectedId]?.text) || STORY_TEXTS[firstCollectedId];
                            let excerpt = Array.isArray(txt) ? txt[0] : String(txt);
                            preview.textContent = excerpt.slice(0, 80) + (excerpt.length > 80 ? '...' : '');
                        }
                        row.appendChild(preview);

                        row.onclick = () => {
                            if (g.parts.filter(pid => !!MazeGame.state.collectedStories[pid]).length === 0) {
                                MazeGame.ui.showToast('íšë“í•œ ìª½ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                                return;
                            }
                            MazeGame.codex.showGroupOverlay(g);
                            codexOverlay.style.display = 'none';
                        };
                        codexPanel.appendChild(row);
                    });

                    const close = document.createElement('div');
                    close.style.marginTop = '8px';

                    close.innerHTML = `<div style="text-align:right"><button class="primary" id="codexClose">ë‹«ê¸°</button></div>`;
                    codexPanel.appendChild(close);
                    codexOverlay.style.display = 'flex';
                    document.getElementById('codexClose').onclick = () => { codexOverlay.style.display = 'none'; };
                }
            },

            /**
             * 7. ì €ì¥ì†Œ (Storage) ê´€ë¦¬
             * - LocalStorage, SessionStorage ê´€ë ¨ ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
             */
            storage: {
                loadStories() {
                    try {
                        const raw = localStorage.getItem(MazeGame.config.STORAGE_KEY);
                        MazeGame.state.collectedStories = raw ? (JSON.parse(raw) || {}) : {};
                    } catch (e) {
                        console.warn('loadStories error', e);
                        MazeGame.state.collectedStories = {};
                    }
                },
                saveStories() {
                    try {
                        localStorage.setItem(MazeGame.config.STORAGE_KEY, JSON.stringify(MazeGame.state.collectedStories));
                    } catch (e) {
                        console.warn('saveStories', e);
                    }
                },
                resetCollectedStories() {
                    MazeGame.state.collectedStories = {};
                    this.saveStories();
                },
                unlockNote(id) {
                    if (!MazeGame.state.collectedStories[id]) {
                        const txt = MazeGame.config.STORY_TEXTS[id] || '(ê¸°ë¡ ì—†ìŒ)';
                        MazeGame.state.collectedStories[id] = { unlocked: true, text: txt };
                        this.saveStories();
                    }
                },
                buildDefaultSpawnOrder() {
                    const order = new Array(15).fill(null);
                    order[0] = 'siblings_1'; order[1] = 'siblings_2'; order[2] = 'siblings_3';
                    order[3] = 'maid_1'; order[4] = 'maid_2'; order[5] = 'maid_3';
                    order[12] = 'sibling_younger_1'; order[13] = 'sibling_younger_2'; order[14] = 'sibling_younger_3';

                    const used = new Set(order.filter(Boolean));
                    const remaining = MazeGame.config.ALL_NOTE_IDS.filter(id => !used.has(id));
                    for (let i = remaining.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [remaining[i], remaining[j]] = [remaining[j], remaining[i]];
                    }

                    let idx = 0;
                    for (let pos = 6; pos <= 11; pos++) { order[pos] = remaining[idx++] || null; }
                    for (let i = 0; i < order.length; i++) if (!order[i] && idx < remaining.length) order[i] = remaining[idx++];
                    return order;
                },
                saveLevel(lv) {
                    localStorage.setItem('maze_current_level', lv);
                },
                loadLevel() {
                    const v = parseInt(localStorage.getItem('maze_current_level') || '1', 10);
                    MazeGame.state.level = v;
                },

                ensureSpawnOrder() {
                    // âœ… ì´ì œ sessionStorage ëŒ€ì‹  localStorage ì‚¬ìš© (ì„¸ì…˜ ìœ ì§€)
                    try {
                        const raw = localStorage.getItem(MazeGame.config.SPAWN_KEY);
                        if (raw) {
                            const arr = JSON.parse(raw);
                            if (Array.isArray(arr) && arr.length >= 15) return arr.slice(0, 15);
                        }
                    } catch (e) { /* ignore */ }

                    // ê¸°ë³¸ ìˆœì„œ ìƒì„± í›„ ì €ì¥
                    const built = this.buildDefaultSpawnOrder();
                    try {
                        localStorage.setItem(MazeGame.config.SPAWN_KEY, JSON.stringify(built));
                    } catch (e) { }
                    return built;
                },
                // âœ… ë ˆë²¨ë³„ ìª½ì§€ ë§¤í•‘ìš© ì¸ë±ìŠ¤ ê´€ë¦¬ (ìƒˆ í•¨ìˆ˜ ì¶”ê°€)
                getSpawnIndex() {
                    return parseInt(localStorage.getItem(MazeGame.config.SPAWN_INDEX_KEY) || '0', 10);
                },
                setSpawnIndex(idx) {
                    localStorage.setItem(MazeGame.config.SPAWN_INDEX_KEY, String(idx));
                },
                advanceSpawnIndex() {
                    const idx = this.getSpawnIndex();
                    this.setSpawnIndex(idx + 1);
                },

                // âœ… ìƒˆ í•¨ìˆ˜: í˜„ì¬ ë ˆë²¨ì— ë§ëŠ” ìª½ì§€ ë°˜í™˜
                getCurrentNoteForLevel(level) {
                    const order = this.ensureSpawnOrder();
                    const idx = Math.min(level - 1, order.length - 1);
                    return order[idx];
                },

                // âœ… ì´ˆê¸°í™” í•¨ìˆ˜ ìˆ˜ì • (sessionStorage â†’ localStorage)
                resetSpawnSession() {
                    try {
                        localStorage.removeItem(MazeGame.config.SPAWN_KEY);
                        localStorage.removeItem(MazeGame.config.SPAWN_INDEX_KEY);
                    } catch (e) { }
                },
                resetLevelProgress() {
                    try {
                        localStorage.removeItem('maze_current_level');
                    } catch (e) { console.warn('resetLevelProgress error', e); }
                },
            },

            /**
             * 8. ì…ë ¥ (Input) ê´€ë¦¬
             * - í‚¤ë³´ë“œ, ì¡°ì´ìŠ¤í‹± ë“± ì‚¬ìš©ì ì…ë ¥ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
             */
            input: {
                init() {
                    const { joystick } = MazeGame.dom;
                    // Keyboard
                    window.addEventListener('keydown', e => { MazeGame.state.keys[e.key.toLowerCase()] = true; });
                    window.addEventListener('keyup', e => { MazeGame.state.keys[e.key.toLowerCase()] = false; });
                    // Joystick
                    joystick.addEventListener('touchstart', e => { e.preventDefault(); this.startJoy(e.touches[0].clientX, e.touches[0].clientY); });
                    joystick.addEventListener('touchmove', e => { e.preventDefault(); this.updateJoy(e.touches[0].clientX, e.touches[0].clientY); });
                    document.addEventListener('touchend', e => {
                        e.preventDefault();
                        this.endJoy();
                    });
                    //stick.addEventListener('touchend', e => {
                    //    e.preventDefault();
                    //    MazeGame.state.joyActive = false;

                    //    // âœ… ì¤‘ì•™ ë³µê·€ (ì‚¬ë¼ì§€ì§€ ì•ŠìŒ)
                    //    stick.style.left = '50%';
                    //    stick.style.top = '50%';
                    //    stick.style.transform = 'translate(-50%, -50%)';

                    //    // âœ… í”Œë ˆì´ì–´ ì´ë™ ë©ˆì¶¤ (ì¤‘ìš”!)
                    //    MazeGame.state.player.vx = 0;
                    //    MazeGame.state.player.vy = 0;
                    //});

                    joystick.addEventListener('mousedown', e => { e.preventDefault(); this.startJoy(e.clientX, e.clientY); });
                    window.addEventListener('mousemove', e => { if (MazeGame.state.joyActive) this.updateJoy(e.clientX, e.clientY); });
                    window.addEventListener('mouseup', e => { if (MazeGame.state.joyActive) this.endJoy(); });

                    this.initJoyCenter();
                    window.addEventListener('resize', this.initJoyCenter);
                },
                initJoyCenter() {
                    const r = MazeGame.dom.joystick.getBoundingClientRect();
                    MazeGame.state.joyCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2 };
                },
                setStickPos(nx, ny) {
                    const joy = MazeGame.dom.joystick;
                    const stick = MazeGame.dom.stick;
                    const max = (joy.clientWidth - stick.clientWidth) / 2;

                    const dx = nx * max;
                    const dy = ny * max;

                    stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                },
                startJoy(x, y) {
                    MazeGame.state.joyActive = true;
                    this.initJoyCenter();
                    this.updateJoy(x, y);
                },
                updateJoy(x, y) {
                    const { joyActive, joyCenter, speed } = MazeGame.state;
                    if (!joyActive || !joyCenter) return;
                    let dx = x - joyCenter.x;
                    let dy = y - joyCenter.y;
                    const distv = Math.hypot(dx, dy);
                    const max = MazeGame.dom.joystick.clientWidth / 2;
                    if (distv > max) { dx = dx / distv * max; dy = dy / distv * max; }
                    const nx = dx / max, ny = dy / max;
                    MazeGame.state.player.vx = nx * speed;
                    MazeGame.state.player.vy = ny * speed;

                    this.setStickPos(nx, ny);
                },
                endJoy() {
                    MazeGame.state.joyActive = false;
                    MazeGame.state.player.vx = 0;
                    MazeGame.state.player.vy = 0;
                    this.setStickPos(0, 0);
                },
            },

            /**
             * 9. ê²Œì„ ì—”ì§„ (Engine)
             * - ê²Œì„ì˜ í•µì‹¬ ë¡œì§(ë©”ì¸ ë£¨í”„, ë Œë”ë§, ë¯¸ë¡œ ìƒì„±, ë ˆë²¨ ê´€ë¦¬ ë“±)ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
             */
            engine: {
                update(now) {
                    try {
                        const { state, utils } = MazeGame;

                        // ì¤‘ë‹¨ ì¡°ê±´
                        if (!state.isRunning) return;

                        const dt = Math.min(0.05, (now - state.lastTime) / 1000);
                        state.lastTime = now;

                        // ì‹œê°„ ì œí•œ ì²˜ë¦¬
                        if (!state.levelCleared && !state.timeUp) {
                            const elapsed = (Date.now() - state.startTime) / 1000;
                            if (elapsed >= state.timeLimitSeconds) {
                                state.timeUp = true;
                                MazeGame.ui.showGameOverOverlay();
                                return;
                            }
                        }

                        // í”Œë ˆì´ì–´ ì´ë™
                        // âœ… MazeGame.engine.update ë‚´ë¶€ êµì²´
                        const { player, speed } = state;

                        // ì´ë™ í›„ë³´ ì¢Œí‘œ ê³„ì‚°
                        let nextX = player.x + player.vx * dt;
                        let nextY = player.y + player.vy * dt;

                        // ì¶©ëŒ ê²€ì‚¬ (ë²½ í†µê³¼ ë°©ì§€)
                        if (MazeGame.engine.canMoveToPos(nextX, player.y)) {
                            player.x = nextX;
                        } else {
                            player.vx = 0;
                        }

                        if (MazeGame.engine.canMoveToPos(player.x, nextY)) {
                            player.y = nextY;
                        } else {
                            player.vy = 0;
                        }

                        // ë°©í–¥ ì „í™˜ (vx, vy ê¸°ì¤€)
                        if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
                            if (Math.abs(player.vx) > Math.abs(player.vy)) {
                                state.playerDirection = player.vx > 0 ? "right" : "left";
                            } else {
                                state.playerDirection = player.vy > 0 ? "down" : "up";
                            }
                        }

                        // ì¶©ëŒ ë° ê²Œì„ ë¡œì§
                        MazeGame.engine.checkGoal();
                        MazeGame.engine.tryCollectItems();
                        MazeGame.engine.draw();
                        MazeGame.engine.drawMiniMap();

                        // ë‹¤ìŒ í”„ë ˆì„
                        requestAnimationFrame(MazeGame.engine.update.bind(MazeGame.engine));
                    } catch (e) {
                        console.warn('update error', e);
                    }
                },

                draw(nowTs) {
                    const { ctx, gameCanvas } = MazeGame.dom;
                    const { player, tileSize, rows, cols, maze, goal, items, blockImages, itemImages } = MazeGame.state;
                    ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                    const offsetX = gameCanvas.width / 2 - player.x * tileSize;
                    const offsetY = gameCanvas.height / 2 - player.y * tileSize;

                    // ë²½ ë Œë”ë§ ìµœì í™”
                    const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
                    for (let y = 0; y < rows; y++) {
                        for (let x = 0; x < cols; x++) {
                            if (maze[y]?.[x] === 1 && !visited[y][x]) {
                                let drawn = false;

                                // 1. ê°€ì¥ í° ë¸”ë¡ë¶€í„° ìš°ì„ ì ìœ¼ë¡œ í™•ì¸ (ê°€ë¡œ 1x3)
                                if (x + 2 < cols && maze[y][x + 1] === 1 && maze[y][x + 2] === 1 && !visited[y][x + 1] && !visited[y][x + 2]) {
                                    ctx.drawImage(blockImages["1x3"], x * tileSize + offsetX, y * tileSize + offsetY, tileSize * 3, tileSize);
                                    visited[y][x] = visited[y][x + 1] = visited[y][x + 2] = true;
                                    drawn = true;
                                }
                                // 2. ê°€ë¡œ 1x2 í™•ì¸
                                else if (x + 1 < cols && maze[y][x + 1] === 1 && !visited[y][x + 1]) {
                                    ctx.drawImage(blockImages["1x2"], x * tileSize + offsetX, y * tileSize + offsetY, tileSize * 2, tileSize);
                                    visited[y][x] = visited[y][x + 1] = true;
                                    drawn = true;
                                }
                                // 3. ì„¸ë¡œ 3x1 í™•ì¸
                                else if (y + 2 < rows && maze[y + 1]?.[x] === 1 && maze[y + 2]?.[x] === 1 && !visited[y + 1]?.[x] && !visited[y + 2]?.[x]) {
                                    ctx.drawImage(blockImages["3x1"], x * tileSize + offsetX, y * tileSize + offsetY, tileSize, tileSize * 3);
                                    visited[y][x] = visited[y + 1][x] = visited[y + 2][x] = true;
                                    drawn = true;
                                }
                                // 4. ì„¸ë¡œ 2x1 í™•ì¸
                                else if (y + 1 < rows && maze[y + 1]?.[x] === 1 && !visited[y + 1]?.[x]) {
                                    ctx.drawImage(blockImages["2x1"], x * tileSize + offsetX, y * tileSize + offsetY, tileSize, tileSize * 2);
                                    visited[y][x] = visited[y + 1][x] = true;
                                    drawn = true;
                                }

                                // 5. ë§ëŠ” ë¸”ë¡ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ 1x1 ë¸”ë¡ì„ ê·¸ë¦½ë‹ˆë‹¤.
                                if (!drawn) {
                                    ctx.drawImage(blockImages["1x1"], x * tileSize + offsetX, y * tileSize + offsetY, tileSize, tileSize);
                                    visited[y][x] = true;
                                }
                            } else if (maze[y]?.[x] === 0) {
                                ctx.fillStyle = "white";
                                ctx.fillRect(x * tileSize + offsetX, y * tileSize + offsetY, tileSize, tileSize);
                            }
                        }
                    }

                    // ëª©í‘œ, ì•„ì´í…œ, í”Œë ˆì´ì–´ ë Œë”ë§
                    ctx.fillStyle = "green";
                    ctx.fillRect(goal.x * tileSize + offsetX, goal.y * tileSize + offsetY, tileSize, tileSize);

                    for (const it of items) {
                        const img = itemImages[it.type];
                        const size = tileSize * 0.8;
                        const px = it.x * tileSize + tileSize / 2 - size / 2 + offsetX;
                        const py = it.y * tileSize + tileSize / 2 - size / 2 + offsetY;
                        if (img) ctx.drawImage(img, px, py, size, size);
                    }

                    // âœ… í”Œë ˆì´ì–´ ë Œë”ë§
                    const { playerImages, playerDirection } = MazeGame.state;
                    const psize = tileSize * player.size;
                    const img = playerImages[playerDirection];

                    // í”Œë ˆì´ì–´ë¥¼ í™”ë©´ ì¤‘ì•™ì— ê·¸ë¦½ë‹ˆë‹¤ (ì¹´ë©”ë¼ ë”°ë¼ ì´ë™)
                    const drawX = gameCanvas.width / 2 - psize / 2;
                    const drawY = gameCanvas.height / 2 - psize / 2;

                    // âœ… í”Œë ˆì´ì–´ ì£¼ë³€ì„ ë°©ë¬¸í•œ ê³³ìœ¼ë¡œ í‘œì‹œ
                    const px = Math.floor(MazeGame.state.player.x);
                    const py = Math.floor(MazeGame.state.player.y);
                    if (MazeGame.state.visitedMap[py] && MazeGame.state.visitedMap[py][px] !== undefined) {
                        MazeGame.state.visitedMap[py][px] = true;
                    }


                    if (img && img.complete) {
                        ctx.drawImage(img, drawX, drawY, psize, psize);
                    } else {
                        // fallback: ê¸°ì¡´ ë¹¨ê°„ ë„¤ëª¨
                        ctx.fillStyle = "red";
                        ctx.fillRect(drawX, drawY, psize, psize);
                    }

                    const rem = this.getRemainingSeconds();
                    this.drawTimer(rem);
                    this.drawUrgency(nowTs, rem);
                },

                drawMiniMap() {
                    const { miniCtx, miniCanvas } = MazeGame.dom;
                    const { cols, rows, visitedMap, maze, goal, items, player } = MazeGame.state;
                    const w = miniCanvas.width, h = miniCanvas.height;
                    const cellW = w / cols, cellH = h / rows;

                    miniCtx.fillStyle = '#030303'; miniCtx.fillRect(0, 0, w, h);

                    for (let y = 0; y < rows; y++) {
                        for (let x = 0; x < cols; x++) {
                            if (visitedMap[y]?.[x] && maze[y]?.[x] === 0) {
                                miniCtx.fillStyle = '#bfbfbf';
                                miniCtx.fillRect(x * cellW, y * cellH, cellW, cellH);
                            }
                        }
                    }

                    miniCtx.fillStyle = '#2ecc71'; miniCtx.fillRect(goal.x * cellW + cellW * 0.15, goal.y * cellH + cellH * 0.15, cellW * 0.7, cellH * 0.7);

                    for (const it of items) {
                        if (visitedMap[it.y]?.[it.x]) {
                            miniCtx.beginPath();
                            miniCtx.fillStyle = (it.type === 'key') ? '#ffcc00' : '#7f5cff';
                            miniCtx.arc((it.x + 0.5) * cellW, (it.y + 0.5) * cellH, Math.min(cellW, cellH) * 0.25, 0, Math.PI * 2);
                            miniCtx.fill();
                        }
                    }
                    miniCtx.fillStyle = '#ff4b4b';
                    miniCtx.beginPath();
                    miniCtx.arc(player.x * cellW, player.y * cellH, Math.min(cellW, cellH) * 0.32, 0, Math.PI * 2);
                    miniCtx.fill();
                },

                drawTimer(rem) {
                    const { ctx } = MazeGame.dom;
                    const text = `${Math.floor(rem / 60)}:${String(Math.floor(rem) % 60).padStart(2, '0')}`;
                    ctx.save();
                    ctx.font = '18px sans-serif';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = rem <= 10 ? 'tomato' : '#fff';
                    ctx.fillText(`ì‹œê°„: ${text}`, 12, 14);
                    ctx.restore();
                },

                drawUrgency(nowTs, rem) {
                    if (rem > 20) return;
                    const { ctx, gameCanvas } = MazeGame.dom;
                    const p = Math.max(0, Math.min(1, rem / 20));
                    const startR = Math.max(gameCanvas.width, gameCanvas.height) * 0.9;
                    const endR = Math.min(gameCanvas.width, gameCanvas.height) * 0.12;
                    const radius = endR + (startR - endR) * p;
                    const pulseSpeed = 6 + (1 - p) * 18;
                    const pulseAmount = 1 + 0.06 * (1 - p) * Math.sin(nowTs / 1000 * pulseSpeed);
                    const drawR = radius * pulseAmount;
                    const cx = gameCanvas.width / 2, cy = gameCanvas.height / 2;

                    ctx.save();
                    ctx.fillStyle = `rgba(120,10,10,${0.22 + (1 - p) * 0.28})`;
                    ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath(); ctx.arc(cx, cy, drawR, 0, Math.PI * 2); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.beginPath(); ctx.arc(cx, cy, drawR, 0, Math.PI * 2);
                    ctx.lineWidth = Math.max(3, (1 - p) * 18);
                    ctx.strokeStyle = `rgba(255,80,80,${Math.min(1, 0.8 - p * 0.5 + (1 - p) * 0.2)})`;
                    ctx.stroke();
                    ctx.beginPath(); ctx.arc(cx, cy, drawR - (ctx.lineWidth * 0.6), 0, Math.PI * 2);
                    ctx.lineWidth = 1.2;
                    ctx.strokeStyle = `rgba(255,200,200,${0.18 + (1 - p) * 0.25})`;
                    ctx.stroke();
                    ctx.restore();
                },
                canMoveToPos(x, y) {
                    const { player, maze } = MazeGame.state;
                    const { inBounds } = MazeGame.utils;
                    const half = player.size / 2;
                    const corners = [{ x: x - half, y: y - half }, { x: x + half, y: y - half }, { x: x - half, y: y + half }, { x: x + half, y: y + half }];
                    for (const c of corners) {
                        const tx = Math.floor(c.x), ty = Math.floor(c.y);
                        if (!inBounds(tx, ty) || maze[ty]?.[tx] === 1) return false;
                    }
                    return true;
                },

                tryCollectItems() {
                    const { state, utils, ui, storage } = MazeGame;
                    for (let i = state.items.length - 1; i >= 0; i--) {
                        const it = state.items[i];
                        if (utils.dist(state.player.x, state.player.y, it.x + 0.5, it.y + 0.5) < 0.8) {
                            it.collected = true;
                            state.items.splice(i, 1);
                            if (it.type === 'key') {
                                state.hasKey = true;
                                storage.unlockNote('key');
                                ui.showToast('ë¬¼ìë¥¼ ì–»ì—ˆë‹¤.');
                            } else if (it.type === 'note') {
                                state.hasNoteInCurrentLevel = true;
                                state.currentLevelNoteId = it.storyId;

                                // âœ… ìª½ì§€ ì¦‰ì‹œ íšë“ (ë„ê° ë°˜ì˜)
                                storage.unlockNote(it.storyId);

                                ui.showToast('ìª½ì§€ë¥¼ ì–»ì—ˆë‹¤.');
                            } else {
                                ui.showToast('ì•„ì´í…œ íšë“');
                            }
                            ui.updateHud();
                        }
                    }
                },

                checkGoal() {
                    const { state, utils, ui, storage } = MazeGame;
                    if (state.levelCleared) return;

                    if (utils.dist(state.player.x, state.player.y, state.goal.x + 0.5, state.goal.y + 0.5) < 0.8) {
                        if (state.hasKey) {
                            state.levelCleared = true;
                            MazeGame.storage.advanceSpawnIndex(); // âœ… ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™
                            MazeGame.storage.saveLevel(state.level + 1); // âœ… ë‹¤ìŒ ë ˆë²¨ ì €ì¥
                            const nextLevel = state.level + 1;
                            const MAX_LEVEL = 15;
                            if (state.level >= MAX_LEVEL) {
                                ui.showLoadingOverlay('ì—”ë”©ì„ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤...');
                                setTimeout(() => {
                                    ui.hideOverlay();
                                    storage.unlockNote('ending');
                                    ui.showStoryOverlay('ì—”ë”©', MazeGame.config.STORY_TEXTS.ending[0], 0);
                                }, 800);
                                return;
                            }
                            ui.showLoadingOverlay(`ë ˆë²¨ ${nextLevel} ë¡œë”© ì¤‘...`);
                            setTimeout(() => {
                                state.level = nextLevel;
                                this.startLevel(state.level);
                                ui.hideOverlay();
                                state.levelCleared = false;
                                state.lastTime = performance.now();
                            }, 700);
                        } else {
                            ui.showToast("ì•„ì´í…œì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ë¬¼ìë¥¼ ëª¨ì•„ì•¼ í•©ë‹ˆë‹¤.", 1800);
                        }
                    }
                },
                getRemainingSeconds: () => Math.max(0, MazeGame.state.timeLimitSeconds - ((Date.now() - MazeGame.state.startTime) / 1000)),

                handleTimeUp() {
                    if (MazeGame.state.timeUp) return;
                    MazeGame.audio.stopBGM(); // âœ… ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš”
                    MazeGame.state.timeUp = true;
                    const elapsedTotal = ((Date.now() - MazeGame.state.startTime) / 1000).toFixed(1);
                    MazeGame.ui.showGameOverOverlay({ title: 'ì‹œê°„ ì´ˆê³¼!', message: `í”Œë ˆì´íƒ€ì„: ${elapsedTotal}ì´ˆ\në ˆë²¨ì„ ë‹¤ì‹œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?` });
                },
                checkTimeout() {
                    if (this.getRemainingSeconds() <= 0) this.handleTimeUp();
                },

                revealAround(px, py) {
                    const { state, utils } = MazeGame;
                    const cx = Math.floor(px), cy = Math.floor(py);
                    const revealRadius = 3;
                    for (let dy = -revealRadius; dy <= revealRadius; dy++) {
                        for (let dx = -revealRadius; dx <= revealRadius; dx++) {
                            const x = cx + dx, y = cy + dy;
                            if (utils.inBounds(x, y)) state.revealMap[y][x] = true;
                        }
                    }
                    if (utils.inBounds(cx, cy) && state.maze[cy][cx] === 0) state.visitedMap[cy][cx] = true;
                },

                generateMaze(w, h) {
                    const { state, utils } = MazeGame;
                    state.cols = w; state.rows = h;
                    state.maze = Array.from({ length: h }, () => Array(w).fill(1));
                    const stack = [{ x: 1, y: 1 }];
                    state.maze[1][1] = 0;
                    const deltas = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                    while (stack.length) {
                        const cur = stack[stack.length - 1];
                        const neighbors = deltas.filter(d => {
                            const nx = cur.x + d[0], ny = cur.y + d[1];
                            return utils.inBounds(nx, ny) && state.maze[ny][nx] === 1;
                        });
                        if (neighbors.length === 0) { stack.pop(); continue; }
                        const ch = neighbors[Math.floor(Math.random() * neighbors.length)];
                        state.maze[cur.y + ch[1] / 2][cur.x + ch[0] / 2] = 0;
                        state.maze[cur.y + ch[1]][cur.x + ch[0]] = 0;
                        stack.push({ x: cur.x + ch[0], y: cur.y + ch[1] });
                    }

                    const possibleGoals = [];
                    for (let x = 1; x < w - 1; x++) { if (state.maze[1][x] === 0) possibleGoals.push({ x, y: 0 }); }
                    for (let x = 1; x < w - 1; x++) { if (state.maze[h - 2][x] === 0) possibleGoals.push({ x, y: h - 1 }); }
                    for (let y = 1; y < h - 1; y++) { if (state.maze[y][1] === 0) possibleGoals.push({ x: 0, y }); }
                    for (let y = 1; y < h - 1; y++) { if (state.maze[y][w - 2] === 0) possibleGoals.push({ x: w - 1, y }); }
                    state.goal = possibleGoals.length ? possibleGoals[Math.floor(Math.random() * possibleGoals.length)] : { x: w - 2, y: h - 2 };
                    state.maze[state.goal.y][state.goal.x] = 2;

                    state.revealMap = Array.from({ length: h }, () => Array(w).fill(false));
                    state.visitedMap = Array.from({ length: h }, () => Array(w).fill(false));
                },

                findRandomPathCell(avoidNearStart = true) {
                    const { state, utils } = MazeGame;
                    for (let tries = 0; tries < 5000; tries++) {
                        const x = utils.randInt(1, state.cols - 2);
                        const y = utils.randInt(1, state.rows - 2);
                        if (state.maze[y][x] !== 0) continue;
                        if (avoidNearStart && (Math.abs(x - 1) < 4 && Math.abs(y - 1) < 4)) continue;
                        if (avoidNearStart && (Math.abs(x - state.goal.x) < 4 && Math.abs(y - state.goal.y) < 4)) continue;
                        return { x, y };
                    }
                    return { x: 1, y: 1 }; // Fallback
                },

                placeItemsForLevel() {
                    const { state, storage, config } = MazeGame;
                    state.items = [];
                    const k = this.findRandomPathCell(true);
                    state.items.push({ type: 'key', x: k.x, y: k.y, collected: false, storyId: 'key' });

                    const noteIdToSpawn = storage.getCurrentNoteForLevel(state.level);
                    if (!noteIdToSpawn) {
                        const uncollected = config.ALL_NOTE_IDS.filter(id => !state.collectedStories[id]);
                        noteIdToSpawn = uncollected.length ? uncollected[Math.floor(Math.random() * uncollected.length)] : config.ALL_NOTE_IDS[0];
                    }
                    state.currentLevelNoteId = noteIdToSpawn;
                    const p = this.findRandomPathCell(true);
                    state.items.push({ type: 'note', x: p.x, y: p.y, collected: false, storyId: noteIdToSpawn, message: config.STORY_TEXTS[noteIdToSpawn] });
                },

                // in MazeGame.engine
                startLevel(lv) {
                    return new Promise(resolve => {
                        // âœ… í˜¹ì‹œ ë‚¨ì•„ìˆì„ ìˆ˜ ìˆëŠ” ì˜¤ë²„ë ˆì´ ë‹«ê¸°
                        MazeGame.dom.overlay.style.display = 'none';
                        MazeGame.dom.overlayPanel.innerHTML = '';

                        const { state, ui, utils } = MazeGame;
                        state.hasKey = false;
                        state.hasNoteInCurrentLevel = false;

                        const PATHS = {
                            CITY_CORE: "img/tiles/city_core/",
                            CITY_OUT: "img/tiles/city_out/",
                            SHOP: "img/tiles/shop/",
                            MANSION: "img/tiles/mansion/",
                            MANSION_NAVY: "img/tiles/mansion_navy/",
                            OUT_GREEN: "img/tiles/out_green/",
                            OUT_FOREST: "img/tiles/out_forest/",
                            OUT_EARTH: "img/tiles/out_earth/",
                        };
                        const TILE_SET_SEQUENCE = [
                            null,
                            PATHS.CITY_CORE,
                            PATHS.SHOP,
                            PATHS.CITY_CORE,
                            PATHS.MANSION,
                            PATHS.MANSION_NAVY,
                            PATHS.CITY_OUT,
                            PATHS.OUT_GREEN,
                            PATHS.OUT_GREEN,
                            PATHS.OUT_FOREST,
                            PATHS.OUT_FOREST,
                            PATHS.OUT_EARTH
                        ];
                        const basePath = TILE_SET_SEQUENCE[lv] || PATHS.RUINS;

                        // âœ… block ì´ë¯¸ì§€ ë¡œë”© (fallback ë° ì—ëŸ¬ ì²´í¬ ì¶”ê°€)
                        const keys = ["1x1", "1x2", "1x3", "2x1", "3x1"];
                        const loadPromises = keys.map(key => {
                            return new Promise(resolveImg => {
                                const img = new Image();
                                img.onload = () => {
                                    state.blockImages[key] = img;
                                    resolveImg();
                                };
                                img.onerror = () => {
                                    console.warn(`âš ï¸ ë¸”ë¡ ì´ë¯¸ì§€ ëˆ„ë½: ${basePath}block_${key}.png â€” ê¸°ë³¸ block_1x1.png ì‚¬ìš©`);
                                    img.src = `${basePath}block_1x1.png`; // fallback
                                    state.blockImages[key] = img;
                                    resolveImg();
                                };
                                img.src = `${basePath}block_${key}.png`;
                            });
                        });

                        // ëª¨ë“  ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ í›„ ì‹¤í–‰
                        Promise.all(loadPromises).then(() => {
                            state.level = lv;
                            // MazeGame.audio.playBGM(lv); // âœ… ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš”
                            state.cols = 21 + (lv - 1) * 2;
                            state.rows = 21 + (lv - 1) * 2;
                            if (state.cols % 2 === 0) state.cols++;
                            if (state.rows % 2 === 0) state.rows++;

                            state.timeLimitSeconds = utils.getTimeLimitForLevel(lv);
                            state.startTime = Date.now();
                            state.timeUp = false;

                            this.generateMaze(state.cols, state.rows);
                            Object.assign(state.player, { x: 1.5, y: 1.5, vx: 0, vy: 0 });
                            state.levelCleared = false;
                            this.placeItemsForLevel();
                            this.revealAround(state.player.x, state.player.y);
                            ui.updateHud();

                            resolve();

                            // MazeGame.audio.playBGM(lv); // âœ… ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš”
                        });

                    });
                },


                playBgmForLevel(level) {
                    const bgm = document.getElementById('bgm');
                    if (!bgm) return;

                    let src = '';
                    if (level >= 1 && level <= 3) src = `${basePath}audio/bgm_center.mp3`;
                    else if (level >= 4 && level <= 5) src = `${basePath}audio/bgm_mansion.mp3`;
                    else if (level >= 6 && level <= 12) src = `${basePath}audio/bgm_outer.mp3`;
                    else if (level >= 13 && level <= 15) src = `${basePath}audio/bgm_field.mp3`;

                    if (bgm.src.endsWith(src)) return; // ì´ë¯¸ ê°™ì€ ê³¡ì´ë©´ êµì²´ ì•ˆ í•¨

                    bgm.pause();
                    bgm.src = src;
                    bgm.volume = 0.4;
                    bgm.load();
                    bgm.play().catch(e => console.warn('BGM ì¬ìƒ ì‹¤íŒ¨', e));
                },


                showIntroStart() {
                    MazeGame.audio.stopBGM(); // âœ… ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš”
                    const introText = MazeGame.config.STORY_TEXTS.intro[0];
                    const { overlayPanel, overlay } = MazeGame.dom;
                    overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">í”„ë¡¤ë¡œê·¸</h3><p>${introText}</p><div class="actions"><button class="primary" id="startBtn">ê²Œì„ ì‹œì‘</button></div>`;
                    // overlayPanel.innerHTML = `<h3 style="margin:0 0 6px">í”„ë¡¤ë¡œê·¸</h3><p>ê¹Šì€ ë¯¸ê¶ ì†ìœ¼ë¡œ ë°œì„ ë‚´ë”›ì—ˆë‹¤. ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ íƒí—˜ì„ ì‹œì‘í•˜ì„¸ìš”.</p><div class="actions"><button class="primary" id="startBtn">ê²Œì„ ì‹œì‘</button></div>`;
                    overlay.style.display = 'flex';

                    document.getElementById('startBtn').onclick = () => {
                        MazeGame.storage.unlockNote('intro');

                        // âœ… BGM ì¬ìƒ í—ˆìš© (ì‚¬ìš©ì í´ë¦­ ì‹œ 1íšŒ ì‹¤í–‰)
                        const bgm = document.getElementById('bgm');
                        if (bgm && bgm.paused) {
                            bgm.volume = 0; // ë¬´ìŒìœ¼ë¡œ ì¬ìƒ
                            bgm.play().then(() => {
                                bgm.pause(); // ì¼ë‹¨ ì •ì§€ (ì´ ì‹œì ì—ì„œ autoplay í—ˆìš©ë¨)
                                bgm.currentTime = 0;
                                bgm.volume = 0.4; // ì‹¤ì œ ì¬ìƒ ì‹œ ë³¼ë¥¨ ë³µì›
                                localStorage.setItem('audioUnlocked', 'true'); // âœ… ë‹¤ìŒë¶€í„°ëŠ” ìë™ ì‹¤í–‰ ê°€ëŠ¥
                                // MazeGame.state.audioReady = true; // âœ… ì´ì œ í—ˆìš©ë¨
                            }).catch(err => console.warn('ğŸ”‡ ì´ˆê¸° BGM í—ˆìš© ì‹¤íŒ¨:', err));
                        }

                        overlay.style.display = 'none';
                        overlayPanel.innerHTML = '';

                        // âœ… ì§„í–‰ ì¤‘ ë ˆë²¨ ë¶ˆëŸ¬ì˜¤ê¸°
                        MazeGame.storage.loadLevel();

                        // âœ… ë£¨í”„ ë‹¤ì‹œ ì‹œì‘
                        MazeGame.state.isRunning = true;
                        MazeGame.state.timeUp = false;

                        MazeGame.engine.startLevel(MazeGame.state.level).then(() => {
                            requestAnimationFrame(MazeGame.engine.update.bind(MazeGame.engine));
                        });
                    };

                }
            },

            /**
             * 10. ì´ˆê¸°í™” (Initialization)
             * - ê²Œì„ ì‹œì‘ì— í•„ìš”í•œ ëª¨ë“  ìš”ì†Œë¥¼ ì„¤ì •í•˜ê³  ì‹¤í–‰í•©ë‹ˆë‹¤.
             */
            init() {
                // âœ… ì´ˆê¸°í™” ì‹œ ì•½ê°„ì˜ ì§€ì—°ì„ ì£¼ì–´ ëª¨ë°”ì¼ ì´ˆê¸° ë¡œë”© ì•ˆì •í™”
                setTimeout(() => {

                    // DOM ìš”ì†Œ ìºì‹±
                    this.dom = {
                        gameCanvas: document.getElementById('game'),
                        ctx: document.getElementById('game').getContext('2d'),
                        miniCanvas: document.getElementById('miniMap'),
                        miniCtx: document.getElementById('miniMap').getContext('2d'),
                        overlay: document.getElementById('overlay'),
                        overlayPanel: document.getElementById('overlayPanel'),
                        codexOverlay: document.getElementById('codexOverlay'),
                        codexPanel: document.getElementById('codexPanel'),
                        codexBtn: document.getElementById('codexBtn'),
                        homeBtn: document.getElementById('homeBtn'),
                        freshStartBtn: document.getElementById('freshStartBtn'),
                        levelText: document.getElementById('levelText'),
                        itemKeyEl: document.getElementById('itemKeyEl'),
                        itemCompassEl: document.getElementById('itemCompassEl'),
                        joystick: document.getElementById('joystick'),
                        stick: document.getElementById('stick')
                    };

                    // ì´ë¯¸ì§€ ê°ì²´ ì´ˆê¸°í™”
                    this.state.itemImages["note"].src = "img/item/Letter.png";
                    this.state.itemImages["key"].src = "img/item/Bread.png";
                    ["1x1", "1x2", "1x3", "2x1", "3x1"].forEach(key => this.state.blockImages[key] = new Image());

                    this.state.playerImages.up.src = "img/player/player_up.png";
                    this.state.playerImages.down.src = "img/player/player_down.png";
                    this.state.playerImages.left.src = "img/player/player_left.png";
                    this.state.playerImages.right.src = "img/player/player_right.png";

                    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë°”ì¸ë”©
                    document.getElementById('resetSpawn').addEventListener('click', () => {
                        this.storage.resetSpawnSession();
                        this.ui.showToast('ì„¸ì…˜ ìŠ¤í° ìˆœì„œ ì´ˆê¸°í™” ì™„ë£Œ.');
                    });
                    this.dom.codexBtn.addEventListener('click', () => this.codex.open());
                    this.dom.homeBtn.addEventListener('click', () => this.engine.showIntroStart());
                    this.dom.freshStartBtn.addEventListener('click', () => {
                        if (!confirm('ì •ë§ ì²˜ìŒë¶€í„° ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ë„ê°/íšë“í•œ ìª½ì§€ ëª¨ë‘ ì´ˆê¸°í™”ë©ë‹ˆë‹¤)')) return;
                        this.storage.resetCollectedStories();
                        this.storage.resetSpawnSession();
                        this.storage.resetLevelProgress(); // âœ… ë ˆë²¨ ì´ˆê¸°í™” ì¶”ê°€
                        this.ui.updateHud();
                        this.ui.showToast('ë„ê°ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
                        this.engine.showIntroStart();
                    });
                    // âœ… í‚¤ë³´ë“œ ì…ë ¥ ì¶”ê°€
                    document.addEventListener('keydown', e => {
                        const p = MazeGame.state.player;
                        const s = MazeGame.state.speed / 2; // ì´ë™ ì†ë„ (ì¡°ì´ìŠ¤í‹±ë³´ë‹¤ ì‚´ì§ ëŠë¦¬ê²Œ)
                        switch (e.key) {
                            case 'ArrowUp':
                            case 'w':
                                p.vy = -s;
                                MazeGame.state.playerDirection = "up";
                                break;
                            case 'ArrowDown':
                            case 's':
                                p.vy = s;
                                MazeGame.state.playerDirection = "down";
                                break;
                            case 'ArrowLeft':
                            case 'a':
                                p.vx = -s;
                                MazeGame.state.playerDirection = "left";
                                break;
                            case 'ArrowRight':
                            case 'd':
                                p.vx = s;
                                MazeGame.state.playerDirection = "right";
                                break;
                        }
                    });

                    document.addEventListener('keyup', e => {
                        const p = MazeGame.state.player;
                        if (['ArrowUp', 'ArrowDown', 'w', 's'].includes(e.key)) p.vy = 0;
                        if (['ArrowLeft', 'ArrowRight', 'a', 'd'].includes(e.key)) p.vx = 0;
                    });


                    // ì´ˆê¸° ë°ì´í„° ë¡œë“œ ë° ì„¤ì •
                    this.storage.loadStories();
                    this.storage.loadLevel(); // âœ… ë§ˆì§€ë§‰ ë ˆë²¨ ë¶ˆëŸ¬ì˜¤ê¸°
                    this.input.init();
                    this.ui.updateHud();
                    this.state.lastTime = performance.now();

                    // âœ… overlay ê°•ì œ í‘œì‹œ (ëª¨ë°”ì¼ì—ì„œ ì´ˆê¸° ë Œë” ëˆ„ë½ ë°©ì§€)
                    this.dom.overlay.style.display = 'flex';

                    // âœ… ì˜¤ë””ì˜¤ í—ˆìš© ìƒíƒœ í™•ì¸ ë° ì²˜ë¦¬ (í„°ì¹˜/í´ë¦­ ì§€ì›)
                    const bgm = document.getElementById('bgm');
                    let hasAudioUnlock = localStorage.getItem('audioUnlocked') === 'true';

                    // ğŸ”¹ ì˜¤ë””ì˜¤ ê¶Œí•œ í•´ì œ ìƒíƒœë¼ë©´, ìœ ì € ìƒí˜¸ì‘ìš© ê¸°ë‹¤ë¦¬ê¸°
                    function unlockAudio() {
                        if (!bgm) return;
                        try {
                            bgm.volume = 0.4;
                            bgm.play()
                                .then(() => {
                                    console.log('ğŸµ ì˜¤ë””ì˜¤ ê¶Œí•œ íšë“ (í„°ì¹˜/í´ë¦­)');
                                    localStorage.setItem('audioUnlocked', 'true');
                                    hasAudioUnlock = true;

                                    // ë¦¬ìŠ¤ë„ˆ ì œê±° (í•œ ë²ˆë§Œ ì‹¤í–‰)
                                    document.removeEventListener('click', unlockAudio);
                                    document.removeEventListener('touchstart', unlockAudio);
                                    document.removeEventListener('pointerdown', unlockAudio);
                                })
                                .catch(err => console.warn('BGM ì¬ìƒ ì‹¤íŒ¨:', err));
                        } catch (err) {
                            console.warn('BGM play() ì˜ˆì™¸:', err);
                        }
                    }

                    // ğŸ”¹ ê¶Œí•œì´ ì—†ì„ ê²½ìš°: í´ë¦­Â·í„°ì¹˜Â·í¬ì¸í„° ì…ë ¥ì„ í•œ ë²ˆë§Œ ê°ì§€
                    if (!hasAudioUnlock) {
                        document.addEventListener('click', unlockAudio, { once: true });
                        document.addEventListener('touchstart', unlockAudio, { once: true });
                        document.addEventListener('pointerdown', unlockAudio, { once: true });
                        // } else {
                        //     // ğŸ”¹ ì´ë¯¸ ê¶Œí•œ ìˆìŒ â€” ë¬´ìŒìœ¼ë¡œ ë¯¸ë¦¬ í™œì„±í™” ì‹œë„
                        //     if (bgm && bgm.paused) {
                        //         bgm.volume = 0;
                        //         bgm.play().then(() => {
                        //             bgm.pause();
                        //             bgm.currentTime = 0;
                        //             bgm.volume = 0.4;
                        //             console.log('ğŸ¶ ì˜¤ë””ì˜¤ ìë™í™œì„±í™”');
                        //         }).catch(() => console.log('ğŸ”‡ ìë™ì¬ìƒì€ ì´ë²ˆ ì„¸ì…˜ì—ì„œ ì°¨ë‹¨ë¨ â€” í„°ì¹˜ ì‹œ ì¬í™œì„±í™”'));
                        //     }
                    }

                    // // âœ… ì˜¤ë””ì˜¤ í—ˆìš© ìƒíƒœ í™•ì¸ ë° ì²˜ë¦¬
                    // const bgm = document.getElementById('bgm');
                    // let hasAudioUnlock = localStorage.getItem('audioUnlocked') === 'true';

                    // const unlockAudio = () => {
                    //     if (bgm && bgm.paused) {
                    //         bgm.volume = 0.4;
                    //         bgm.play()
                    //             .then(() => {
                    //                 console.log('ğŸµ ì˜¤ë””ì˜¤ ê¶Œí•œ íšë“ (í„°ì¹˜/í´ë¦­)');
                    //                 localStorage.setItem('audioUnlocked', 'true');
                    //                 hasAudioUnlock = true;

                    //                 // í•œ ë²ˆë§Œ ë“±ë¡ë˜ê²Œ ì œê±°
                    //                 document.removeEventListener('click', unlockAudio);
                    //                 document.removeEventListener('touchstart', unlockAudio);
                    //                 document.removeEventListener('pointerdown', unlockAudio);
                    //             })
                    //             .catch(err => console.warn('BGM í—ˆìš© ì‹¤íŒ¨', err));
                    //     }
                    // };

                    // // ğŸ”¹ ì˜¤ë””ì˜¤ í—ˆìš© ì•ˆ ëœ ê²½ìš° â†’ ëª¨ë“  ì…ë ¥ë°©ì‹ì— ëŒ€í•´ í•œ ë²ˆë§Œ ë“±ë¡
                    // if (!hasAudioUnlock) {
                    //     document.addEventListener('click', unlockAudio, { once: true });
                    //     document.addEventListener('touchstart', unlockAudio, { once: true });
                    //     document.addEventListener('pointerdown', unlockAudio, { once: true });
                    // } else {
                    //     // ğŸ”¸ ì´ë¯¸ í—ˆìš©ë¨ â†’ ë¬´ìŒìœ¼ë¡œ ë¯¸ë¦¬ í™œì„±í™”
                    //     if (bgm && bgm.paused) {
                    //         bgm.volume = 0;
                    //         bgm.play().then(() => {
                    //             bgm.pause();
                    //             bgm.currentTime = 0;
                    //             bgm.volume = 0.4;
                    //             console.log('ğŸ¶ ì˜¤ë””ì˜¤ ìë™í™œì„±í™”');
                    //         }).catch(() => console.log('ğŸ”‡ ìë™ì¬ìƒì€ ì´ë²ˆ ì„¸ì…˜ì—ì„œ ì°¨ë‹¨ë¨ â€” í„°ì¹˜ ì‹œ ì¬í™œì„±í™”'));
                    //     }
                    // }

                    // // âœ… ì˜¤ë””ì˜¤ í—ˆìš© ìƒíƒœ í™•ì¸ ë° ì²˜ë¦¬
                    // const hasAudioUnlock = localStorage.getItem('audioUnlocked') === 'true';
                    // const bgm = document.getElementById('bgm');

                    // if (!hasAudioUnlock) {
                    //     // ğŸ”¸ ì²˜ìŒ ì ‘ì† â†’ ì˜¤ë””ì˜¤ í—ˆìš© ì•ˆ ë¨ â†’ ì‹œì‘ ë²„íŠ¼ ê°•ì œë¡œ ë„ì›€
                    //     this.engine.showIntroStart();

                    //     // ğŸ”¹ ë²„íŠ¼ ìƒì„± ì™„ë£Œ í›„ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (DOM ë°˜ì˜ íƒ€ì´ë° ë³´ì¥)
                    //     const tryBindAudio = () => {
                    //         const startBtn = document.getElementById('startBtn');
                    //         if (startBtn) {
                    //             startBtn.addEventListener('click', () => {
                    //                 if (bgm && bgm.paused) {
                    //                     bgm.volume = 0.4;
                    //                     bgm.play()
                    //                         .then(() => {
                    //                             console.log('ğŸµ ì˜¤ë””ì˜¤ ê¶Œí•œ íšë“');
                    //                             localStorage.setItem('audioUnlocked', 'true');
                    //                         })
                    //                         .catch(err => console.warn('BGM í—ˆìš© ì‹¤íŒ¨', err));
                    //                 }
                    //             }, { once: true });
                    //         } else {
                    //             // ë²„íŠ¼ì´ ì•„ì§ ì—†ìœ¼ë©´ ì•½ê°„ ëŠ¦ê²Œ ë‹¤ì‹œ ì‹œë„
                    //             setTimeout(tryBindAudio, 100);
                    //         }
                    //     };
                    //     tryBindAudio();
                    // } else {
                    //     // ğŸ”¸ ì´ë¯¸ ì˜¤ë””ì˜¤ í—ˆìš©ë¨ â†’ ë¬´ìŒìœ¼ë¡œ ë¯¸ë¦¬ í™œì„±í™”
                    //     if (bgm && bgm.paused) {
                    //         bgm.volume = 0;
                    //         bgm.play().then(() => {
                    //             bgm.pause();
                    //             bgm.currentTime = 0;
                    //             bgm.volume = 0.4;
                    //             console.log('ğŸ¶ ì˜¤ë””ì˜¤ ìë™í™œì„±í™”');
                    //         }).catch(err => console.warn('BGM ìë™í™œì„±í™” ì‹¤íŒ¨', err));
                    //     }
                    // }


                    // ê²Œì„ ì‹œì‘
                    // const hasAudioUnlock = localStorage.getItem('audioUnlocked') === 'true';

                    if (!this.state.collectedStories['intro']) {
                        // ğŸ“˜ ì²˜ìŒ ì ‘ì†í•œ ìœ ì € â€” intro ìŠ¤í† ë¦¬ ì—†ìœ¼ë©´ ì¸íŠ¸ë¡œë¶€í„° ì‹œì‘
                        // ì´ ê²½ìš° showIntroStart() ë‚´ë¶€ì— 'ì‹œì‘í•˜ê¸°' ë²„íŠ¼ì´ ì˜¤ë””ì˜¤ ê¶Œí•œì„ íšë“í•˜ê²Œ ë©ë‹ˆë‹¤.
                        this.engine.showIntroStart();
                    } else {
                        // ğŸ“— ì´ë¯¸ ì ‘ì†í–ˆë˜ ìœ ì € (intro ìŠ¤í† ë¦¬ íšë“í•¨)
                        if (hasAudioUnlock) {
                            // âœ… ì˜¤ë””ì˜¤ ê¶Œí•œì´ ì´ë¯¸ ìˆë‹¤ë©´ ìë™ìœ¼ë¡œ ì´ì–´ì„œ ì‹œì‘
                            this.engine.startLevel(this.state.level).then(() => {
                                requestAnimationFrame(this.engine.update.bind(this.engine));
                            });
                        } else {
                            // // ğŸ”¸ ì˜¤ë””ì˜¤ ê¶Œí•œì´ ì—†ìœ¼ë©´, ê¶Œí•œ íšë“ì„ ìœ„í•œ ì˜¤ë²„ë ˆì´ë¥¼ ë„ì›ë‹ˆë‹¤.
                            // // showIntroStart() í•¨ìˆ˜ë¥¼ ì¬ì‚¬ìš©í•˜ì—¬ 'ì´ì–´ì„œ ì‹œì‘' ë²„íŠ¼ì„ ë„ìš°ê³ ,
                            // // ì´ ë²„íŠ¼ì´ í´ë¦­ë  ë•Œ ì˜¤ë””ì˜¤ ê¶Œí•œì„ íšë“í•˜ê²Œ í•©ë‹ˆë‹¤.

                            // // --- ğŸš¨ ë³€ê²½í•  ë¶€ë¶„ ì‹œì‘ ğŸš¨ ---

                            // const { overlayPanel, overlay } = this.dom;
                            // const currentLevel = this.state.level;

                            // // ì¸íŠ¸ë¡œ í…ìŠ¤íŠ¸ ëŒ€ì‹  'ì´ì–´ì„œ ì‹œì‘' ë©”ì‹œì§€ ì‚¬ìš©
                            // overlayPanel.innerHTML = `
                            //     <h3 style="margin:0 0 6px">ê²Œì„ ë¡œë“œë¨</h3>
                            //     <p>ë ˆë²¨ ${currentLevel}ì—ì„œ ì´ì–´ì„œ ì‹œì‘í•©ë‹ˆë‹¤.</p>
                            //     <div class="actions">
                            //         <p>ì†Œë¦¬ë¥¼ ì¼œê³  í”Œë ˆì´í•˜ë ¤ë©´ 'ì´ì–´ì„œ ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
                            //         overlay.style.display = 'flex';
                            //         <button class="primary" id="continueBtn">ì´ì–´ì„œ ì‹œì‘</button>
                            //     </div>`;

                            // document.getElementById('continueBtn').onclick = () => {
                            //     overlay.style.display = 'none';
                            //     overlayPanel.innerHTML = '';

                            //     // BGM ê¶Œí•œ íšë“ ì‹œë„ (showIntroStart() ë‚´ë¶€ ë¡œì§ê³¼ ìœ ì‚¬)
                            //     const bgm = document.getElementById('bgm');
                            //     if (bgm && bgm.paused) {
                            //         bgm.volume = 0; // ë¬´ìŒìœ¼ë¡œ ì¬ìƒ
                            //         bgm.play().then(() => {
                            //             bgm.pause(); // ì¼ë‹¨ ì •ì§€ (ì´ ì‹œì ì—ì„œ autoplay í—ˆìš©ë¨)
                            //             bgm.currentTime = 0;
                            //             bgm.volume = 0.4; // ì‹¤ì œ ì¬ìƒ ì‹œ ë³¼ë¥¨ ë³µì›
                            //             localStorage.setItem('audioUnlocked', 'true');
                            //             console.log('ğŸµ ì˜¤ë””ì˜¤ ê¶Œí•œ íšë“ (ì´ì–´ì„œ ì‹œì‘)');
                            //         }).catch(err => console.warn('ğŸ”‡ BGM í—ˆìš© ì‹¤íŒ¨:', err));
                            //     }

                            //     // ë£¨í”„ ë‹¤ì‹œ ì‹œì‘ ë° ë ˆë²¨ ì‹œì‘
                            //     this.state.isRunning = true;
                            //     this.state.timeUp = false;

                            //     this.engine.startLevel(currentLevel).then(() => {
                            //         requestAnimationFrame(this.engine.update.bind(this.engine));
                            //     });
                            // }
                            // // --- ğŸš¨ ë³€ê²½í•  ë¶€ë¶„ ë ğŸš¨ ---

                            // // ğŸ”¸ ì˜¤ë””ì˜¤ ê¶Œí•œì´ ì—†ìœ¼ë©´, ê¶Œí•œ íšë“ì„ ìœ„í•œ ì˜¤ë²„ë ˆì´ë¥¼ ë„ì›ë‹ˆë‹¤.
                            // const { overlayPanel, overlay } = this.dom;
                            // const currentLevel = this.state.level;

                            // // ì¸íŠ¸ë¡œ í…ìŠ¤íŠ¸ ëŒ€ì‹  'ì´ì–´ì„œ ì‹œì‘' ë©”ì‹œì§€ ì‚¬ìš©
                            // overlayPanel.innerHTML = `
                            //     <h3 style="margin:0 0 6px">ê²Œì„ ë¡œë“œë¨</h3>
                            //     <p>ë ˆë²¨ ${currentLevel}ì—ì„œ ì´ì–´ì„œ ì‹œì‘í•©ë‹ˆë‹¤.</p>
                            //     <div class="actions">
                            //         <p>ì†Œë¦¬ë¥¼ ì¼œê³  í”Œë ˆì´í•˜ë ¤ë©´ 'ì´ì–´ì„œ ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
                            //         <button class="primary" id="continueBtn">ì´ì–´ì„œ ì‹œì‘</button>
                            //     </div>`;

                            // // ğŸ‘ˆ ğŸš¨ HTML êµ¬ì„±ì„ ë§ˆì¹œ í›„, ì´ ìœ„ì¹˜ì—ì„œ CSSë¥¼ ì ìš©í•©ë‹ˆë‹¤.
                            // overlay.style.display = 'flex';

                            // document.getElementById('continueBtn').onclick = () => {
                            //     // ... (ë‚˜ë¨¸ì§€ ë¡œì§ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)
                            //     overlay.style.display = 'none';
                            //     overlayPanel.innerHTML = '';
                            //     // ... (BGM ê¶Œí•œ íšë“ ë° startLevel í˜¸ì¶œ)

                            //     const bgm = document.getElementById('bgm');
                            //     if (bgm && bgm.paused) {
                            //         bgm.volume = 0; // ë¬´ìŒìœ¼ë¡œ ì¬ìƒ
                            //         bgm.play().then(() => {
                            //             bgm.pause(); // ì¼ë‹¨ ì •ì§€ (ì´ ì‹œì ì—ì„œ autoplay í—ˆìš©ë¨)
                            //             bgm.currentTime = 0;
                            //             bgm.volume = 0.4; // ì‹¤ì œ ì¬ìƒ ì‹œ ë³¼ë¥¨ ë³µì›
                            //             localStorage.setItem('audioUnlocked', 'true');
                            //             console.log('ğŸµ ì˜¤ë””ì˜¤ ê¶Œí•œ íšë“ (ì´ì–´ì„œ ì‹œì‘)');
                            //         }).catch(err => console.warn('ğŸ”‡ BGM í—ˆìš© ì‹¤íŒ¨:', err));
                            //     }

                            //     // ë£¨í”„ ë‹¤ì‹œ ì‹œì‘ ë° ë ˆë²¨ ì‹œì‘
                            //     this.state.isRunning = true;
                            //     this.state.timeUp = false;

                            //     this.engine.startLevel(currentLevel).then(() => {
                            //         requestAnimationFrame(this.engine.update.bind(this.engine));
                            //     });
                            // }
                            // ğŸ”¸ ì˜¤ë””ì˜¤ ê¶Œí•œì´ ì—†ìœ¼ë©´, ê¶Œí•œ íšë“ì„ ìœ„í•œ ì˜¤ë²„ë ˆì´ë¥¼ ë„ì›ë‹ˆë‹¤.

                            // --- ğŸš¨ ë³€ê²½í•  ë¶€ë¶„ ì‹œì‘ ğŸš¨ ---

                            // ğŸ‘ˆ this.dom ëŒ€ì‹  DOMì—ì„œ ì§ì ‘ ìš”ì†Œ ì°¸ì¡°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
                            const overlayPanel = document.getElementById('overlayPanel');
                            const overlay = document.getElementById('overlay');

                            const currentLevel = this.state.level;

                            if (!overlay || !overlayPanel) {
                                console.error('Overlay DOM elements not found!');
                                // ìš”ì†Œê°€ ì—†ìœ¼ë©´ ì—¬ê¸°ì„œ ì‹¤í–‰ ì¤‘ë‹¨
                                return;
                            }

                            // 1. ì˜¤ë²„ë ˆì´ íŒ¨ë„ì— HTML ì½˜í…ì¸  ì„¤ì •
                            overlayPanel.innerHTML = `
                                <h3 style="margin:0 0 6px">ê²Œì„ ë¡œë“œë¨</h3>
                                <p>ë ˆë²¨ ${currentLevel}ì—ì„œ ì´ì–´ì„œ ì‹œì‘í•©ë‹ˆë‹¤.</p>
                                <div class="actions">
                                    <p>ì†Œë¦¬ë¥¼ ì¼œê³  í”Œë ˆì´í•˜ë ¤ë©´ 'ì´ì–´ì„œ ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
                                    <button class="primary" id="continueBtn">ì´ì–´ì„œ ì‹œì‘</button>
                                </div>`;

                            // 2. ì˜¤ë²„ë ˆì´ í‘œì‹œ (displayë¥¼ 'flex'ë¡œ ì„¤ì •)
                            overlay.style.display = 'flex';
                            // // âœ… í•œ í”„ë ˆì„ ë’¤ì— HUD í‘œì‹œ (ëª¨ë°”ì¼ì—ì„œ ë Œë”ë§ í™•ì • ë³´ì¥)
                            // requestAnimationFrame(() => {
                            //     this.ui.showToast('ê²Œì„ ë¡œë“œë¨');
                            // });
                            // overlay.style.setProperty('display', 'flex', 'important');

                            // 3. ë²„íŠ¼ì— ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
                            document.getElementById('continueBtn').onclick = () => {
                                // ... (ê¸°ì¡´ BGM ê¶Œí•œ íšë“ ë° startLevel ë¡œì§)
                                overlay.style.display = 'none'; // ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
                                overlayPanel.innerHTML = '';

                                const bgm = document.getElementById('bgm');
                                if (bgm && bgm.paused) {
                                    bgm.volume = 0;
                                    bgm.play().then(() => {
                                        bgm.pause();
                                        bgm.currentTime = 0;
                                        bgm.volume = 0.4;
                                        localStorage.setItem('audioUnlocked', 'true');
                                        console.log('ğŸµ ì˜¤ë””ì˜¤ ê¶Œí•œ íšë“ (ì´ì–´ì„œ ì‹œì‘)');
                                    }).catch(err => console.warn('ğŸ”‡ BGM í—ˆìš© ì‹¤íŒ¨:', err));
                                }

                                this.state.isRunning = true;
                                this.state.timeUp = false;

                                this.engine.startLevel(currentLevel).then(() => {
                                    requestAnimationFrame(this.engine.update.bind(this.engine));
                                });
                            }
                            // --- ğŸš¨ ë³€ê²½í•  ë¶€ë¶„ ë ğŸš¨ ---
                        }
                    }
                    // }

                    // if (!this.state.collectedStories['intro']) {
                    //     // ğŸ“˜ ì²˜ìŒ ì ‘ì†í•œ ìœ ì € â€” intro ìŠ¤í† ë¦¬ ì—†ìœ¼ë©´ ì¸íŠ¸ë¡œë¶€í„° ì‹œì‘
                    //     this.engine.showIntroStart();
                    // } else {
                    //     // âœ… ì˜¤ë””ì˜¤ ê¶Œí•œì´ ì´ë¯¸ ìˆë‹¤ë©´ ìë™ìœ¼ë¡œ ì´ì–´ì„œ ì‹œì‘
                    //     if (hasAudioUnlock) {
                    //         this.engine.startLevel(this.state.level).then(() => {
                    //             requestAnimationFrame(this.engine.update.bind(this.engine));
                    //         });
                    //     } else {
                    //         // ğŸ”¸ ì˜¤ë””ì˜¤ ê¶Œí•œì´ ì—†ìœ¼ë©´ intro í™”ë©´ë§Œ ë„ì›Œì„œ í´ë¦­ìœ¼ë¡œ íšë“
                    //         this.engine.showIntroStart();
                    //     }
                    // }

                    // ê²Œì„ ì‹œì‘
                    // if (!this.state.collectedStories['intro']) {
                    //     this.engine.showIntroStart();
                    // } else {
                    //     this.engine.startLevel(this.state.level).then(() => {
                    //         requestAnimationFrame(this.engine.update.bind(this.engine));
                    //     });
                    // }

                    document.getElementById('bgmToggle').addEventListener('click', () => {
                        MazeGame.audio.toggle();
                    });


                    // ë””ë²„ê·¸ìš© ì „ì—­ ì ‘ê·¼
                    window._GAME = {
                        getState: () => this.state,
                        resetStories: () => { this.storage.resetCollectedStories(); alert('stories reset'); },
                        resetSpawnSession: () => { this.storage.resetSpawnSession(); alert('spawn session reset'); }
                    };





                }, 200); // âœ… ì•½ê°„ì˜ ì§€ì—°ìœ¼ë¡œ ëª¨ë°”ì¼ localStorage ì¤€ë¹„ ì‹œê°„ í™•ë³´
            }
        }

        // DOMì´ ë¡œë“œëœ í›„ ê²Œì„ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        window.addEventListener('DOMContentLoaded', () => {
            MazeGame.init();
            document.addEventListener('touchstart', () => {
                const bgm = document.getElementById('bgm');
                bgm.volume = 0.4;
                bgm.play();
            }, { once: true });
        });

    </script>
</body>

</html>